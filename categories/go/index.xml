<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Ilija Eftimov</title>
    <link>https://ieftimov.com/categories/go/</link>
    <description>Recent content in go on Ilija Eftimov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © 2014 - 2019 Ilija Eftimov</copyright>
    <lastBuildDate>Sun, 05 Jan 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ieftimov.com/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        <item>
          <title>Make resilient Go net/http servers using timeouts, deadlines and context cancellation</title>
          <link>https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/</link>
          <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/</guid>
          <description>When it comes to timeouts, there are two types of people: those who know how tricky they can be, and those who are yet to find out.
As tricky as they are, timeouts are a reality in the connected world we live in. As I am writing this, on the other side of the table, two persons are typing on their smartphones, probably chatting to people very far from them. All made possible because of networks.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Test Doubles by Example</title>
          <link>https://ieftimov.com/post/testing-in-go-test-doubles-by-example/</link>
          <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-test-doubles-by-example/</guid>
          <description>One of the biggest misconceptions is that doubles are a specific implementation of mocks or other testing constructs that we use in testing.
Dummies, mocks, stubs, fakes, and spies ARE test doubles. Test double is the category of these test constructs. Over the years, there has been some confusion around this concept.
It is my observation that this confusion arises from the naming of testing constructs that the popular testing frameworks use.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Dependency Injection</title>
          <link>https://ieftimov.com/post/testing-in-go-dependency-injection/</link>
          <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-dependency-injection/</guid>
          <description>In software engineering, over the years folks have developed many patterns, techniques and refactoring maneuvers. Some have been long forgotten, while others have stood the test of times.
Such a long-standing technique is dependency injection. It is a concept and a programming technique where a construct is passed (injected) to another construct that depends on it.
In Golang, like in other languages, we use it to simplify our code and make it more testable.</description>
        </item>
      
    
      
        <item>
          <title>Simple Golang database seeding abstraction for Gorm</title>
          <link>https://ieftimov.com/post/simple-golang-database-seeding-abstraction-gorm/</link>
          <pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/simple-golang-database-seeding-abstraction-gorm/</guid>
          <description>One of the most feature-full ORMs for Go that I have worked with is Gorm. If you would like to learn more about it, I recommend checking out its official website and its documentation.
Image taken from Undraw.  Recenlty I wanted to write a small database seeding abstraction. Database seeding is a process in which an initial set of data is provided to a database when it is being set up or installed.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Fixtures</title>
          <link>https://ieftimov.com/post/testing-in-go-fixtures/</link>
          <pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-fixtures/</guid>
          <description>When I was researching the topic of test fixtures, I couldn&#39;t find much about their beginnings. My first search was about the name of the person who coined &amp;ldquo;test fixtures&amp;rdquo;. Unfortunately, that was not a fruitful edeavour. The next logical step was to look for etymology of the phrase &amp;ldquo;test fixtures&amp;rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Image taken from Undraw.  Judging by the Wiki page, it&#39;s clear that test fixutures as a concept has been heavily popularized by Ruby on Rails.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Subtests</title>
          <link>https://ieftimov.com/post/testing-in-go-subtests/</link>
          <pubDate>Sat, 27 Jul 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-subtests/</guid>
          <description>Before we begin: The content in this article assumes knowledge of table-driven tests in Go. If you are unfamiliar with the concept, read this article to familiarize yourself.
Image taken from Undraw.  With table-driven tests as the most popular testing approach, there is one annoying problem that every programmer will face: selective running of tests. That’s because the traditional approach of testing using table-driven tests in a single test function is not decomposable in granular subfunctions.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Table-Driven Tests</title>
          <link>https://ieftimov.com/post/testing-in-go-table-driven-tests/</link>
          <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-table-driven-tests/</guid>
          <description>Coming from Ruby, which has excellent testing tools and libraries, the notion of table-driven tests was unusual for me. The popular testing libraries in Ruby, like RSpec, force the programmer to approach testing from a BDD standpoint. Thus, coming to Go and learning about the table-driven test was definitely a new way of looking at tests for me.
Image taken from Undraw.  Looking back, Dave Cheney&#39;s 2013 seminal blog post &amp;ldquo;Writing table driven-tests in Go&amp;rdquo; was very likely my gateway to table-driven tests.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: go test</title>
          <link>https://ieftimov.com/post/testing-in-go-go-test/</link>
          <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-go-test/</guid>
          <description>As I was going down the stairs I remember feeling the temperature dropping. It was an astounding experience descending towards the basement in my grandparents&amp;rsquo; house – it felt cooler and quieter. The light was warm and dimmed, with creepy shadows dropping behind the old furniture that was serving its last years before getting disposed to the city cleaning service.
Image taken from Undraw.  One of the rooms in the basement was my grandfather’s workshop.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Naming Conventions</title>
          <link>https://ieftimov.com/post/testing-in-go-naming-conventions/</link>
          <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-naming-conventions/</guid>
          <description>Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when it comes to testing. Some are defined in the language itself (official), while others are coined by community members (unofficial).
In this article we will look at the naming conventions for files, functions and variables separately.
Image taken from Undraw.  File and package naming conventions Go&#39;s testing package comes with an expectation that any test file must have a _test.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Writing Practical Failure Messages</title>
          <link>https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/</link>
          <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/</guid>
          <description>All developers appreciate code that works, yet we spend much of our working hours debugging existing code. When fixing existing code, what our test failures communicate is paramount to the debugging experience we have.
That&#39;s why in this article we will look at what it means to write a meaningful test failure message. We will look at its structure and how we can use some simple techniques to improve our test failure messages.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: Failing Tests</title>
          <link>https://ieftimov.com/post/testing-in-go-failing-tests/</link>
          <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-failing-tests/</guid>
          <description>In the previous article on testing in Golang, titled Testing in Go: First Principles, we looked at what testing looks like in Golang. In this article, we will do a deeper dive in the testing package. More specifically, we will take a look at the different ways we can fail tests in our test suites and when and how we should use these techniques.
Without further ado, let&#39;s take a look under the covers in the testing package.</description>
        </item>
      
    
      
        <item>
          <title>Testing in Go: First Principles</title>
          <link>https://ieftimov.com/post/testing-in-go-first-principles/</link>
          <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/testing-in-go-first-principles/</guid>
          <description>If you have any programming experience, whether that&#39;s as a student or a professional, there&#39;s a good chance you have heard about testing. It&#39;s an omnipresent topic, be it on conferences, books or articles. (See what I did there?)
Also, it seems like a topic that everyone agrees on - yes, testing is good and we should do it. There are many reasons why folks consider testing good for you code.</description>
        </item>
      
    
      
        <item>
          <title>Deep Dive in the Upcoming Go Error Inspection Changes</title>
          <link>https://ieftimov.com/post/deep-dive-in-upcoming-go-error-inspection-changes/</link>
          <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/deep-dive-in-upcoming-go-error-inspection-changes/</guid>
          <description>The team behind the language started working on a document titled &amp;ldquo;Go 2 Draft Designs&amp;rdquo;. The draft document is part of the design process for Go v2.0. In this article we will zoom in at the proposal for error inspection in Go 2.
What&#39;s worth noting is that this is still part of a draft proposal. Still, from where we are standing at the moment, it&#39;s certain that these changes will be added to the language starting Go v1.</description>
        </item>
      
    
      
        <item>
          <title>Tell your team you are running late using Google Home, Google Cloud Functions, Golang and Twilio</title>
          <link>https://ieftimov.com/post/tell-team-running-late-google-home-google-functions-golang-twilio/</link>
          <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/tell-team-running-late-google-home-google-functions-golang-twilio/</guid>
          <description>In this age of cloud platforms, Internet of Things and SaaS products that are easy to integrate with, the effort of automating parts of your life is shrinking down substantially with every year that goes by. Additionally, these services have very generous free plans (or are quite affordable), you won&#39;t have to pay a fortune for this automation. In this article I&#39;ll show you how you can create your own commands for your Google Home.</description>
        </item>
      
    
      
        <item>
          <title>Barebones model of Spotify&#39;s &#39;Recently Played&#39; screen using a Least Recently Used (LRU) cache in Golang</title>
          <link>https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/</link>
          <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/</guid>
          <description>One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.
Image taken from Undraw.  Before we go too much into details about the implementation of an LRU cache, let&#39;s first see what are the possible applications of this caching scheme.</description>
        </item>
      
    
      
        <item>
          <title>When and Why to use a Least Frequently Used (LFU) cache with an implementation in Golang</title>
          <link>https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/</link>
          <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/</guid>
          <description>Over the years, people involved in computer science and engineering have worked really hard on optimisations of various natures. Given that we live in a world with limited resources, humanity has always worked on ways to optimise the costs and speed literally everything.
In software engineering, I would argue, the most popular approach to performance improvement is caching. While there are various applications of caching, depending on the area of software engineering, the idea behind caching is quite simple: store data that is often needed/used in fast structure/storage so it can be retrieved very fast.</description>
        </item>
      
    
      
        <item>
          <title>Golang Datastructures: Trees</title>
          <link>https://ieftimov.com/post/golang-datastructures-trees/</link>
          <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/golang-datastructures-trees/</guid>
          <description>You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don’t understand them (which is what I had been doing for a while).
Image taken from Undraw.  Now, don&#39;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be.</description>
        </item>
      
    
      
        <item>
          <title>Data structures in Go: Stacks and queues</title>
          <link>https://ieftimov.com/post/golang-datastructures-stacks-queues/</link>
          <pubDate>Sat, 24 Feb 2018 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/golang-datastructures-stacks-queues/</guid>
          <description>In a previous post1, we took a look at linked lists and how we can apply them in a hypothetical use-case. In this post, we will look at two similar but powerful data structures.
Image taken from Undraw.  Modelling actions and history Think about Excel or Google docs. You know, the most ubiquitous applications for composing documents that humanity has invented. We&#39;ve all used them in some capacity. As you might know, these apps come with various actions one can apply to a text.</description>
        </item>
      
    
      
        <item>
          <title>Data structures in Go: Linked lists</title>
          <link>https://ieftimov.com/post/golang-datastructures-linked-lists/</link>
          <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/golang-datastructures-linked-lists/</guid>
          <description>Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.
Image taken from Undraw.  This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang.</description>
        </item>
      
    
      
        <item>
          <title>Create and manage MacOS LaunchAgents using Go</title>
          <link>https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/</link>
          <pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/</guid>
          <description>If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don&#39;t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.
For those unfamiliar, a daemon is a program running in the background without requiring user input. A typical daemon might, for instance, perform daily maintenance tasks or scan a device for malware when connected.</description>
        </item>
      
    
      
        <item>
          <title>Packing multiple binaries in a Golang package</title>
          <link>https://ieftimov.com/post/golang-package-multiple-binaries/</link>
          <pubDate>Tue, 23 Jan 2018 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/golang-package-multiple-binaries/</guid>
          <description>Recently, while writing a small Golang program for setting reminders I came across a small confusion that I guess most newcomers to Golang will have - how to organise a package in a way that will enable it to cleanly contain two or more binaries.
This post is not aimed at experienced Golang programmers, it&#39;s mostly aimed at beginners to understand how to compose more complex packages, beyond making the usual &amp;ldquo;one package one binary&amp;rdquo; ones.</description>
        </item>
      
    
  </channel>
</rss>


