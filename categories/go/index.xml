<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Ilija Eftimov ⚡️</title><link>https://ieftimov.com/categories/go/</link><description>Recent content in go on Ilija Eftimov ⚡️</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright 2021 © Ilija Eftimov</copyright><lastBuildDate>Fri, 22 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ieftimov.com/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing in Go: Stop Leaking Files</title><link>https://ieftimov.com/post/testing-in-go-stop-leaking-files/</link><pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-stop-leaking-files/</guid><description>No test suite is perfect. Some test suites are missing good helper functions; others are under-configured or over-customize. Some have obsolete packages included and are left unmaintained. Folks that have experience with more mature projects will likely agree that all of the above can be found in the wild.
Often, when we test our Go programs, need to create files. Such files can be just fixture files, or whole file trees, to set up the correct environment for the tests to run.</description></item><item><title>Testing in Go: HTTP Servers</title><link>https://ieftimov.com/post/testing-in-go-testing-http-servers/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-testing-http-servers/</guid><description>Go&amp;rsquo;s a great hammer for a lot of nails, one of the areas where I find it fitting is building HTTP servers. The net/http package of Go&amp;rsquo;s standard library makes it easy to attach HTTP handlers to any Go program. What I find delightful is that Go&amp;rsquo;s standard library, also has packages that make testing HTTP servers as easy as building them.
Nowadays, it&amp;rsquo;s widely accepted that test coverage is important and useful.</description></item><item><title>Testing in Go: Clean Tests Using t.Cleanup</title><link>https://ieftimov.com/post/testing-in-go-clean-tests-using-t-cleanup/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-clean-tests-using-t-cleanup/</guid><description>Go v1.14 ships with improvements across different aspects of the language. Two of them are brand new t.Cleanup, and b.Cleanup methods, added to the testing package.
The introduction of these methods will make it easier for our tests to clean up after themselves. This was always achievable through the careful composition of (sub)tests and helper functions, but since Go 1.14, the testing package will ship with one right way to do that.</description></item><item><title>Testing in Go: Golden Files</title><link>https://ieftimov.com/post/testing-in-go-golden-files/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-golden-files/</guid><description>Hardcoding the expected values in an assertion is a straightforward approach in testing. Most of the time, we know the expected output of the unit under test, so simply adding the raw value to the assertion works well.
Things can get tricky when we are testing a unit whose output is cumbersome to hardcode. The straightforward remedy is to extract this cumbersome value to a file that we can then read and compare the output of the unit under test to the output of the file.</description></item><item><title>Make resilient Go net/http servers using timeouts, deadlines and context cancellation</title><link>https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/</link><pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/</guid><description>When it comes to timeouts, there are two types of people: those who know how tricky they can be, and those who are yet to find out.
As tricky as they are, timeouts are a reality in the connected world we live in. As I am writing this, on the other side of the table, two persons are typing on their smartphones, probably chatting to people very far from them. All made possible because of networks.</description></item><item><title>Testing in Go: Test Doubles by Example</title><link>https://ieftimov.com/post/testing-in-go-test-doubles-by-example/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-test-doubles-by-example/</guid><description>One of the biggest misconceptions is that doubles are a specific implementation of mocks or other testing constructs that we use in testing.
Dummies, mocks, stubs, fakes, and spies ARE test doubles. Test double is the category of these test constructs. Over the years, there has been some confusion around this concept.
It is my observation that this confusion arises from the naming of testing constructs that the popular testing frameworks use.</description></item><item><title>Testing in Go: Dependency Injection</title><link>https://ieftimov.com/post/testing-in-go-dependency-injection/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-dependency-injection/</guid><description>In software engineering, over the years folks have developed many patterns, techniques and refactoring maneuvers. Some have been long forgotten, while others have stood the test of times.
Such a long-standing technique is dependency injection. It is a concept and a programming technique where a construct is passed (injected) to another construct that depends on it.
In Golang, like in other languages, we use it to simplify our code and make it more testable.</description></item><item><title>Simple Golang database seeding abstraction for Gorm</title><link>https://ieftimov.com/post/simple-golang-database-seeding-abstraction-gorm/</link><pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/simple-golang-database-seeding-abstraction-gorm/</guid><description>One of the most feature-full ORMs for Go that I have worked with is Gorm. If you would like to learn more about it, I recommend checking out its official website and its documentation.
Recenlty I wanted to write a small database seeding abstraction. Database seeding is a process in which an initial set of data is provided to a database when it is being set up or installed.</description></item><item><title>Testing in Go: Fixtures</title><link>https://ieftimov.com/post/testing-in-go-fixtures/</link><pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-fixtures/</guid><description>When I was researching the topic of test fixtures, I couldn&amp;rsquo;t find much about their beginnings. My first search was about the name of the person who coined &amp;ldquo;test fixtures&amp;rdquo;. Unfortunately, that was not a fruitful endeavor. The next logical step was to look for the etymology of the phrase &amp;ldquo;test fixtures&amp;rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Judging by the Wiki page, it&amp;rsquo;s clear that Ruby on Rails has heavily popularized test fixtures as a concept.</description></item><item><title>Testing in Go: Subtests</title><link>https://ieftimov.com/post/testing-in-go-subtests/</link><pubDate>Sat, 27 Jul 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-subtests/</guid><description>Before we begin: The content in this article assumes knowledge of table-driven tests in Go. If you are unfamiliar with the concept, read this article to familiarize yourself.
With table-driven tests as the most popular testing approach, there is one annoying problem that every programmer will face: running selective tests. That&amp;rsquo;s because the traditional method of testing using table-driven tests in a single test function is not decomposable in granular subfunctions.</description></item><item><title>Testing in Go: Table-Driven Tests</title><link>https://ieftimov.com/post/testing-in-go-table-driven-tests/</link><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-table-driven-tests/</guid><description>Coming from Ruby, which has excellent testing tools and libraries, the notion of table-driven tests was unusual for me. The widespread testing libraries in Ruby, such as RSpec, force the programmer to approach testing from a BDD standpoint. Thus, coming to Go and learning about the table-driven test was a new way of looking at tests for me.
Looking back, Dave Cheney&amp;rsquo;s 2013 seminal blog post &amp;ldquo;Writing table driven-tests in Go&amp;rdquo; was very likely my gateway to table-driven tests.</description></item><item><title>Testing in Go: go test</title><link>https://ieftimov.com/post/testing-in-go-go-test/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-go-test/</guid><description>If you remember anything from this article, remember this: go test is a command that automates the execution of test files and functions in a Go project. The go test command ships with Go itself, so if you have Golang installed, there&amp;rsquo;s nothing to check - it&amp;rsquo;s available on your machine.
go test will recompile each package and any files with names matching the file pattern *_test.go. These *_test.go files can contain test functions, benchmark functions, and example functions.</description></item><item><title>Testing in Go: Naming Conventions</title><link>https://ieftimov.com/post/testing-in-go-naming-conventions/</link><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-naming-conventions/</guid><description>Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when it comes to testing. Some are defined in the language itself (official), while others are coined by community members (unofficial).
In this article we will look at the naming conventions for files, functions and variables separately.
File and package naming conventions Go&amp;rsquo;s testing package comes with an expectation that any test file must have a _test.</description></item><item><title>Testing in Go: Writing Practical Failure Messages</title><link>https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/</link><pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/</guid><description>All developers appreciate code that works, yet we spend much of our working hours debugging existing code. When fixing existing code, what our test failures communicate is paramount to the debugging experience we have.
That&amp;rsquo;s why in this article we will look at what it means to write a meaningful test failure message. We will look at its structure and how we can use some simple techniques to improve our test failure messages.</description></item><item><title>Testing in Go: Failing Tests</title><link>https://ieftimov.com/post/testing-in-go-failing-tests/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-failing-tests/</guid><description>A short overview of the testing package The testing package from Golang&amp;rsquo;s standard library provides support for automated testing of Go packages. It is intended to be used in combination with the go test command. In combination with go test, this package expects certain naming conventions that we will cover in another article.
Still, for this article, we have to know that:
Every test file ends with *_test.go Every test function has the format TestXxx, where Xxx must not start with a lowercase letter The testing package exposes two different modes: testing and benchmarking.</description></item><item><title>Testing in Go: First Principles</title><link>https://ieftimov.com/post/testing-in-go-first-principles/</link><pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-first-principles/</guid><description>If you have any programming experience, whether that&amp;rsquo;s as a student or a professional, there&amp;rsquo;s a good chance you have heard about testing. It&amp;rsquo;s an omnipresent topic, be it at conferences, books, or articles. (See what I did there?)
Also, it seems like a topic that everyone agrees on - yes, testing is good, and we should do it. There are many reasons why folks consider testing good for your code&amp;rsquo;s quality.</description></item><item><title>Deep Dive in the Upcoming Go Error Inspection Changes</title><link>https://ieftimov.com/post/deep-dive-in-upcoming-go-error-inspection-changes/</link><pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/deep-dive-in-upcoming-go-error-inspection-changes/</guid><description>The team behind the language started working on a document titled &amp;ldquo;Go 2 Draft Designs&amp;rdquo;. The draft document is part of the design process for Go v2.0. In this article we will zoom in at the proposal for error inspection in Go 2.
What&amp;rsquo;s worth noting is that this is still part of a draft proposal. Still, from where we are standing at the moment, it&amp;rsquo;s certain that these changes will be added to the language starting Go v1.</description></item><item><title>Tell your team you are running late using Google Home, Google Cloud Functions, Golang and Twilio</title><link>https://ieftimov.com/post/tell-team-running-late-google-home-google-functions-golang-twilio/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/tell-team-running-late-google-home-google-functions-golang-twilio/</guid><description>In this age of cloud platforms, Internet of Things and SaaS products that are easy to integrate with, the effort of automating parts of your life is shrinking down substantially with every year that goes by. Additionally, these services have very generous free plans (or are quite affordable), you won&amp;rsquo;t have to pay a fortune for this automation. In this article I&amp;rsquo;ll show you how you can create your own commands for your Google Home.</description></item><item><title>Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang</title><link>https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/</guid><description>One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.
Before we go too much into details about the implementation of an LRU cache, let&amp;rsquo;s first see what are the possible applications of this caching scheme.</description></item><item><title>When and Why to use a Least Frequently Used (LFU) cache with an implementation in Golang</title><link>https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/</link><pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/</guid><description>Over the years, people involved in computer science and engineering have worked really hard on optimisations of various natures. Given that we live in a world with limited resources, humanity has always worked on ways to optimise the costs and speed literally everything.
In software engineering, I would argue, the most popular approach to performance improvement is caching. While there are various applications of caching, depending on the area of software engineering, the idea behind caching is quite simple: store data that is often needed/used in fast structure/storage so it can be retrieved very fast.</description></item><item><title>Golang Datastructures: Trees</title><link>https://ieftimov.com/post/golang-datastructures-trees/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/golang-datastructures-trees/</guid><description>You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don’t understand them (which is what I had been doing for a while).
Now, don&amp;rsquo;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be.</description></item><item><title>Data structures in Go: Stacks and queues</title><link>https://ieftimov.com/post/golang-datastructures-stacks-queues/</link><pubDate>Sat, 24 Feb 2018 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/golang-datastructures-stacks-queues/</guid><description>In a previous post1, we took a look at linked lists and how we can apply them in a hypothetical use-case. In this post, we will look at two similar but powerful data structures.
Modelling actions and history Think about Excel or Google docs. You know, the most ubiquitous applications for composing documents that humanity has invented. We&amp;rsquo;ve all used them in some capacity. As you might know, these apps come with various actions one can apply to a text.</description></item><item><title>Data structures in Go: Linked lists</title><link>https://ieftimov.com/post/golang-datastructures-linked-lists/</link><pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/golang-datastructures-linked-lists/</guid><description>Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.
This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang.</description></item><item><title>Create and manage MacOS LaunchAgents using Go</title><link>https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/</link><pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/</guid><description>If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don&amp;rsquo;t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.
For those unfamiliar, a daemon is a program running in the background without requiring user input. A typical daemon might, for instance, perform daily maintenance tasks or scan a device for malware when connected.</description></item><item><title>Packing multiple binaries in a Golang package</title><link>https://ieftimov.com/post/golang-package-multiple-binaries/</link><pubDate>Tue, 23 Jan 2018 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/golang-package-multiple-binaries/</guid><description>Recently, while writing a small Golang program for setting reminders I came across a small confusion that I guess most newcomers to Golang will have - how to organise a package in a way that will enable it to cleanly contain two or more binaries.
This post is not aimed at experienced Golang programmers, it&amp;rsquo;s mostly aimed at beginners to understand how to compose more complex packages, beyond making the usual &amp;ldquo;one package one binary&amp;rdquo; ones.</description></item></channel></rss>