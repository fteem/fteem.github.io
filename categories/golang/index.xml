<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Ilija Eftimov</title>
    <link>https://ieftimov.com/categories/golang/</link>
    <description>Recent content in Golang on Ilija Eftimov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 23 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ieftimov.com/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Deep Dive in the Upcoming Go Error Inspection Changes</title>
      <link>https://ieftimov.com/post/deep-dive-in-upcoming-go-error-inspection-changes/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/deep-dive-in-upcoming-go-error-inspection-changes/</guid>
      <description>The team behind the language started working on a document titled &amp;ldquo;Go 2 Draft Designs&amp;rdquo;. The draft document is part of the design process for Go v2.0. In this article we will zoom in at the proposal for error inspection in Go 2.
What&amp;rsquo;s worth noting is that this is still part of a draft proposal. Still, from where we are standing at the moment, it&amp;rsquo;s certain that these changes will be added to the language starting Go v1.</description>
    </item>
    
    <item>
      <title>My First dotGo Conference</title>
      <link>https://ieftimov.com/post/my-first-dotgo-conference/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/my-first-dotgo-conference/</guid>
      <description>This year&amp;rsquo;s dotGo in Paris was awesome. The people were great in general. The organisers and volunteers did a good job. The attendees that I interacted with were cool – I had some interesting conversations and made couple of connections. The talks were informative and engaging. If this is where you stop reading, please give dotGo a shot next year - I am sure it will be great! And please find me in the crowd and talk to me, because I&amp;rsquo;d love to talk to you.</description>
    </item>
    
    <item>
      <title>Tell your team you are running late using Google Home, Google Cloud Functions, Golang and Twilio</title>
      <link>https://ieftimov.com/post/tell-team-running-late-google-home-google-functions-golang-twilio/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/tell-team-running-late-google-home-google-functions-golang-twilio/</guid>
      <description>In this age of cloud platforms, Internet of Things and SaaS products that are easy to integrate with, the effort of automating parts of your life is shrinking down substantially with every year that goes by. Additionally, these services have very generous free plans (or are quite affordable), you won&amp;rsquo;t have to pay a fortune for this automation. In this article I&amp;rsquo;ll show you how you can create your own commands for your Google Home.</description>
    </item>
    
    <item>
      <title>Barebones model of Spotify&#39;s &#39;Recently Played&#39; screen using a Least Recently Used (LRU) cache in Golang</title>
      <link>https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/</guid>
      <description>One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.
Before we go too much into details about the implementation of an LRU cache, let&amp;rsquo;s first see what are the possible applications of this caching scheme.</description>
    </item>
    
    <item>
      <title>When and Why to use a Least Frequently Used (LFU) cache with an implementation in Golang</title>
      <link>https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/</guid>
      <description>Over the years, people involved in computer science and engineering have worked really hard on optimisations of various natures. Given that we live in a world with limited resources, humanity has always worked on ways to optimise the costs and speed literally everything.
In software engineering, I would argue, the most popular approach to performance improvement is caching. While there are various applications of caching, depending on the area of software engineering, the idea behind caching is quite simple: store data that is often needed/used in fast structure/storage so it can be retrieved very fast.</description>
    </item>
    
    <item>
      <title>Golang Datastructures: Trees</title>
      <link>https://ieftimov.com/post/golang-datastructures-trees/</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/golang-datastructures-trees/</guid>
      <description>You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don’t understand them (which is what I had been doing for a while).
Now, don&amp;rsquo;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be.</description>
    </item>
    
    <item>
      <title>Data structures in Go: Stacks and queues</title>
      <link>https://ieftimov.com/post/golang-datastructures-stacks-queues/</link>
      <pubDate>Sat, 24 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/golang-datastructures-stacks-queues/</guid>
      <description>In a previous post, we took a look at linked lists and how we can apply them in a hypothetical use-case. In this post, we will look at two similar but powerful data structures.
Modelling actions and history Think about Excel or Google docs. You know, the most ubiquitous applications for composing documents that humanity has invented. We&amp;rsquo;ve all used them in some capacity. As you might know, these apps come with various actions one can apply to a text.</description>
    </item>
    
    <item>
      <title>Data structures in Go: Linked lists</title>
      <link>https://ieftimov.com/post/golang-datastructures-linked-lists/</link>
      <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/golang-datastructures-linked-lists/</guid>
      <description>Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.
This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang.</description>
    </item>
    
    <item>
      <title>Create and manage MacOS LaunchAgents using Go</title>
      <link>https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/</link>
      <pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/</guid>
      <description>If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don&amp;rsquo;t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.
For those unfamiliar, a daemon is a program running in the background without requiring user input.</description>
    </item>
    
    <item>
      <title>Packing multiple binaries in a Golang package</title>
      <link>https://ieftimov.com/post/golang-package-multiple-binaries/</link>
      <pubDate>Tue, 23 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/golang-package-multiple-binaries/</guid>
      <description>Recently, while writing a small Golang program for setting reminders I came across a small confusion that I guess most newcomers to Golang will have - how to organise a package in a way that will enable it to cleanly contain two or more binaries.
This post is not aimed at experienced Golang programmers, it&amp;rsquo;s mostly aimed at beginners to understand how to compose more complex packages, beyond making the usual &amp;ldquo;one package one binary&amp;rdquo; ones.</description>
    </item>
    
  </channel>
</rss>