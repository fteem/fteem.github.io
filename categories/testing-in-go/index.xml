<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>testing-in-go on Ilija Eftimov ⚡️</title><link>https://ieftimov.com/categories/testing-in-go/</link><description>Recent content in testing-in-go on Ilija Eftimov ⚡️</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright 2021 © Ilija Eftimov</copyright><lastBuildDate>Fri, 22 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ieftimov.com/categories/testing-in-go/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing in Go: Stop Leaking Files</title><link>https://ieftimov.com/post/testing-in-go-stop-leaking-files/</link><pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-stop-leaking-files/</guid><description>No test suite is perfect. Some test suites are missing good helper functions; others are under-configured or over-customize. Some have obsolete packages included and are left unmaintained. Folks that have experience with more mature projects will likely agree that all of the above can be found in the wild.
Often, when we test our Go programs, need to create files. Such files can be just fixture files, or whole file trees, to set up the correct environment for the tests to run.</description></item><item><title>Testing in Go: WebSockets</title><link>https://ieftimov.com/post/testing-in-go-websockets/</link><pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-websockets/</guid><description>WebSockets offer duplex communication from a non-trusted source to a server that we own across a TCP socket connection. This means that, instead of continually polling the web server for updates and having to perform the whole TCP dance with each request, we can maintain a single TCP socket connection and then send and listen to messages on said connection.
In Go&amp;rsquo;s ecosystem there are few different implementations of the WebSocket protocol.</description></item><item><title>Testing in Go: HTTP Servers</title><link>https://ieftimov.com/post/testing-in-go-testing-http-servers/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-testing-http-servers/</guid><description>Go&amp;rsquo;s a great hammer for a lot of nails, one of the areas where I find it fitting is building HTTP servers. The net/http package of Go&amp;rsquo;s standard library makes it easy to attach HTTP handlers to any Go program. What I find delightful is that Go&amp;rsquo;s standard library, also has packages that make testing HTTP servers as easy as building them.
Nowadays, it&amp;rsquo;s widely accepted that test coverage is important and useful.</description></item><item><title>Testing in Go: Clean Tests Using t.Cleanup</title><link>https://ieftimov.com/post/testing-in-go-clean-tests-using-t-cleanup/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-clean-tests-using-t-cleanup/</guid><description>Go v1.14 ships with improvements across different aspects of the language. Two of them are brand new t.Cleanup, and b.Cleanup methods, added to the testing package.
The introduction of these methods will make it easier for our tests to clean up after themselves. This was always achievable through the careful composition of (sub)tests and helper functions, but since Go 1.14, the testing package will ship with one right way to do that.</description></item><item><title>Testing in Go: Golden Files</title><link>https://ieftimov.com/post/testing-in-go-golden-files/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-golden-files/</guid><description>Hardcoding the expected values in an assertion is a straightforward approach in testing. Most of the time, we know the expected output of the unit under test, so simply adding the raw value to the assertion works well.
Things can get tricky when we are testing a unit whose output is cumbersome to hardcode. The straightforward remedy is to extract this cumbersome value to a file that we can then read and compare the output of the unit under test to the output of the file.</description></item><item><title>Testing in Go: Test Doubles by Example</title><link>https://ieftimov.com/post/testing-in-go-test-doubles-by-example/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-test-doubles-by-example/</guid><description>One of the biggest misconceptions is that doubles are a specific implementation of mocks or other testing constructs that we use in testing.
Dummies, mocks, stubs, fakes, and spies ARE test doubles. Test double is the category of these test constructs. Over the years, there has been some confusion around this concept.
It is my observation that this confusion arises from the naming of testing constructs that the popular testing frameworks use.</description></item><item><title>Testing in Go: Dependency Injection</title><link>https://ieftimov.com/post/testing-in-go-dependency-injection/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-dependency-injection/</guid><description>In software engineering, over the years folks have developed many patterns, techniques and refactoring maneuvers. Some have been long forgotten, while others have stood the test of times.
Such a long-standing technique is dependency injection. It is a concept and a programming technique where a construct is passed (injected) to another construct that depends on it.
In Golang, like in other languages, we use it to simplify our code and make it more testable.</description></item><item><title>Testing in Go: Fixtures</title><link>https://ieftimov.com/post/testing-in-go-fixtures/</link><pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-fixtures/</guid><description>When I was researching the topic of test fixtures, I couldn&amp;rsquo;t find much about their beginnings. My first search was about the name of the person who coined &amp;ldquo;test fixtures&amp;rdquo;. Unfortunately, that was not a fruitful edeavour. The next logical step was to look for etymology of the phrase &amp;ldquo;test fixtures&amp;rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Judging by the Wiki page, it&amp;rsquo;s clear that test fixutures as a concept has been heavily popularized by Ruby on Rails.</description></item><item><title>Testing in Go: Subtests</title><link>https://ieftimov.com/post/testing-in-go-subtests/</link><pubDate>Sat, 27 Jul 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-subtests/</guid><description>Before we begin: The content in this article assumes knowledge of table-driven tests in Go. If you are unfamiliar with the concept, read this article to familiarize yourself.
With table-driven tests as the most popular testing approach, there is one annoying problem that every programmer will face: selective running of tests. That’s because the traditional approach of testing using table-driven tests in a single test function is not decomposable in granular subfunctions.</description></item><item><title>Testing in Go: Table-Driven Tests</title><link>https://ieftimov.com/post/testing-in-go-table-driven-tests/</link><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-table-driven-tests/</guid><description>Coming from Ruby, which has excellent testing tools and libraries, the notion of table-driven tests was unusual for me. The popular testing libraries in Ruby, like RSpec, force the programmer to approach testing from a BDD standpoint. Thus, coming to Go and learning about the table-driven test was definitely a new way of looking at tests for me.
Looking back, Dave Cheney&amp;rsquo;s 2013 seminal blog post &amp;ldquo;Writing table driven-tests in Go&amp;rdquo; was very likely my gateway to table-driven tests.</description></item><item><title>Testing in Go: go test</title><link>https://ieftimov.com/post/testing-in-go-go-test/</link><pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-go-test/</guid><description>If you remember anything from this article, remember this: go test is a command that automates the execution of test files and functions in a Go project. The go test command ships with Go itself, so if you have Golang installed, there&amp;rsquo;s nothing to check - it&amp;rsquo;s available on your machine.
go test will recompile each package and any files with names matching the file pattern *_test.go. These *_test.go files can contain test functions, benchmark functions, and example functions.</description></item><item><title>Testing in Go: Naming Conventions</title><link>https://ieftimov.com/post/testing-in-go-naming-conventions/</link><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-naming-conventions/</guid><description>Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when it comes to testing. Some are defined in the language itself (official), while others are coined by community members (unofficial).
In this article we will look at the naming conventions for files, functions and variables separately.
File and package naming conventions Go&amp;rsquo;s testing package comes with an expectation that any test file must have a _test.</description></item><item><title>Testing in Go: Writing Practical Failure Messages</title><link>https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/</link><pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/</guid><description>All developers appreciate code that works, yet we spend much of our working hours debugging existing code. When fixing existing code, what our test failures communicate is paramount to the debugging experience we have.
That&amp;rsquo;s why in this article we will look at what it means to write a meaningful test failure message. We will look at its structure and how we can use some simple techniques to improve our test failure messages.</description></item><item><title>Testing in Go: Failing Tests</title><link>https://ieftimov.com/post/testing-in-go-failing-tests/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-failing-tests/</guid><description>A short overview of the testing package The testing package from Golang&amp;rsquo;s standard library provides support for automated testing of Go packages. It is intended to be used in combination with the go test command. In combination with go test, this package expects certain naming conventions that we will cover in another article.
Still, for this article, we have to know that:
Every test file ends with *_test.go Every test function has the format TestXxx, where Xxx must not start with a lowercase letter The testing package exposes two different modes: testing and benchmarking.</description></item><item><title>Testing in Go: First Principles</title><link>https://ieftimov.com/post/testing-in-go-first-principles/</link><pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate><guid>https://ieftimov.com/post/testing-in-go-first-principles/</guid><description>If you have any programming experience, whether that&amp;rsquo;s as a student or a professional, there&amp;rsquo;s a good chance you have heard about testing. It&amp;rsquo;s an omnipresent topic, be it at conferences, books, or articles. (See what I did there?)
Also, it seems like a topic that everyone agrees on - yes, testing is good, and we should do it. There are many reasons why folks consider testing good for your code&amp;rsquo;s quality.</description></item></channel></rss>