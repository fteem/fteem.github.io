<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refactoring on Ilija Eftimov</title>
    <link>https://ieftimov.com/categories/refactoring/</link>
    <description>Recent content in Refactoring on Ilija Eftimov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Â© Ilija Eftimov</copyright>
    <lastBuildDate>Tue, 08 Mar 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ieftimov.com/categories/refactoring/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        <item>
          <title>Refactoring in Ruby: Primitive Obsession</title>
          <link>https://ieftimov.com/post/primitive-obsession-ruby/</link>
          <pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/primitive-obsession-ruby/</guid>
          <description>We&#39;ve all been at this point where we have bloated our classes with primitive values all over the place. Usually, we drop in primitive constants that, for whatever reason, we think that are a good fit to the class. Or sometimes, we just dump primitive values instead of small objects, thinking &amp;ldquo;it&#39;s okay, it&#39;s just an attribute in the class&amp;rdquo;. But, does it always make sense?
The problem Say we have a project for a finance journalist who wants us to automate his text editor to do some random fixes to his texts, on the fly.</description>
        </item>
      
    
      
        <item>
          <title>Refactoring in Ruby: The right place for a Builder?</title>
          <link>https://ieftimov.com/post/refactoring-builder-pattern/</link>
          <pubDate>Wed, 13 Jan 2016 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/refactoring-builder-pattern/</guid>
          <description>Recently I started tackling refactoring in Ruby with my blog posts. It seems that it&#39;s one of the most popular topics that people would like to read about, so here I am with another installment of refactoring in Ruby. This time, we will see if it&#39;s the right time and place for a Builder&amp;hellip; whatever that means.
Just a bit of backstory In my last post on refactoring in Ruby, I covered how to detect and refactor the long parameters code smell.</description>
        </item>
      
    
      
        <item>
          <title>Refactoring in Ruby: Smelly Parameters Lists</title>
          <link>https://ieftimov.com/post/refactoring-smelly-parameters-lists/</link>
          <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/refactoring-smelly-parameters-lists/</guid>
          <description>Ruby is a really clear and expressive language, but we developers sure know how to make a mess. Even when you think your classes are nicely written and tested, things can still get out of hand. I am pretty sure you&#39;ve heard one (or more) of your more experienced colleagues/mentors tell you that &amp;ldquo;something is smelly&amp;rdquo; in the code. Well, in this article we will cover one of the simplest code smells</description>
        </item>
      
    
      
        <item>
          <title>Refactoring in Ruby: TDD your way through Extract Class</title>
          <link>https://ieftimov.com/post/tdd-extract-class/</link>
          <pubDate>Mon, 28 Dec 2015 00:00:00 +0000</pubDate>
          
          <guid>https://ieftimov.com/post/tdd-extract-class/</guid>
          <description>There are a lot of refactoring patterns available out there for us. I assume that most of us use these patterns, at certain times without being aware that those refactoring steps are defined as a pattern in the past. In this post, I will take you through an example of refactoring Ruby code with the Extract Class pattern by using Test-Driven Development.
Let&#39;s dive in!
What went wrong at the test?</description>
        </item>
      
    
  </channel>
</rss>


