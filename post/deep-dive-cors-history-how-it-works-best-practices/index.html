<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deep dive in CORS: History, how it works, and best practices | Ilija Eftimov ‚ö°Ô∏è</title><meta name=keywords content><meta name=description content="Learn the history and evolution of same-origin policy and CORS, understand CORS and the different types of cross-origin access in depth, and learn best practices."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/deep-dive-cors-history-how-it-works-best-practices/><link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="Deep dive in CORS: History, how it works, and best practices"><meta property="og:description" content="Learn the history and evolution of same-origin policy and CORS, understand CORS and the different types of cross-origin access in depth, and learn best practices."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/deep-dive-cors-history-how-it-works-best-practices/"><meta property="og:image" content="https://ieftimov.com/cards/deep-dive-cors-history-how-it-works-best-practices.png"><meta property="article:published_time" content="2021-04-12T20:40:00+01:00"><meta property="article:modified_time" content="2021-04-12T20:40:00+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/deep-dive-cors-history-how-it-works-best-practices.png"><meta name=twitter:title content="Deep dive in CORS: History, how it works, and best practices"><meta name=twitter:description content="Learn the history and evolution of same-origin policy and CORS, understand CORS and the different types of cross-origin access in depth, and learn best practices."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Deep dive in CORS: History, how it works, and best practices","item":"https://ieftimov.com/post/deep-dive-cors-history-how-it-works-best-practices/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deep dive in CORS: History, how it works, and best practices","name":"Deep dive in CORS: History, how it works, and best practices","description":"The error in your browser\u0026amp;rsquo;s console  No \u0026amp;lsquo;Access-Control-Allow-Origin\u0026amp;rsquo; header is present on the requested resource.\n  Cross-Origin Request Blocked: The Same Origin ‚Ä¶","keywords":[],"articleBody":"The error in your browser‚Äôs console  No ‚ÄòAccess-Control-Allow-Origin‚Äô header is present on the requested resource.\n  Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://example.com/\n  Access to fetch at ‚Äòhttps://example.com‚Äô from origin ‚Äòhttp://localhost:3000‚Äô has been blocked by CORS policy.\n I am sure you‚Äôve seen one of these errors, or a variation, in your browser‚Äôs console. If you have not ‚Äì don‚Äôt fret, you soon will. There are enough CORS errors for all developers out there.\nThese popping-up during development can be annoying. But in fact, CORS is an incredibly useful mechanism in a world of misconfigured web servers, hostile actors on the web and organizations pushing the web standards ahead.\nBut let‚Äôs go back the beginning‚Ä¶\nIn the beginning was the first subresource A subresource is an HTML element that is requested to be embedded into the document, or executed in its context. In the year of 1993, the first subresource  was introduced. By introducing , the web got prettier. And more complex.\nBack to 1993  You see, if your browser would render a page with an  on it, it would actually have to go fetch that subresource from an origin. When a browser fetches said subresource from an origin that does not reside on the same scheme, fully qualified hostname or port ‚Äì that‚Äôs a cross-origin request.\nOrigins \u0026 cross-origin An origin is identified by a triple: scheme, fully qualified hostname and port. For example, http://example.com and https://example.com are different origins ‚Äì¬†the first uses http scheme and the second https. Also, the default http port is 80, while the https is 443. Therefore, in this example, the two origins differ by scheme and port, although the host is the same (example.com).\nYou get the idea ‚Äì if any of the three items in the triple are different, then the origin is different.\nAs an exercise if we run a comparison of the https://blog.example.com/posts/foo.html origin against other origins, we would get the following results:\n   URL Result Reason     https://blog.example.com/posts/bar.html Same Only the path differs   https://blog.example.com/contact.html Same Only the path differs   http://blog.example.com/posts/bar.html Different Different protocol   https://blog.example.com:8080/posts/bar.html Different Different port (https:// is port 443 by default)   https://example.com/posts/bar.html Different Different host    A cross-origin request means, for example, a resource (i.e. page) such as http://example.com/posts/bar.html that would try to render a subresource from the https://example.com origin (note the scheme change!).\nThe many dangers of cross-origin requests Now that we defined what same- and cross-origin is, let‚Äôs see what is the big deal.\nWhen we introduced  to the web, we opened the floodgates. Soon after the web got , , , , , ,  and so on. These subresources can be fetched by the browser after loading the page, therefore they can all be same- or cross-origin requests.\nLet‚Äôs travel to an imaginary world where CORS does not exist and web browsers allow all sorts of cross-origin requests.\nImagine I got a page on my website evil.com with a . On the surface it looks like a simple page, where you read some useful information. But in the , I have specially crafted code that will send a specially-crafted request to bank‚Äôs DELETE /account endpoint. Once you load the page, the JavaScript is executed and an AJAX call hits the bank‚Äôs API.\nPuff, your account is gone. üå¨  Mind-blowing ‚Äì¬†imagine while reading some information on a web page, you get an email from your bank that you‚Äôve successfully deleted your account. I know I know‚Ä¶ if it was THAT easy to do anything with a bank‚Äôs. I digress.\nFor my evil  to work, as part of the request your browser would also have to send your credentials (cookies) from the bank‚Äôs website. That‚Äôs how the bank‚Äôs servers would identify you and know which account to delete.\nLet‚Äôs look at a different, not-so-evil scenario.\nI want to detect folks that work for Awesome Corp, whose internal website is on intra.awesome-corp.com. On my website, dangerous.com I got an .\nFor users that do not have a session active with intra.awesome-corp.com, the avatar won‚Äôt render ‚Äì¬†it will produce an error. But, if you‚Äôre logged in the intranet of Awesome Corp., once you open my dangerous.com website I‚Äôll know that you have access.\nThat means that I will be able to derive some information about you. While it‚Äôs definitely harder for me to craft an attack, the knowledge that you have access to Awesome Corp. is still a potential attack vector.\nLeaking info to 3rd parties üí¶  While these two are overly-simplistic examples, it is this kind of threats that have made the same-origin policy \u0026 CORS neccessary. These are all different dangers of cross-origin requests. Some have been mitigated, others can‚Äôt be mitigated ‚Äì they‚Äôre rooted in the nature of the web. But for the plethora of attack vectors that have been squashed ‚Äì¬†it‚Äôs because of CORS.\nBut before CORS, there was the same-origin policy.\nSame-origin policy The same-origin policy prevents cross-origin attacks by blocking read access to resources loaded from a different origin. This policy still allows some tags, like , to embeds resources from a different origin.\nThe same-origin policy was introduced by Netscape Navigator 2.02 in 1995, originally intended to protect cross-origin access to the DOM.\nEven though same-origin policy implementations are not required to follow an exact specification, all modern browsers implement some form of it. The principles of the policy are described in RFC6454 of the Internet Engineering Task Force (IETF).\nThe implementation of the same-origin policy is defined with this ruleset:\n   Tags Cross-origin Note      Embedding permitted Depends on X-Frame-Options    Embedding permitted Proper Content-Type might be required    Writing permitted Cross-origin writes are common    Embedding permitted Cross-origin reading via JavaScript and loading it in a  is forbidden    /  Embedding permitted     Embedding permitted Access to certain APIs might be forbidden    Same-origin policy solves many challenges, but it is pretty restrictive. In the age of single-page applications and media-heavy websites, same-origin does not leave a lot of room for relaxation of or fine-tuning of these rules.\nCORS was born with the goals to relax the same-origin policy and to fine-tune cross-origin access.\nEnter CORS So far we covered what is an origin, how it‚Äôs defined, what the drawbacks of cross-origin requests are and the same-origin policy that browsers implement.\nNow it‚Äôs time to familiarize ourselves with Cross Origin Resource Sharing (CORS). CORS is a mechanism that allows control of access to subresources on a web page over a network. The mechanism classifies three different categories of subresource access:\n Cross-origin writes Cross-origin embeds Cross-origin reads  Before we go on to explain each of these categories, it‚Äôs important to realize that although your browser (by default) might allow a certain type of cross-origin request, that does not mean that said request will be accepted by the server.\nCross-origin writes are links, redirects, and form submissions. With CORS active in your browser, these are all allowed. There is also a thing called preflight request that fine-tunes cross-origin writes, so while some writes might be permitted by default it doesn‚Äôt mean they can go through in practice. We‚Äôll look into that a bit later.\nCross-origin embeds are subresources loaded via: , , , , , , ,  and more. These are all allowed by default.  is a special one ‚Äì as it‚Äôs purpose is to literally load a different page inside the frame, its cross-origin framing can be controlled by using the X-Frame-options header.\nWhen it comes to  and the other embeddable subresources ‚Äì it‚Äôs in their nature to trigger cross-origin requests. That‚Äôs why in CORS differentiates between cross-origin embeds and cross-origin reads, and treats them differently.\nCross-origin reads are subresources loaded via AJAX / fetch calls. These are by default blocked in your browser. There‚Äôs the workaround of embedding such subresources in a page, but such tricks are handled by another policy present in modern browsers.\nIf your browser is up to date, all of these heuristics are already implemented in it.\nCross-origin writes Cross-origin writes can be the very problematic. Let‚Äôs look into an example and see CORS in action.\nFirst, we‚Äôll have a simple Crystal (using Kemal) HTTP server:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  require \"kemal\" port = ENV[\"PORT\"].to_i || 4000 get \"/\" do \"Hello world!\" end get \"/greet\" do \"Hey!\" end post \"/greet\" do |env| name = env.params.json[\"name\"].as(String) \"Hello, #{name}!\" end Kemal.config.port = port Kemal.run   It simply takes a request at the /greet path, with a name in the request body, and returns a Hello #{name}!. To run this tiny Crystal server, we can boot it with:\n1  $ crystal run server.cr   This will boot the server and listen on localhost:4000. If we navigate to localhost:4000 in our browser, we will be presented a simple ‚ÄúHello World‚Äù page:\nHello, world! üåç  Now that we know our server is running, let‚Äôs execute a POST /greet to the server listening on localhost:4000, from the console of our browser page. We can do that by using fetch:\n1 2 3 4 5 6 7 8  fetch( 'http://localhost:4000/greet', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: 'Ilija'}) } ).then(resp = resp.text()).then(console.log)    Once we run it, we will see the greeting come back from the server:\nHi there! üëã  This was a POST request, but it was not cross-origin. We sent the request from the browser where http://localhost:4000 (the origin) was rendered, to that same origin.\nNow, let‚Äôs try the same request, but cross-origin. We will open https://google.com and try to send that same request from that tab in our browser:\nHello, CORS! üí£  We managed to get the famous CORS error. Athough our Crystal server can fulfil the request, our browser is protecting us from ourselves. It is basically telling us that a website that we have opened wants to make changes to another website as ourselves.\nIn the first example, where we sent the request to http://localhost:4000/greet from the tab that rendered http://localhost:4000, our browser looks at that request and lets it through because it appears that our website is calling our server (which is fine). But in the second example where our website (https://google.com) wants to write to http://localhost:4000, then our browser flags that request and does not let it go through.\nPreflight requests If we look deeper in our developer console, in the Network tab in particular, we will in fact notice two requests in place of the one that we sent:\nTwo outbound requests as seen in the Network panel  What is interesting to notice is that the first request has a HTTP method of OPTIONS, while the second has POST.\nIf we explore the OPTIONS request we will see that this is a request that has been sent by our browser prior to sending our POST request:\nLooking into the OPTIONS request üîç  What is interesting is that even though the response to the OPTIONS request was a HTTP 200, it was still marked as red in the request list. Why?\nThis is the preflight request that modern browsers do. A preflight request is performed for requests which CORS deems as complex. The criteria for complex request is:\n A request that uses methods other than GET, POST, or HEAD A request that includes headers other than Accept, Accept-Language or Content-Language A request that has a Content-Type header value other than application/x-www-form-urlencoded, multipart/form-data, or text/plain  Therefore in the above example, although we send a POST request, the browser considers our request complex due to the Content-Type: application/json header.\nIf we would change our server to handle text/plain content (instead of JSON), we can work around the need for a preflight request:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  require \"kemal\" get \"/\" do \"Hello world!\" end get \"/greet\" do \"Hey!\" end post \"/greet\" do |env| body = env.request.body name = \"there\" name = body.gets.as(String) if !body.nil? \"Hello, #{name}!\" end Kemal.config.port = 4000 Kemal.run   Now, when we can send our request with the Content-type: text/plain header:\n1 2 3 4 5 6 7 8 9 10 11 12  fetch( 'http://localhost:4000/greet', { method: 'POST', headers: { 'Content-Type': 'text/plain' }, body: 'Ilija' } ) .then(resp = resp.text()) .then(console.log)    Now, while the preflight request will not be sent, the CORS policy of the browser will keep on blocking:\nCORS standing strong  But because we have crafted a request which does not classify as complex, our browser actually won‚Äôt block the request:\nRequest went through ‚û°Ô∏è  Simply put: our server is misconfgured to accept text/plain cross-origin requests, without any other protection in place, and our browser can‚Äôt do much about that. But still, it does the next best thing ‚Äì it does not expose our opened page / tab to the response of that request. Therefore in this case, CORS does not block the request - it blocks the response.\nThe CORS policy of our browser considers this effectively a cross-origin read, because although the request is sent as POST, the Content-type header value makes it essentialy the same as a GET. And cross-origin reads are blocked by default, hence the blocked response we are seeing in our network tab.\nWorking around preflight requests like in the example above is not recommended. In fact, if you expect that your server will have to gracefully handle preflight requests, it should implement the OPTIONS endpoints and return the correct headers.\nWhen implementing the OPTIONS endpoint, you need to know that the preflight request of the browser looks for three headers in particular that can be present on the response:\n Access-Control-Allow-Methods ‚Äì it indicates which methods are supported by the response‚Äôs URL for the purposes of the CORS protocol. Access-Control-Allow-Headers - it indicates which headers are supported by the response‚Äôs URL for the purposes of the CORS protocol. Access-Control-Max-Age - it indicates the number of seconds (5 by default) the information provided by the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers can be cached.  Let‚Äôs go back to our previous example where we sent a complex request:\n1 2 3 4 5 6 7 8  fetch( 'http://localhost:4000/greet', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: 'Ilija'}) } ).then(resp = resp.text()).then(console.log)    We already confirmed that when we send this request, our browser will check with the server if it can perform the cross-origin request. To get this request working in a cross-origin environment, we have to first add the OPTIONS /greet endpoint to our server. In its response header, the new endpoint will have to inform the browser that the request to POST /greet, with Content-type: application/json header, from the origin https://www.google.com, can be accepted.\nWe‚Äôll do this by using the Access-Control-Allow-* headers:\n1 2 3 4 5 6 7 8  options \"/greet\" do |env| # Allow `POST /greet`... env.response.headers[\"Access-Control-Allow-Methods\"] = \"POST\" # ...with `Content-type` header in the request... env.response.headers[\"Access-Control-Allow-Headers\"] = \"Content-type\" # ...from https://www.google.com origin. env.response.headers[\"Access-Control-Allow-Origin\"] = \"https://www.google.com\" end   If we boot our server and send the request:\nStill blocked? ü§î  Our request remains blocked. Even though our OPTIONS /greet endpoint did allow the request, we are still seeing the error message. In our network tab there‚Äôs something interesting going on:\nOPTIONS is green! üéâ  The request to the OPTIONS /greet endpoint was a success! But the POST /greet call still failed. If we take a peek in the internals of the POST /greet request we will see a familiar sight:\nPOST is green too? üò≤  In fact, the request did succeed ‚Äì the server returned a HTTP 200. The preflight request did work ‚Äì the browser did make the POST request instead of blocking it. But the response of the POST request did not contain any CORS headers, so even though the browser did make the request, it blocked any response processing.\nTo allow the browser also process the response from the POST /greet request, we need to add a CORS header to the POST endpoint as well:\n1 2 3 4 5 6 7  post \"/greet\" do |env| name = env.params.json[\"name\"].as(String) env.response.headers[\"Access-Control-Allow-Origin\"] = \"https://www.google.com\" \"Hello, #{name}!\" end   By adding the Access-Control-Allow-Origin header response header, we tell the browser that a tab that has https://www.google.com open can also access the response payload.\nIf we give this another shot:\nPOST works!  We will see that POST /greet did get us a response, without any errors. If we take a peek in the Network tab, we‚Äôll see that both requests are green:\nOPTIONS \u0026 POST in action! üí™  By using proper response headers on our preflight endpoint OPTIONS /greet, we unlocked our server‚Äôs POST /greet endpoint to be accessed across different origin. On top of that, by providing a correct CORS response header on the response of the POST /greet endpoint, we freed the browser to process the response without any blocking.\nCross-origin reads As we mentioned before, cross-origin reads are blocked by default. That‚Äôs on purpose - we wouldn‚Äôt want to load other resources from other origints in the scope of our origin.\nSay, we have a GET /greet action in our Crystal server:\n1 2 3  get \"/greet\" do \"Hey!\" end   From our tab that has www.google.com rendered, if we try to fetch the GET /greet endpoint we will get blocked by CORS:\nCORS blocking üôÖ  If we look deeper in the request, we will found out something interesting:\nA successful GET üéâ  In fact, just like before, our browser did let the request through ‚Äì¬†we got a HTTP 200 back. But it did not expose our opened page / tab to the response of that request. Again, in this case CORS does not block the request - it blocks the response.\nJust like with cross-origin writes, we can relax CORS and make it available for cross-origin reading - by adding the Access-Control-Allow-Origin header:\n1 2 3 4  get \"/greet\" do |env| env.response.headers[\"Access-Control-Allow-Origin\"] = \"https://www.google.com\" \"Hey!\" end   When the browser gets the response back from the server, it will look at the Access-Control-Allow-Origin header and will decide based on its value if it can let the page read the response. Given that the value in this case is https://www.google.com which is the page that we use in our example the outcome will be a success:\nA successful cross-origin GET üéâ  This is how the browser shields us from cross-origin reads and respects the server directives that are sent via the headers.\nFine-tuning CORS As we already saw in previous examples, to relax the CORS policy of our website, we can set the Access-Control-Allow-Origin of our /greet action to the https://www.google.com value:\n1 2 3 4 5 6 7 8 9  post \"/greet\" do |env| body = env.request.body name = \"there\" name = body.gets.as(String) if !body.nil? env.response.headers[\"Access-Control-Allow-Origin\"] = \"https://www.google.com\" \"Hello, #{name}!\" end   This will allow the https://www.google.com origin to call our server, and our browser will feel fine about that. Having the Access-Control-Allow-Origin in place, we can try to execute the fetch call again:\nSuccess! üéâ  This made it work! With the new CORS policy, we can call our /greet action from our tab that has https://www.google.com rendered. Alternatively, we could also set the header value to *, which would tell the browser that the server can be called from any origin.\nSuch a configuration has to be carefully considered. Yet, putting relaxed CORS headers is almost always safe. One rule of thumb is: if you open the URL in an incognito tab, and you are happy with the information you are exposing, then you can set a permissive (*) CORS policy on said URL.\nAnother way to fine-tune CORS on our website is to use the Access-Control-Allow-Credentials response header. Access-Control-Allow-Credentials instructs browsers whether to expose the response to the frontend JavaScript code when the request‚Äôs credetials mode is include.\nThe request‚Äôs credentials mode comes from the introduction of the Fetch API, which has its roots back the original XMLHttpRequest objects:\n1 2 3  var client = new XMLHttpRequest() client.open(\"GET\", \"./\") client.withCredentials = true    With the introduction of fetch, the withCredentials option was transformed into an optional argument to the fetch call:\n1  fetch(\"./\", { credentials: \"include\" }).then(/* ... */)    The available options for the credentials options are omit, same-origin and include. The different modes are available so developers can fine-tune the outbound request, whereas the response from the server will inform the browser how to behave when credentials are sent with the request (via the Access-Control-Allow-Credentials header).\nThe Fetch API spec contains a well-written and thorough breakdown of the interplay of CORS and the fetch Web API, and the security mechanisms put in place by browsers.\nSome best practices Before we wrap it up, let‚Äôs cover some best practices when it comes to Cross Origin Resource Sharing (CORS).\nFree for all A common example is if you own a website that displays content for the public, that is not behind paywalls, or requiring authentication or authorization ‚Äì¬†you should be able to set Access-Control-Allow-Origin: * to its resources.\nThe * value is a good choice in cases when:\n No authentication or authorization is required The resource should be accessible to a wide range of users without restrictions The origins \u0026 clients that will access the resource is of great variety, you don‚Äôt have knowledge of it or you simply don‚Äôt care  A dangerous prospect of such configuration is when it comes to content served on private networks (i.e. behind firewall or VPN). When you are connected via a VPN, you have access to the files on the company‚Äôs network:\nOversimplification of VPNs  Now, if an attacker hosts as website dangerous.com, which contains a link to a file within the VPN, they can (in theory) create a script on their website that can access that file:\nFile leak  While such an attack is hard and requires a lot of knowledge about the VPN and the files stored within it, it is a potential attack vector that we must be aware of.\nKeeping it in the family Continuing with the example from above, imagine we want to implement analytics for our website. We would like our users' browsers to send us data about the experience and behavior of our users on our website.\nA common way to do this is to send that data periodically using asynchronous requests using JavaScript in the browser. On the backend we have a simple API that takes these requests from our users' browsers and stores the data on the backend for further processing.\nIn such cases, our API is public, but we don‚Äôt want any website to send data to our analytics API. In fact, we are interested only in requests that originate from browsers that have our website rendered ‚Äì¬†that is all.\n  In such cases, we want our API to set the Access-Control-Allow-Origin header to our website‚Äôs URL. That will make sure browsers never send requests to our API from other pages.\nIf users or other websites try to cram data in our analytics API, the Access-Control-Allow-Origin headers set on the resources of our API won‚Äôt let the request to go through:\n  NULL origins Another interesting case are null origins. They occur when a resource is accessed by a browser that renders a local file. For example, requests coming from some JavaScript running in a static file on your local machine have the Origin header set to null.\nIn such cases, if our servers do now allow access to resources for the null origin, then it can be a hindrance to the developer productivity. Allowing the null origin within your CORS policy has to be deliberately done, and only if the users of your website / product are developers.\nSkip cookies, if you can As we saw before with the Access-Control-Allow-Credentials, cookies are not enabled by default. To allow cross-origin sending cookies, it as easy as returning Access-Control-Allow-Credentials: true. This header will tell browsers that they are allowed to send credentials (i.e. cookies) in cross-origin requests.\nAllowing and acepting cross-origin cookies can be tricky. You could expose yourself to potential attack vectors, so enable them only when absolutely neccessary.\nCross-origin cookies work best in situations when you know exactly which clients will be accessing your server. That is why the CORS semantics do not allow us to set Access-Control-Allow-Origin: * when cross-origin credentials are allowed.\nWhile the Access-Control-Allow-Origin: * and Access-Control-Allow-Credentials: true combination is technically allowed, it‚Äôs a anti-pattern and should absolutely be avoided.\nIf you would like your servers to be accessed by different clients and origins, you should probably look into building an API (with token-based authentication) instead of using cookies. But if going down the API path is not an option, then make sure you implement cross-site request forgery (CSRF) protection.\nAdditional reading I hope this (long) read gave you a good idea about CORS, how it came to be, and why it‚Äôs neccesary. Here are a few more links that I used while writing this article, or that I believe are a good read on the topic:\n Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Credentials header on MDN Web Docs Authoritative guide to CORS (Cross-Origin Resource Sharing) for REST APIs The ‚ÄúCORS protocol‚Äù section of the Fetch API spec Same-origin policy on MDN Web Docs Quentin‚Äôs great summary of CORS on StackOverflow  ","wordCount":"4212","inLanguage":"en","datePublished":"2021-04-12T20:40:00+01:00","dateModified":"2021-04-12T20:40:00+01:00","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/deep-dive-cors-history-how-it-works-best-practices/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ‚ö°Ô∏è","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ‚ö°Ô∏è (Alt + H)">Ilija Eftimov ‚ö°Ô∏è</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://ieftimov.com/posts title=Archive><span>Archive</span></a></li><li><a href=https://ieftimov.com/about title=About><span>About</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Deep dive in CORS: History, how it works, and best practices</h1><div class=post-description>Learn the history and evolution of same-origin policy and CORS, understand CORS and the different types of cross-origin access in depth, and learn best practices.</div><div class=post-meta>April 12, 2021&nbsp;¬∑&nbsp;20 min&nbsp;¬∑&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#the-error-in-your-browsers-console aria-label="The error in your browser&amp;rsquo;s console">The error in your browser&rsquo;s console</a></li><li><a href=#in-the-beginning-was-the-first-subresource aria-label="In the beginning was the first subresource">In the beginning was the first subresource</a><ul><li><a href=#origins--cross-origin aria-label="Origins &amp;amp; cross-origin">Origins & cross-origin</a></li><li><a href=#the-many-dangers-of-cross-origin-requests aria-label="The many dangers of cross-origin requests">The many dangers of cross-origin requests</a></li></ul></li><li><a href=#same-origin-policy aria-label="Same-origin policy">Same-origin policy</a></li><li><a href=#enter-cors aria-label="Enter CORS">Enter CORS</a><ul><li><a href=#cross-origin-writes aria-label="Cross-origin writes">Cross-origin writes</a></li><li><a href=#preflight-requests aria-label="Preflight requests">Preflight requests</a></li><li><a href=#cross-origin-reads aria-label="Cross-origin reads">Cross-origin reads</a></li></ul></li><li><a href=#fine-tuning-cors aria-label="Fine-tuning CORS">Fine-tuning CORS</a></li><li><a href=#some-best-practices aria-label="Some best practices">Some best practices</a><ul><li><a href=#free-for-all aria-label="Free for all">Free for all</a></li><li><a href=#keeping-it-in-the-family aria-label="Keeping it in the family">Keeping it in the family</a></li><li><a href=#null-origins aria-label="NULL origins">NULL origins</a></li><li><a href=#skip-cookies-if-you-can aria-label="Skip cookies, if you can">Skip cookies, if you can</a></li></ul></li><li><a href=#additional-reading aria-label="Additional reading">Additional reading</a></li></ul></div></details></div><div class=post-content><h2 id=the-error-in-your-browsers-console>The error in your browser&rsquo;s console<a hidden class=anchor aria-hidden=true href=#the-error-in-your-browsers-console>#</a></h2><blockquote><p>No &lsquo;Access-Control-Allow-Origin&rsquo; header is present on the requested resource.</p></blockquote><blockquote><p>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the
remote resource at <a href=https://example.com/>https://example.com/</a></p></blockquote><blockquote><p>Access to fetch at &lsquo;<a href=https://example.com>https://example.com</a>&rsquo; from origin &lsquo;http://localhost:3000&rsquo;
has been blocked by CORS policy.</p></blockquote><p>I am sure you&rsquo;ve seen one of these errors, or a variation, in your browser&rsquo;s
console. If you have not ‚Äì don&rsquo;t fret, you soon will. There are enough CORS
errors for all developers out there.</p><p>These popping-up during development can be annoying. But in fact, CORS is an
incredibly useful mechanism in a world of misconfigured web servers, hostile
actors on the web and organizations pushing the web standards ahead.</p><p>But let&rsquo;s go back the beginning&mldr;</p><h2 id=in-the-beginning-was-the-first-subresource>In the beginning was the first subresource<a hidden class=anchor aria-hidden=true href=#in-the-beginning-was-the-first-subresource>#</a></h2><p>A subresource is an HTML element that is requested to be embedded into the
document, or executed in its context. <a href=http://1997.webhistory.org/www.lists/www-talk.1993q1/0182.html>In the year of
1993</a>, the
first subresource <code>&lt;img></code> was introduced. By introducing <code>&lt;img></code>, the web got
prettier. And more complex.</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/meet-img.png caption="Back to 1993" alt="Back to 1993">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Back to 1993</span></figure><p>You see, if your browser would render a page with an <code>&lt;img></code> on it, it would
actually have to go fetch that sub<strong>resource</strong> from an origin. When a browser
fetches said subresource from an origin that does not reside on the same
scheme, fully qualified hostname or port ‚Äì that&rsquo;s a <strong>cross-origin request</strong>.</p><h3 id=origins--cross-origin>Origins & cross-origin<a hidden class=anchor aria-hidden=true href=#origins--cross-origin>#</a></h3><p>An origin is identified by a triple: scheme, fully qualified hostname and port.
For example, <code>http://example.com</code> and <code>https://example.com</code> are different
origins ‚Äì¬†the first uses <code>http</code> scheme and the second <code>https</code>. Also, the
default <code>http</code> port is 80, while the <code>https</code> is 443. Therefore, in this
example, the two origins differ by scheme and port, although the host is the
same (<code>example.com</code>).</p><p>You get the idea ‚Äì if any of the three items in the triple are different, then
the origin is different.</p><p>As an exercise if we run a comparison of the
<code>https://blog.example.com/posts/foo.html</code> origin against other origins, we
would get the following results:</p><table><thead><tr><th>URL</th><th>Result</th><th>Reason</th></tr></thead><tbody><tr><td><code>https://blog.example.com/posts/bar.html</code></td><td>Same</td><td>Only the path differs</td></tr><tr><td><code>https://blog.example.com/contact.html</code></td><td>Same</td><td>Only the path differs</td></tr><tr><td><code>http://blog.example.com/posts/bar.html</code></td><td>Different</td><td>Different protocol</td></tr><tr><td><code>https://blog.example.com:8080/posts/bar.html</code></td><td>Different</td><td>Different port (<code>https://</code> is port 443 by default)</td></tr><tr><td><code>https://example.com/posts/bar.html</code></td><td>Different</td><td>Different host</td></tr></tbody></table><p>A cross-origin request means, for example, a resource (i.e. page) such as
<code>http://example.com/posts/bar.html</code> that would try to render a subresource from
the <code>https://example.com</code> origin (note the scheme change!).</p><h3 id=the-many-dangers-of-cross-origin-requests>The many dangers of cross-origin requests<a hidden class=anchor aria-hidden=true href=#the-many-dangers-of-cross-origin-requests>#</a></h3><p>Now that we defined what same- and cross-origin is, let&rsquo;s see what is the big
deal.</p><p>When we introduced <code>&lt;img></code> to the web, we opened the floodgates. Soon after the
web got <code>&lt;script></code>, <code>&lt;frame></code>, <code>&lt;video></code>, <code>&lt;audio></code>, <code>&lt;iframe></code>, <code>&lt;link></code>,
<code>&lt;form></code> and so on. These subresources can be fetched by the browser after
loading the page, therefore they can all be same- or cross-origin requests.</p><p>Let&rsquo;s travel to an imaginary world where CORS does not exist and web browsers
allow all sorts of cross-origin requests.</p><p>Imagine I got a page on my website <code>evil.com</code> with a <code>&lt;script></code>. On the surface
it looks like a simple page, where you read some useful information. But in the
<code>&lt;script></code>, I have specially crafted code that will send a specially-crafted
request to bank&rsquo;s <code>DELETE /account</code> endpoint. Once you load the page, the
JavaScript is executed and an AJAX call hits the bank&rsquo;s API.</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/malicious-javascript-injection.png caption="Puff, your account is gone. üå¨" alt="Puff, your account is gone. üå¨">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Puff, your account is gone. üå¨</span></figure><p>Mind-blowing ‚Äì¬†imagine while reading some information on a web page, you get an
email from your bank that you&rsquo;ve successfully deleted your account. I know I
know&mldr; if it was THAT easy to do <em>anything</em> with a bank&rsquo;s. I digress.</p><p>For my evil <code>&lt;script></code> to work, as part of the request your browser would also
have to send your credentials (cookies) from the bank&rsquo;s website. That&rsquo;s how the
bank&rsquo;s servers would identify you and know which account to delete.</p><p>Let&rsquo;s look at a different, not-so-evil scenario.</p><p>I want to detect folks that work for <strong>Awesome Corp</strong>, whose internal website
is on <code>intra.awesome-corp.com</code>. On my website, <code>dangerous.com</code> I got an <code>&lt;img src="https://intra.awesome-corp.com/avatars/john-doe.png"></code>.</p><p>For users that do not have a session active with <code>intra.awesome-corp.com</code>, the
avatar won&rsquo;t render ‚Äì¬†it will produce an error. But, if you&rsquo;re logged in the
intranet of Awesome Corp., once you open my <code>dangerous.com</code> website I&rsquo;ll know
that you have access.</p><p>That means that I will be able to derive some information about you. While it&rsquo;s
definitely harder for me to craft an attack, the knowledge that you have access
to Awesome Corp. is still a potential attack vector.</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/resource-embed-attack-vector.png caption="Leaking info to 3rd parties üí¶" alt="Leaking info to 3rd parties üí¶">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Leaking info to 3rd parties üí¶</span></figure><p>While these two are overly-simplistic examples, it is this kind of threats that
have made the same-origin policy & CORS neccessary. These are all different
dangers of cross-origin requests. Some have been mitigated, others <strong>can&rsquo;t be</strong>
mitigated ‚Äì they&rsquo;re rooted in the nature of the web. But for the plethora of
attack vectors that have been squashed ‚Äì¬†it&rsquo;s because of CORS.</p><p>But before CORS, there was the same-origin policy.</p><h2 id=same-origin-policy>Same-origin policy<a hidden class=anchor aria-hidden=true href=#same-origin-policy>#</a></h2><p>The same-origin policy prevents cross-origin attacks by blocking read access to
resources loaded from a different origin. This policy still allows some tags,
like <code>&lt;img></code>, to embeds resources from a different origin.</p><p>The same-origin policy was introduced by Netscape Navigator 2.02 in 1995,
originally intended to protect cross-origin access to the DOM.</p><p>Even though same-origin policy implementations are not required to follow an
exact specification, all modern browsers implement some form of it. The
principles of the policy are described in
<a href=https://tools.ietf.org/html/rfc6454>RFC6454</a> of the Internet Engineering Task
Force (IETF).</p><p>The implementation of the same-origin policy is defined with this ruleset:</p><table><thead><tr><th>Tags</th><th>Cross-origin</th><th>Note</th></tr></thead><tbody><tr><td><code>&lt;iframe></code></td><td>Embedding permitted</td><td>Depends on <code>X-Frame-Options</code></td></tr><tr><td><code>&lt;link></code></td><td>Embedding permitted</td><td>Proper <code>Content-Type</code> might be required</td></tr><tr><td><code>&lt;form></code></td><td>Writing permitted</td><td>Cross-origin writes are common</td></tr><tr><td><code>&lt;img></code></td><td>Embedding permitted</td><td>Cross-origin reading via JavaScript and loading it in a <code>&lt;canvas></code> is forbidden</td></tr><tr><td><code>&lt;audio></code> / <code>&lt;video></code></td><td>Embedding permitted</td><td></td></tr><tr><td><code>&lt;script></code></td><td>Embedding permitted</td><td>Access to certain APIs might be forbidden</td></tr></tbody></table><p>Same-origin policy solves many challenges, but it is pretty restrictive. In the
age of single-page applications and media-heavy websites, same-origin does not
leave a lot of room for relaxation of or fine-tuning of these rules.</p><p>CORS was born with the goals to relax the same-origin policy and to fine-tune
cross-origin access.</p><h2 id=enter-cors>Enter CORS<a hidden class=anchor aria-hidden=true href=#enter-cors>#</a></h2><p>So far we covered what is an origin, how it&rsquo;s defined, what the drawbacks of
cross-origin requests are and the same-origin policy that browsers implement.</p><p>Now it&rsquo;s time to familiarize ourselves with Cross Origin Resource Sharing
(CORS). CORS is a mechanism that allows control of access to subresources on a
web page over a network. The mechanism classifies three different categories of
subresource access:</p><ol><li>Cross-origin writes</li><li>Cross-origin embeds</li><li>Cross-origin reads</li></ol><p>Before we go on to explain each of these categories, it&rsquo;s important to
realize that although your browser (by default) might allow a certain type
of cross-origin request, that <strong>does not mean that said request will be
accepted by the server</strong>.</p><p><strong>Cross-origin writes</strong> are links, redirects, and form submissions. With CORS
active in your browser, these are all <strong>allowed</strong>. There is also a thing called
<strong>preflight request</strong> that fine-tunes cross-origin writes, so while some writes
might be permitted by default it doesn&rsquo;t mean they can go through in practice.
We&rsquo;ll look into that a bit later.</p><p><strong>Cross-origin embeds</strong> are subresources loaded via: <code>&lt;script></code>, <code>&lt;link></code>,
<code>&lt;img></code>, <code>&lt;video></code>, <code>&lt;audio></code>, <code>&lt;object></code>, <code>&lt;embed></code>, <code>&lt;iframe></code> and more.
These are all <strong>allowed</strong> by default. <code>&lt;iframe></code> is a special one ‚Äì as it&rsquo;s
purpose is to literally load a different page inside the frame, its
cross-origin framing can be controlled by using the <code>X-Frame-options</code> header.</p><p>When it comes to <code>&lt;img></code> and the other embeddable subresources ‚Äì it&rsquo;s in their
nature to trigger cross-origin requests. That&rsquo;s why in CORS differentiates
between cross-origin embeds and cross-origin reads, and treats them
differently.</p><p><strong>Cross-origin reads</strong> are subresources loaded via AJAX / <code>fetch</code> calls. These
are by default <strong>blocked</strong> in your browser. There&rsquo;s the workaround of embedding
such subresources in a page, but such tricks are handled by another policy
present in modern browsers.</p><p>If your browser is up to date, all of these heuristics are already implemented
in it.</p><h3 id=cross-origin-writes>Cross-origin writes<a hidden class=anchor aria-hidden=true href=#cross-origin-writes>#</a></h3><p>Cross-origin writes can be the very problematic. Let&rsquo;s look into an example and
see CORS in action.</p><p>First, we&rsquo;ll have a simple <a href=https://crystal-lang.org/>Crystal</a> (using
<a href=https://kemalcr.com/>Kemal</a>) HTTP server:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-crystal data-lang=crystal><span style=color:#5f8700>require</span> <span style=color:#00afaf>&#34;kemal&#34;</span>

port = <span style=color:#d75f00>ENV</span>[<span style=color:#00afaf>&#34;PORT&#34;</span>].to_i || <span style=color:#00afaf>4000</span>

get <span style=color:#00afaf>&#34;/&#34;</span> <span style=color:#5f8700>do</span>
  <span style=color:#00afaf>&#34;Hello world!&#34;</span>
<span style=color:#5f8700>end</span>

get <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span>
  <span style=color:#00afaf>&#34;Hey!&#34;</span>
<span style=color:#5f8700>end</span>

post <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span> |env|
  name = env.params.json[<span style=color:#00afaf>&#34;name&#34;</span>].as(<span style=color:#0087ff>String</span>)
  <span style=color:#00afaf>&#34;Hello, </span><span style=color:#00afaf>#{</span>name<span style=color:#00afaf>}</span><span style=color:#00afaf>!&#34;</span>
<span style=color:#5f8700>end</span>

Kemal.config.port = port
Kemal.run</code></pre></td></tr></table></div></div><p>It simply takes a request at the <code>/greet</code> path, with a <code>name</code> in the request
body, and returns a <code>Hello #{name}!</code>. To run this tiny Crystal server, we can
boot it with:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ crystal run server.cr</code></pre></td></tr></table></div></div><p>This will boot the server and listen on <code>localhost:4000</code>. If we navigate to
<code>localhost:4000</code> in our browser, we will be presented a simple &ldquo;Hello World&rdquo;
page:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/hello-world-localhost.png caption="Hello, world! üåç" alt="Hello, world! üåç">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Hello, world! üåç</span></figure><p>Now that we know our server is running, let&rsquo;s execute a <code>POST /greet</code> to the
server listening on <code>localhost:4000</code>, from the console of our browser page. We
can do that by using <code>fetch</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>fetch(
  <span style=color:#00afaf>&#39;http://localhost:4000/greet&#39;</span>,
  {
    method: <span style=color:#00afaf>&#39;POST&#39;</span>,
    headers: { <span style=color:#00afaf>&#39;Content-Type&#39;</span>: <span style=color:#00afaf>&#39;application/json&#39;</span> },
    body: JSON.stringify({ name: <span style=color:#00afaf>&#39;Ilija&#39;</span>})
  }
).then(resp =&gt; resp.text()).then(console.log)
</code></pre></td></tr></table></div></div><p>Once we run it, we will see the greeting come back from the server:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/hello-world-localhost-post.png caption="Hi there! üëã" alt="Hi there! üëã">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Hi there! üëã</span></figure><p>This was a <code>POST</code> request, but it was not cross-origin. We sent the request
from the browser where <code>http://localhost:4000</code> (the origin) was rendered, to
that same origin.</p><p>Now, let&rsquo;s try the same request, but cross-origin. We will open
<code>https://google.com</code> and try to send that same request from that tab in our
browser:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post.png caption="Hello, CORS! üí£" alt="Hello, CORS! üí£">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Hello, CORS! üí£</span></figure><p>We managed to get the famous CORS error. Athough our Crystal server can fulfil
the request, our browser is protecting us from ourselves. It is basically
telling us that a website that we have opened wants to make changes to another
website as ourselves.</p><p>In the first example, where we sent the request to
<code>http://localhost:4000/greet</code> from the tab that rendered
<code>http://localhost:4000</code>, our browser looks at that request and lets it through
because it appears that our website is calling our server (which is fine). But
in the second example where our website (<code>https://google.com</code>) wants to write
to <code>http://localhost:4000</code>, then our browser flags that request and does not
let it go through.</p><h3 id=preflight-requests>Preflight requests<a hidden class=anchor aria-hidden=true href=#preflight-requests>#</a></h3><p>If we look deeper in our developer console, in the Network tab in particular,
we will in fact notice two requests in place of the one that we sent:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-network.png caption="Two outbound requests as seen in the Network panel" alt="Two outbound requests as seen in the Network panel">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Two outbound requests as seen in the Network panel</span></figure><p>What is interesting to notice is that the first request has a HTTP method of
<code>OPTIONS</code>, while the second has <code>POST.</code></p><p>If we explore the <code>OPTIONS</code> request we will see that this is a request that has
been sent by our browser prior to sending our <code>POST</code> request:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-network-options.png caption="Looking into the OPTIONS request üîç" alt="Looking into the OPTIONS request üîç">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Looking into the <code>OPTIONS</code> request üîç</span></figure><p>What is interesting is that even though the response to the <code>OPTIONS</code> request
was a HTTP 200, it was still marked as red in the request list. Why?</p><p>This is the <strong>preflight request</strong> that modern browsers do. A preflight request
is performed for requests which CORS deems as complex. The criteria for
<em>complex</em> request is:</p><ul><li>A request that uses methods other than <code>GET</code>, <code>POST</code>, or <code>HEAD</code></li><li>A request that includes headers other than <code>Accept</code>, <code>Accept-Language</code> or
<code>Content-Language</code></li><li>A request that has a <code>Content-Type</code> header value other than
<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, or <code>text/plain</code></li></ul><p>Therefore in the above example, although we send a <code>POST</code> request, the browser
considers our request complex due to the <code>Content-Type: application/json</code>
header.</p><p>If we would change our server to handle <code>text/plain</code> content (instead of JSON),
we can work around the need for a preflight request:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-crystal data-lang=crystal><span style=color:#5f8700>require</span> <span style=color:#00afaf>&#34;kemal&#34;</span>

get <span style=color:#00afaf>&#34;/&#34;</span> <span style=color:#5f8700>do</span>
  <span style=color:#00afaf>&#34;Hello world!&#34;</span>
<span style=color:#5f8700>end</span>

get <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span>
  <span style=color:#00afaf>&#34;Hey!&#34;</span>
<span style=color:#5f8700>end</span>

post <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span> |env|
  body = env.request.body

  name = <span style=color:#00afaf>&#34;there&#34;</span>
  name = body.gets.as(<span style=color:#0087ff>String</span>) <span style=color:#5f8700>if</span> !body.nil?

  <span style=color:#00afaf>&#34;Hello, </span><span style=color:#00afaf>#{</span>name<span style=color:#00afaf>}</span><span style=color:#00afaf>!&#34;</span>
<span style=color:#5f8700>end</span>

Kemal.config.port = <span style=color:#00afaf>4000</span>
Kemal.run</code></pre></td></tr></table></div></div><p>Now, when we can send our request with the <code>Content-type: text/plain</code> header:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>fetch(
  <span style=color:#00afaf>&#39;http://localhost:4000/greet&#39;</span>,
  {
    method: <span style=color:#00afaf>&#39;POST&#39;</span>,
    headers: {
      <span style=color:#00afaf>&#39;Content-Type&#39;</span>: <span style=color:#00afaf>&#39;text/plain&#39;</span>
    },
    body: <span style=color:#00afaf>&#39;Ilija&#39;</span>
  }
)
.then(resp =&gt; resp.text())
.then(console.log)
</code></pre></td></tr></table></div></div><p>Now, while the preflight request will not be sent, the CORS policy of the
browser will keep on blocking:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-text-plain.png caption="CORS standing strong" alt="CORS standing strong">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">CORS standing strong</span></figure><p>But because we have crafted a request which does not classify as <em>complex</em>, our
browser actually <strong>won&rsquo;t block the request</strong>:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-text-plain-response-blocked.png caption="Request went through ‚û°Ô∏è" alt="Request went through ‚û°Ô∏è">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Request went through ‚û°Ô∏è</span></figure><p>Simply put: our server is <em>misconfgured</em> to accept <code>text/plain</code> cross-origin
requests, without any other protection in place, and our browser can&rsquo;t do much
about that. But still, it does the next best thing ‚Äì it does not expose our
opened page / tab to the response of that request. Therefore in this case, CORS
does not block the request - <strong>it blocks the response</strong>.</p><p>The CORS policy of our browser considers this effectively a cross-origin read,
because although the request is sent as <code>POST</code>, the <code>Content-type</code> header value
makes it essentialy the same as a <code>GET</code>. And cross-origin reads are blocked by
default, hence the blocked response we are seeing in our network tab.</p><p>Working around preflight requests like in the example above is not recommended.
In fact, if you expect that your server will have to gracefully handle preflight requests,
it should implement the <code>OPTIONS</code> endpoints and return the correct headers.</p><p>When implementing the <code>OPTIONS</code> endpoint, you need to know that the preflight
request of the browser looks for three headers in particular that can be
present on the response:</p><ul><li><code>Access-Control-Allow-Methods</code> ‚Äì it indicates which methods are supported by
the response‚Äôs URL for the purposes of the CORS protocol.</li><li><code>Access-Control-Allow-Headers</code> - it indicates which headers are supported by
the response‚Äôs URL for the purposes of the CORS protocol.</li><li><code>Access-Control-Max-Age</code> - it indicates the number of seconds (5 by default)
the information provided by the <code>Access-Control-Allow-Methods</code> and
<code>Access-Control-Allow-Headers</code> headers can be cached.</li></ul><p>Let&rsquo;s go back to our previous example where we sent a complex request:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>fetch(
  <span style=color:#00afaf>&#39;http://localhost:4000/greet&#39;</span>,
  {
    method: <span style=color:#00afaf>&#39;POST&#39;</span>,
    headers: { <span style=color:#00afaf>&#39;Content-Type&#39;</span>: <span style=color:#00afaf>&#39;application/json&#39;</span> },
    body: JSON.stringify({ name: <span style=color:#00afaf>&#39;Ilija&#39;</span>})
  }
).then(resp =&gt; resp.text()).then(console.log)
</code></pre></td></tr></table></div></div><p>We already confirmed that when we send this request, our browser will check
with the server if it can perform the cross-origin request. To get this request
working in a cross-origin environment, we have to first add the <code>OPTIONS /greet</code> endpoint to our server. In its response header, the new endpoint will
have to inform the browser that the request to <code>POST /greet</code>, with
<code>Content-type: application/json</code> header, from the origin
<code>https://www.google.com</code>, can be accepted.</p><p>We&rsquo;ll do this by using the <code>Access-Control-Allow-*</code> headers:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-crystal data-lang=crystal>options <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span> |env|
  <span style=color:#4e4e4e># Allow `POST /greet`...</span>
  env.response.headers[<span style=color:#00afaf>&#34;Access-Control-Allow-Methods&#34;</span>] = <span style=color:#00afaf>&#34;POST&#34;</span>
  <span style=color:#4e4e4e># ...with `Content-type` header in the request...</span>
  env.response.headers[<span style=color:#00afaf>&#34;Access-Control-Allow-Headers&#34;</span>] = <span style=color:#00afaf>&#34;Content-type&#34;</span>
  <span style=color:#4e4e4e># ...from https://www.google.com origin.</span>
  env.response.headers[<span style=color:#00afaf>&#34;Access-Control-Allow-Origin&#34;</span>] = <span style=color:#00afaf>&#34;https://www.google.com&#34;</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>If we boot our server and send the request:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-blocked.png caption="Still blocked? ü§î" alt="Still blocked? ü§î">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Still blocked? ü§î</span></figure><p>Our request remains blocked. Even though our <code>OPTIONS /greet</code> endpoint did
allow the request, we are still seeing the error message. In our network tab
there&rsquo;s something interesting going on:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-blocked-network-inspect.png caption="OPTIONS is green! üéâ" alt="OPTIONS is green! üéâ">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">OPTIONS is green! üéâ</span></figure><p>The request to the <code>OPTIONS /greet</code> endpoint was a success! But the <code>POST /greet</code> call still failed. If we take a peek in the internals of the <code>POST /greet</code> request we will see a familiar sight:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-blocked-post-inspect.png caption="POST is green too? üò≤" alt="POST is green too? üò≤">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">POST is green too? üò≤</span></figure><p>In fact, the request did succeed ‚Äì the server returned a HTTP 200. The
preflight request did work ‚Äì the browser did make the <code>POST</code> request instead of
blocking it. But the response of the <code>POST</code> request did not contain any CORS
headers, so even though the browser did make the request, it blocked any
response processing.</p><p>To allow the browser also process the response from the <code>POST /greet</code> request,
we need to add a CORS header to the <code>POST</code> endpoint as well:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-crystal data-lang=crystal>post <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span> |env|
  name = env.params.json[<span style=color:#00afaf>&#34;name&#34;</span>].as(<span style=color:#0087ff>String</span>)

  env.response.headers[<span style=color:#00afaf>&#34;Access-Control-Allow-Origin&#34;</span>] = <span style=color:#00afaf>&#34;https://www.google.com&#34;</span>

  <span style=color:#00afaf>&#34;Hello, </span><span style=color:#00afaf>#{</span>name<span style=color:#00afaf>}</span><span style=color:#00afaf>!&#34;</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>By adding the <code>Access-Control-Allow-Origin</code> header response header, we tell the
browser that a tab that has <code>https://www.google.com</code> open can also access the
response payload.</p><p>If we give this another shot:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-success.png caption="POST works!" alt="POST works!">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">POST works!</span></figure><p>We will see that <code>POST /greet</code> did get us a response, without any errors. If
we take a peek in the Network tab, we&rsquo;ll see that both requests are green:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-success-network.png caption="OPTIONS & POST in action! üí™" alt="OPTIONS & POST in action! üí™">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">OPTIONS & POST in action! üí™</span></figure><p>By using proper response headers on our preflight endpoint <code>OPTIONS /greet</code>, we
unlocked our server&rsquo;s <code>POST /greet</code> endpoint to be accessed across different
origin. On top of that, by providing a correct CORS response header on the
response of the <code>POST /greet</code> endpoint, we freed the browser to process the
response without any blocking.</p><h3 id=cross-origin-reads>Cross-origin reads<a hidden class=anchor aria-hidden=true href=#cross-origin-reads>#</a></h3><p>As we mentioned before, cross-origin reads are blocked by default. That&rsquo;s on
purpose - we wouldn&rsquo;t want to load other resources from other origints in the
scope of our origin.</p><p>Say, we have a <code>GET /greet</code> action in our Crystal server:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-crystal data-lang=crystal>get <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span>
  <span style=color:#00afaf>&#34;Hey!&#34;</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>From our tab that has <code>www.google.com</code> rendered, if we try to <code>fetch</code> the <code>GET /greet</code> endpoint we will get blocked by CORS:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-get.png caption="CORS blocking üôÖ" alt="CORS blocking üôÖ">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">CORS blocking üôÖ</span></figure><p>If we look deeper in the request, we will found out something interesting:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-get-blocked-inspect.png caption="A successful GET üéâ" alt="A successful GET üéâ">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">A successful GET üéâ</span></figure><p>In fact, just like before, our browser did let the request through ‚Äì¬†we got a
HTTP 200 back. But it did not expose our opened page / tab to the response of
that request. Again, in this case CORS does not block the request - <strong>it blocks
the response</strong>.</p><p>Just like with cross-origin writes, we can relax CORS and make it available for
cross-origin reading - by adding the <code>Access-Control-Allow-Origin</code> header:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-crystal data-lang=crystal>get <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span> |env|
  env.response.headers[<span style=color:#00afaf>&#34;Access-Control-Allow-Origin&#34;</span>] = <span style=color:#00afaf>&#34;https://www.google.com&#34;</span>
  <span style=color:#00afaf>&#34;Hey!&#34;</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>When the browser gets the response back from the server, it will look at the
<code>Access-Control-Allow-Origin</code> header and will decide based on its value if it
can let the page read the response. Given that the value in this case is
<code>https://www.google.com</code> which is the page that we use in our example the
outcome will be a success:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-get-success.png caption="A successful cross-origin GET üéâ" alt="A successful cross-origin GET üéâ">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">A successful cross-origin GET üéâ</span></figure><p>This is how the browser shields us from cross-origin reads and respects the
server directives that are sent via the headers.</p><h2 id=fine-tuning-cors>Fine-tuning CORS<a hidden class=anchor aria-hidden=true href=#fine-tuning-cors>#</a></h2><p>As we already saw in previous examples, to relax the CORS policy of our
website, we can set the <code>Access-Control-Allow-Origin</code> of our <code>/greet</code> action to
the <code>https://www.google.com</code> value:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-crystal data-lang=crystal>post <span style=color:#00afaf>&#34;/greet&#34;</span> <span style=color:#5f8700>do</span> |env|
  body = env.request.body

  name = <span style=color:#00afaf>&#34;there&#34;</span>
  name = body.gets.as(<span style=color:#0087ff>String</span>) <span style=color:#5f8700>if</span> !body.nil?

  env.response.headers[<span style=color:#00afaf>&#34;Access-Control-Allow-Origin&#34;</span>] = <span style=color:#00afaf>&#34;https://www.google.com&#34;</span>
  <span style=color:#00afaf>&#34;Hello, </span><span style=color:#00afaf>#{</span>name<span style=color:#00afaf>}</span><span style=color:#00afaf>!&#34;</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>This will allow the <code>https://www.google.com</code> origin to call our server, and our
browser will feel fine about that. Having the <code>Access-Control-Allow-Origin</code> in
place, we can try to execute the <code>fetch</code> call again:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/google-cross-origin-post-text-plain-success.png caption="Success! üéâ" alt="Success! üéâ">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Success! üéâ</span></figure><p>This made it work! With the new CORS policy, we can call our <code>/greet</code> action
from our tab that has <code>https://www.google.com</code> rendered. Alternatively, we
could also set the header value to <code>*</code>, which would tell the browser that the
server can be called from any origin.</p><p>Such a configuration has to be carefully considered. Yet, putting relaxed CORS
headers is <strong>almost always</strong> safe. One rule of thumb is: if you open the URL in
an incognito tab, and you are happy with the information you are exposing, then
you can set a permissive (<code>*</code>) CORS policy on said URL.</p><p>Another way to fine-tune CORS on our website is to use the
<code>Access-Control-Allow-Credentials</code> response header.
<code>Access-Control-Allow-Credentials</code> instructs browsers whether to expose the
response to the frontend JavaScript code when the request&rsquo;s credetials mode is
<code>include</code>.</p><p>The request&rsquo;s credentials mode comes from the introduction of <a href=https://fetch.spec.whatwg.org/>the Fetch
API</a>, which has its roots back the original
<code>XMLHttpRequest</code> objects:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#0087ff>var</span> client = <span style=color:#5f8700>new</span> XMLHttpRequest()
client.open(<span style=color:#00afaf>&#34;GET&#34;</span>, <span style=color:#00afaf>&#34;./&#34;</span>)
client.withCredentials = <span style=color:#d75f00>true</span>
</code></pre></td></tr></table></div></div><p>With the introduction of <code>fetch</code>, the <code>withCredentials</code> option was transformed
into an optional argument to the <code>fetch</code> call:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>fetch(<span style=color:#00afaf>&#34;./&#34;</span>, { credentials: <span style=color:#00afaf>&#34;include&#34;</span> }).then(<span style=color:#4e4e4e>/* ... */</span>)
</code></pre></td></tr></table></div></div><p>The available options for the <code>credentials</code> options are <code>omit</code>, <code>same-origin</code>
and <code>include</code>. The different modes are available so developers can fine-tune
the outbound request, whereas the response from the server will inform the
browser how to behave when credentials are sent with the request (via the
<code>Access-Control-Allow-Credentials</code> header).</p><p>The Fetch API spec contains a well-written and thorough
<a href=https://fetch.spec.whatwg.org/#cors-protocol-and-credentials>breakdown</a> of
the interplay of CORS and the <code>fetch</code> Web API, and the security mechanisms put
in place by browsers.</p><h2 id=some-best-practices>Some best practices<a hidden class=anchor aria-hidden=true href=#some-best-practices>#</a></h2><p>Before we wrap it up, let&rsquo;s cover some best practices when it comes to Cross
Origin Resource Sharing (CORS).</p><h3 id=free-for-all>Free for all<a hidden class=anchor aria-hidden=true href=#free-for-all>#</a></h3><p>A common example is if you own a website that displays content for the public,
that is not behind paywalls, or requiring authentication or authorization ‚Äì¬†you
should be able to set <code>Access-Control-Allow-Origin: *</code> to its resources.</p><p>The <code>*</code> value is a good choice in cases when:</p><ul><li>No authentication or authorization is required</li><li>The resource should be accessible to a wide range of users without
restrictions</li><li>The origins & clients that will access the resource is of great variety, you
don&rsquo;t have knowledge of it or you simply don&rsquo;t care</li></ul><p>A dangerous prospect of such configuration is when it comes to content served
on private networks (i.e. behind firewall or VPN). When you are connected via a
VPN, you have access to the files on the company&rsquo;s network:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/vpn-access-diagram.png caption="Oversimplification of VPNs" alt="Oversimplification of VPNs">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Oversimplification of VPNs</span></figure><p>Now, if an attacker hosts as website <code>dangerous.com</code>, which contains a link to
a file within the VPN, they can (in theory) create a script on their website
that can access that file:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/vpn-access-attacker-diagram.png caption="File leak" alt="File leak">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">File leak</span></figure><p>While such an attack is hard and requires a lot of knowledge about the VPN and
the files stored within it, it is a potential attack vector that we must be
aware of.</p><h3 id=keeping-it-in-the-family>Keeping it in the family<a hidden class=anchor aria-hidden=true href=#keeping-it-in-the-family>#</a></h3><p>Continuing with the example from above, imagine we want to implement analytics
for our website. We would like our users' browsers to send us data about the
experience and behavior of our users on our website.</p><p>A common way to do this is to send that data periodically using asynchronous
requests using JavaScript in the browser. On the backend we have a simple API
that takes these requests from our users' browsers and stores the data on the
backend for further processing.</p><p>In such cases, our API is public, but we don&rsquo;t want <em>any</em> website to send data to our
analytics API. In fact, we are interested only in requests that originate from
browsers that have our website rendered ‚Äì¬†that is all.</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/no-cross-origin-api.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>In such cases, we want our API to set the <code>Access-Control-Allow-Origin</code> header
to our website&rsquo;s URL. That will make sure browsers never send requests to our
API from other pages.</p><p>If users or other websites try to cram data in our analytics API, the
<code>Access-Control-Allow-Origin</code> headers set on the resources of our API won&rsquo;t let
the request to go through:</p><figure class=imagecaption><img class=caption src=/back-to-the-origin-with-cors/failed-cross-origin-api.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h3 id=null-origins>NULL origins<a hidden class=anchor aria-hidden=true href=#null-origins>#</a></h3><p>Another interesting case are <code>null</code> origins. They occur when a resource is
accessed by a browser that renders a local file. For example, requests coming
from some JavaScript running in a static file on your local machine have the
<code>Origin</code> header set to <code>null</code>.</p><p>In such cases, if our servers do now allow access to resources for the <code>null</code>
origin, then it can be a hindrance to the developer productivity. Allowing the
<code>null</code> origin within your CORS policy has to be deliberately done, and only if
the users of your website / product are developers.</p><h3 id=skip-cookies-if-you-can>Skip cookies, if you can<a hidden class=anchor aria-hidden=true href=#skip-cookies-if-you-can>#</a></h3><p>As we saw before with the <code>Access-Control-Allow-Credentials</code>, cookies are not
enabled by default. To allow cross-origin sending cookies, it as easy as
returning <code>Access-Control-Allow-Credentials: true</code>. This header will tell
browsers that they are allowed to send credentials (i.e. cookies) in
cross-origin requests.</p><p>Allowing and acepting cross-origin cookies can be tricky. You could expose
yourself to potential attack vectors, so enable them only when <strong>absolutely
neccessary</strong>.</p><p>Cross-origin cookies work best in situations when you know exactly which
clients will be accessing your server. That is why the CORS semantics do not
allow us to set <code>Access-Control-Allow-Origin: *</code> when cross-origin credentials
are allowed.</p><p>While the <code>Access-Control-Allow-Origin: *</code> and
<code>Access-Control-Allow-Credentials: true</code> combination is technically allowed,
it&rsquo;s a anti-pattern and should absolutely be avoided.</p><p>If you would like your servers to be accessed by different clients and origins,
you should probably look into building an API (with token-based authentication)
instead of using cookies. But if going down the API path is not an option, then
make sure you implement cross-site request forgery (CSRF) protection.</p><h2 id=additional-reading>Additional reading<a hidden class=anchor aria-hidden=true href=#additional-reading>#</a></h2><p>I hope this (long) read gave you a good idea about CORS, how it came to be, and
why it&rsquo;s neccesary. Here are a few more links that I used while writing this
article, or that I believe are a good read on the topic:</p><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>Cross-Origin Resource Sharing (CORS)</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials><code>Access-Control-Allow-Credentials</code> header</a> on MDN Web Docs</li><li><a href=https://www.moesif.com/blog/technical/cors/Authoritative-Guide-to-CORS-Cross-Origin-Resource-Sharing-for-REST-APIs/>Authoritative guide to CORS (Cross-Origin Resource Sharing) for REST APIs</a></li><li>The <a href=https://fetch.spec.whatwg.org/#http-cors-protocol>&ldquo;CORS protocol&rdquo; section</a> of the <a href=https://fetch.spec.whatwg.org>Fetch API spec</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy>Same-origin policy</a> on MDN Web Docs</li><li><a href=https://stackoverflow.com/users/19068/quentin>Quentin&rsquo;s</a> great <a href=https://stackoverflow.com/a/35553666>summary of CORS</a> on StackOverflow</li></ul></div><footer class=post-footer><nav class=paginav><a class=next href=https://ieftimov.com/post/testing-in-go-stop-leaking-files/><span class=title>Next Page ¬ª</span><br><span>Testing in Go: Stop Leaking Files</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Deep dive in CORS: History, how it works, and best practices on twitter" href="https://twitter.com/intent/tweet/?text=Deep%20dive%20in%20CORS%3a%20History%2c%20how%20it%20works%2c%20and%20best%20practices&url=https%3a%2f%2fieftimov.com%2fpost%2fdeep-dive-cors-history-how-it-works-best-practices%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep dive in CORS: History, how it works, and best practices on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fdeep-dive-cors-history-how-it-works-best-practices%2f&title=Deep%20dive%20in%20CORS%3a%20History%2c%20how%20it%20works%2c%20and%20best%20practices&summary=Deep%20dive%20in%20CORS%3a%20History%2c%20how%20it%20works%2c%20and%20best%20practices&source=https%3a%2f%2fieftimov.com%2fpost%2fdeep-dive-cors-history-how-it-works-best-practices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep dive in CORS: History, how it works, and best practices on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fdeep-dive-cors-history-how-it-works-best-practices%2f&title=Deep%20dive%20in%20CORS%3a%20History%2c%20how%20it%20works%2c%20and%20best%20practices"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep dive in CORS: History, how it works, and best practices on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fdeep-dive-cors-history-how-it-works-best-practices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep dive in CORS: History, how it works, and best practices on whatsapp" href="https://api.whatsapp.com/send?text=Deep%20dive%20in%20CORS%3a%20History%2c%20how%20it%20works%2c%20and%20best%20practices%20-%20https%3a%2f%2fieftimov.com%2fpost%2fdeep-dive-cors-history-how-it-works-best-practices%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Deep dive in CORS: History, how it works, and best practices on telegram" href="https://telegram.me/share/url?text=Deep%20dive%20in%20CORS%3a%20History%2c%20how%20it%20works%2c%20and%20best%20practices&url=https%3a%2f%2fieftimov.com%2fpost%2fdeep-dive-cors-history-how-it-works-best-practices%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 ¬© Ilija Eftimov</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>