<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Conditional HTTP GET: The fastest requests need no response body | Ilija Eftimov ⚡️</title><meta name=keywords content><meta name=description content="HTTP caching 101 Every browser implements its own in-memory caching. The information about the cache size per browser is spotty, but there&rsquo;s one thing for sure: the cache sizes vary. The great thing is that browsers are smart nowadays – they manage their caches opaquely for us, the end-users.
There are a few ways to put these caches to use. But it all starts with HTTP caching directives (or headers). The two HTTP response headers used for specifying freshness (another word for should something be cached) are Cache-Control and Expires:"><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/conditional-http-get-fastest-requests-need-no-response-body/><link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Conditional HTTP GET: The fastest requests need no response body"><meta property="og:description" content="HTTP caching 101 Every browser implements its own in-memory caching. The information about the cache size per browser is spotty, but there&rsquo;s one thing for sure: the cache sizes vary. The great thing is that browsers are smart nowadays – they manage their caches opaquely for us, the end-users.
There are a few ways to put these caches to use. But it all starts with HTTP caching directives (or headers). The two HTTP response headers used for specifying freshness (another word for should something be cached) are Cache-Control and Expires:"><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/conditional-http-get-fastest-requests-need-no-response-body/"><meta property="og:image" content="https://ieftimov.com/cards/conditional-http-get-fastest-requests-need-no-response-body.png"><meta property="article:published_time" content="2021-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-01T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/conditional-http-get-fastest-requests-need-no-response-body.png"><meta name=twitter:title content="Conditional HTTP GET: The fastest requests need no response body"><meta name=twitter:description content="HTTP caching 101 Every browser implements its own in-memory caching. The information about the cache size per browser is spotty, but there&rsquo;s one thing for sure: the cache sizes vary. The great thing is that browsers are smart nowadays – they manage their caches opaquely for us, the end-users.
There are a few ways to put these caches to use. But it all starts with HTTP caching directives (or headers). The two HTTP response headers used for specifying freshness (another word for should something be cached) are Cache-Control and Expires:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Conditional HTTP GET: The fastest requests need no response body","item":"https://ieftimov.com/post/conditional-http-get-fastest-requests-need-no-response-body/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Conditional HTTP GET: The fastest requests need no response body","name":"Conditional HTTP GET: The fastest requests need no response body","description":"HTTP caching 101 Every browser implements its own in-memory caching. The information about the cache size per browser is spotty, but there\u0026amp;rsquo;s one thing for sure: the cache …","keywords":[],"articleBody":"HTTP caching 101 Every browser implements its own in-memory caching. The information about the cache size per browser is spotty, but there’s one thing for sure: the cache sizes vary. The great thing is that browsers are smart nowadays – they manage their caches opaquely for us, the end-users.\nThere are a few ways to put these caches to use. But it all starts with HTTP caching directives (or headers). The two HTTP response headers used for specifying freshness (another word for should something be cached) are Cache-Control and Expires:\n Expires sets an explicit date and time when the content expires; Cache-Control specifies how long the browser can cache the content relative to the fetch time  In cases when the request has both headers specified, Cache-Control takes precedence.\nAnother way to put the browser caches to use is by using conditional requests and revalidation. We use the Last-modified and ETag (Entity Tag) response headers for that purpose:\n Last-modified is a timestamp that specifies when the backend last changed the object. ETag is a unique identifier for the content as a string. The server decides its format, but usually, it’s some form of a hash.  As we advance, we will explore caching by using conditional GET requests. In-depth!\n  Conditional HTTP requests Conditional requests are HTTP requests that include headers that indicate a certain precondition. When said headers are present, the HTTP server must check the condition. The server must perform the check before executing the HTTP method against the target resource. The result of the request can be different based on the result of the check of the precondition.\nAt the core of the conditional HTTP requests are validators. Validators are metadata the user-agent and the server use to discern if a resource is stale or not. The revalidation mechanisms implemented by the HTTP server check if the resource stored on the server matches a specific version that the user-agent has cached. The HTTP server performs the check (validation) based on the validators (metadata) sent by the user-agent.\nValidators fall in two categories:\n timestamp of last modification of the resource - the Last-Modified header unique string representing the resource version - the ETag (entity tag) header  Validator types Both validators, Last-Modified and ETag, allow two types of validation: weak and strong. Depending on the case, the complexity of implementing the validation can vary.\nStrong validators Strong validators are metadata that changes its value whenever the representational data of the resource changes. The representational data is the data format that would be observable in the payload body of an HTTP 200 OK response to GET /resource/:id.\nI know that’s loaded, so let me explain through an oversimplified example. Imagine we have a user resource served by GET /users/:id. For example, the response body of GET /users/1 would be:\n1 2 3 4 5  { \"id\": 1, \"name\": \"Jane\", \"age\": 30 }   A strong validator in this particular case can be an ETag composed based on the user’s id, name, and age attributes. In Ruby, the MD5 hash of these three values would be:\n1 2   Digest::MD5.hexdigest(\"1-Jane-30\") = \"fb324ab8bda9e1cbb47c2a001fa36349\"   If any of the attributes of the user change, given that our ETag is supposed to be a strong validator, we would like the ETag value to change. For example, after Jane’s birthday, the age will increase to 31. The new ETag would be:\n1 2   Digest::MD5.hexdigest(\"1-Jane-31\") = \"f78e2fe80b589cd55a2fef324e877d34\"   But also the change in the representational data of the resource is observable by GET-ing it from the server, e.g., GET /users/1:\n1 2 3 4 5  { \"id\": 1, \"name\": \"Jane\", \"age\": 31 }   This means that the metadata sent in the ETag changed because it is also observable by the user-agent in the data of the resource itself – not a magical field in the server’s database that the user-agent won’t know about.\nThere are scenarios, such as content negotiation, in which strong validators can change. The bottom line is: the origin server should only change the validator’s value when it is necessary to invalidate the cached responses in caches and other user-agents.\nHTTP uses strong validation by default, but it provides a way for clients to specify when they use weak validation. Clients can prepend ETags with the W/ string, denoting that the server should perform a weak validation.\nWeak validators A weak validator is metadata that might not change for every change to the representation data. It’s the opposite of the strong validators – even if the representation data changes, the HTTP server considers the change not worth busting the cached representation in the user-agents and other proxies/caches.\nBuilding on the example from above, let’s imagine that the representation of the user is as follows:\n1 2 3 4 5 6  { \"id\": 1, \"name\": \"Jane\", \"age\": 31, \"position\": \"Software Engineer\" }   If this user is promoted, from Software Engineer to Senior Software Engineer, a strong validator would be updated, causing user-agents and proxies to invalidate their caches. But what about weak validators?\nIt depends. The validator’s weakness might stem from how the product uses the data or the context in which it resides. For example, say we have an endpoint as part of an employee directory within a company. In that context, the change of age (i.e. birthday) might not be the reason to invalidate a resource. Invalidation in such an event will bust the caches, and we will incur a performance penalty for a non-essential change.\nIf that is the case, the ETag will not take all attributes from the representation into account – only the relevant ones, hence being a weak ETag. For example:\n1 2   etag = Digest::MD5.hexdigest(\"1-Jane-Software-Engineer\") = \"d18968bf453b0208dbbbcb5bd72af3e1\"   But a change of position (a.k.a. promotion) is relevant information that should cause the resource to be revalidated by caches.\nIn other words, an origin server should change a weak entity tag whenever it considers prior representations to be unacceptable as a substitute for the current representation.\nRevalidating weak ETags  Imagine Jane getting a promotion and then still seeing their old title in the employees' directory, even though they worked so hard to get the promotion. Soul-crushing. And all that because of a weak ETag. So choose your validators wisely!\nDeeper into the validators Let’s look at the format of Last-Modified and ETag, how to generate them, how to perform the comparison, and when to use them.\nLast-modified As we already established, the Last-Modified response header is a timestamp that indicates when the origin server believes the selected resource was last modified while handling the request.\nFor example, if the origin server serves a request to GET /users/1 at Date: 2021-05-05 12:00:00, then the Last-Modified header will be set to a timestamp that the server knows the user with an ID of 1 was last updated. When the origin server responds to a GET /users/1, even a second later in time (at Date: 2021-05-05 12:00:01), the server can potentially return a different Last-Modified as in the meantime the underlying entity might be updated.\nSetting the Last-Modified In the wild, the Last-Modified header on the response is rarely generated based on a single resource. When set on web pages, the Last-Modified header will be set based on all the different resources that are rendered on the page.\nTherefore the most straightforward way to generating the Last-Modified header is to take the most recent time that the server has changed any of those resources. An additional angle to consider is if all resources rendered on the page are worth busting the cache.\nFor example, a page that renders TV shows for watching, with a list of recommended shows in the footer, could set the Last-Modified to the most recent time server updated the TV show entity. When the recommendations in the footer change, the origin server can still keep the Last-Modified tied to the show update time, as the recommendations are secondary to the page.\n  When the TV show gets a new season, this is an event when the server should update the Last-Modified header, as we would like all users to see that we have added a new season.\nBut if the recommendations keep people watching and discovering new shows, then more recent (and better), recommendations should also be taken into account when setting the Last-Modified header.\nETag ETag is an opaque validator - as we already mentioned, the server generates the entity tags, but how it generates them is unknown to the user-agent. In fact, from the user-agent perspective, the approach to generating the ETag is irrelevant. It’s only crucial that the ETag is changed once the resource representation changes, so the user-agent can revalidate when the change happens.\nThe main principle to generating and sending an ETag is always to create one where the server can reliably and consistently determine the changes on the underlying resource. Proper usage of ETags will substantially reduce HTTP network traffic and can be a significant factor in improving service scalability and reliability.\nComparing ETags ETags opaqueness forced their inventors to add a weakness denominator: the W/ prefix. For example, the same ETag header will be differently handled by the user-agent, based on the weakness indicator:\n1 2 3 4 5  # Weak ETag ETag: \"W/3cb377-13f27-5c0c816db0d40\" # Strong ETag ETag: \"3cb377-13f27-5c0c816db0d40\"   Although they contain the same value, these two headers are different due to the weakness indicator. Looking at the example above, we can see that strong is the default, or in other words, an ETag is weak only if the weak indicator (W/) is present.\nA comparison table on weak and strong ETags looks like this:\n   ETag 1 ETag 2 Strong Comparison Weak Comparison     W/\"Foo\" W/\"Foo\" No match Match   W/\"Foo\" W/\"Bar\" No match No match   W/\"Foo\" \"Foo\" No match Match   \"Foo\" \"Foo\" Match Match    Conditional requests semantics and mechanisms Now that we understand the validator headers and their intricacies let’s look at the precondition and header semantics.\nThere are five headers used for communicating preconditions between the user-agent and the servers:\n If-Match If-None-Match If-Modified-Since If-Unmodified-Since If-Range  In this article, we are looking at only conditional reads, or conditional GETs, as a way of caching content at the user-agent. That’s why, out of the five headers above, we will look only at the 2nd and 3rd: If-None-Match and If-Modified-Since. The other three are used for conditional requests but of a different kind that we will look into in another article.\nBefore we continue investigating the two headers, let’s first familiarize ourselves with the example application that we’ll be using.\nFamiliarizing with our application We will begin this exploration by looking at a sample application. For my comfort, we will use a Ruby on Rails application. Yet, the concepts discussed can be transferred to any web framework or language, as long as it can speak HTTP.\nThe application that we will be using to demonstrate these concepts is the “Sample app” built as part of the most popular Ruby on Rails book - Ruby on Rails Tutorial by Michael Hartl. The complete source code is available on Github.\nThe sample application is a Twitter clone. It is a multi-tenant application where users can create microposts. The application’s root path (/) points to the timeline of the logged-in user, which the StaticPagesController#home action renders:\n1 2 3 4 5 6 7  class StaticPagesController ApplicationController def home if logged_in? @feed_items = current_user.feed.paginate(page: params[:page]) end end end   Below you can see what the microposts feed looks like:\n  Let’s use this action and explore the various ways we can implement conditional HTTP requests.\nConditional requests using ETags and If-None-Match As mentioned in RFC-7232, the implementation of ETags is left to the server itself. That’s why there is no single implementation of ETags. It is every server for itself.\nThe case for using conditional requests, in this case, is: when a user is logged in, we would like not to send bytes over the network as long as there are no new @feed_items on the page.\nWhy? Think about this: we open the page, get the latest microposts from the people we follow and read them. That’s it. The next time we refresh the page, if there are no new microposts on the page, our browser already has all the data in its cache, so there’s no need to fetch new bytes from the server.\nIn such cases, we want to skip (most of) the network traffic and get an HTTP 304 Not modified from the server. As stated in section 4.1 of RFC-7232:\n The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false. In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the payload of a 200 (OK) response.\n This excerpt is packed, but the main point is: the client made the request conditional (using a header), the server evaluated the condition and decided that the client has the fresh content by returning an HTTP 304.\n  In our example, having the latest @feed_items means that there’s nothing new to be returned by the server, so the server informs the client that the cached @feed_items are still valid to be used by returning HTTP 304.\nNow, how can we practically do that?\nA manual approach As we mentioned before, the ETag is a string that differentiates between multiple representations of the same resource. It means that if the @feed_items collection changes, the ETag must also change. In addition, two identical @feed_items collections must have the same ETags.\nKnowing all of this, our ETag has to consider the id and the content of the Micropost (the @feed_items collection contains multiple Micropost objects). If the id or content changes on any Micropost, we want the ETag to change. When the ETag changes, the client will fail the revalidation condition, and the server will respond with the latest data.\nTherefore, the ETag of the @feed_items collection will consist of all ETags of each Micropost in the collection. The implementation would look like this:\n1 2 3 4 5  # app/models/micropost.rb def my_etag [id, Digest::MD5.hexdigest(content)].join('-') end   If we run this method against a micropost:\n1 2 3 4 5 6 7 8   m = Micropost.last = # m.id = 1  m.content = \"Soluta dolorem aspernatur doloremque vel.\"  m.my_etag = \"1-3268ba55dd9915c975821eda93eb22dc\"   We concatenate the MD5 hash of the content and the id to form an ETag for the micropost.\nUsually, we generate the ETag using an MD5 hash of the resource, allowing us to use a single string value, with 32 hexadecimal digits, instead of long arbitrary strings.\nThe MD5 hash will also change if any of the parameters used to generate it get changed.\n Now, back to our controller:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # app/controllers/static_pages_controller.rb def home if logged_in? @feed_items = current_user.feed.paginate(page: params[:page]) my_etag = @feed_items.map(\u0026:my_etag).join('-') if my_etag != request.headers['If-None-Match'] response.set_header('ETag', my_etag) else head :not_modified end end end   We generate my_etag for the @feed_items collection by joining all the Micropost#my_etag outputs for each micropost in the collection. Then, we take the If-None-Match header from the request and compare it with the my_etag value. If the two are the same, that means that the browser already has the latest @feed_items in its cache, and there’s no point for the server to return it again. Instead, it returns a response with HTTP 304 status and no body.\nIf the two values differ, then we set the response header ETag to that new value, and we return the whole response.\nBut why the If-None-Match header? As described in section 3.2 of RFC-7232:\n The “If-None-Match” header field makes the request method conditional on a recipient cache or origin server either not having any current representation of the target resource, or having a selected representation with an entity-tag that does not match any of those listed in the field-value.\n In other words, the client sends the ETag value in the If-None-Match header, and our server decides whether that’s the valid representation of the content to be served. If it is valid, then the server will return an HTTP 304 to the client.\nIf we send a request to the page again, we will see the following output:\n  Our (massive!) custom ETag is present. While such a long header is not practical, it still works. If we rerun the same request, by refreshing the page, we will see the server responding with an HTTP 304:\n  That happened because our browser sent the ETag value as part of the If-none-match header:\n  Voila! We implemented our conditional requests using Rails. Before we go on, there’s one thing I’d like to point out – avoid custom implementations. Our implementation is problematic, as it does not consider the differences between strong and weak validators.\nThere’s a better way to do it – using the built-in helpers by the web framework or a library for the respective language/framework.\nUsing helpers Similar to most web frameworks, Rails provides helpers to deal with conditional GET requests. In our particular case, we can substitute all of the custom code we wrote with a single method call: fresh_when.\nHere’s the new version of our controller action:\n1 2 3 4 5 6 7 8 9  # app/controllers/static_pages_controller.rb def home if logged_in? @feed_items = current_user.feed.paginate(page: params[:page]) fresh_when(etag: @feed_items) end end   Internally fresh_when will do what our custom code did before, and a bit more.\nIf we inspect the method’s source code, we will see that fresh_when can handle both strong and weak ETags and the Last-modified header (which we will look into soon).\nIn our code snippet above, we explicitly set the etag to be set by fresh_when based on the @feed_items collection.\nBut how Rails know how to calculate the ETag? Well, internally fresh_when calls the ActionDispatch::Http::Cache::Request#fresh? method, which handles the ETag validation. It taps into the If-None-Match value of the request object and the ETag header value of the response and compares the two.\nIf we test out the new code, we will see a very similar behavior as before:\n  The server set the ETag response header to a string, prepending it with W/ denoting a weak ETag. The server will exhibit the same behavior on the next request: an empty response body with the HTTP 304 Not Modified status.\n  Conditional requests using Last-modified and If-Modified-Since As we mentioned before, the Last-modified header contains a timestamp specifying when the server last changed the object. If we continue to use the same example with @feed_items, we are running into an interesting problem: from all the @feed_items in the collection, we have to return only a single last modified date. What object’s last modified date should we pick then?\nThe easiest way to do it is to find the largest last updated date from all the objects in the collection. Neatly, most Rails models have a updated_at attribute updated when the record in the database is changed – perfect for us to use it as the last updated date.\nIf your framework or application does not have the updated_at attribute (or similar), you need to figure out another way to deduce when each record was last updated. We can find the last updated timestamp through an audit trail or another field in the database.\nStill, I recommend adding a updated_at field as it is a neat way to solve the problem.\n In the example application, that would look like:\n1  last_modified = @feed_items.map(\u0026:updated_at).max.httpdate   Knowing all this, let’s implement this manually and then using fresh_when.\nA manual approach Validating the If-Modified-Since is a comparison between two DateTime objects: the last_modified and the if_modified_since. We want to compare the two and return an HTTP 304 if the last_modified is more recent (larger) than the if_modified_since.\nIf the client does not send the If-Modified-Since header, we need to make sure we return it to the client to send it on the subsequent request.\nAll of that, in code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # app/controllers/static_pages_controller.rb def home if logged_in? @feed_items = current_user.feed.paginate(page: params[:page]) last_modified = @feed_items.map(\u0026:updated_at).max.httpdate if request.headers.key?('If-Modified-Since') if_modified_since = DateTime.parse(request.headers['If-Modified-Since']).httpdate head :not_modified if if_modified_since = last_modified end response.set_header('Last-Modified', last_modified) end end   If we give this a shot in the browser, we will see that on the first request-response cycle, we will get the Last-Modified header set:\n  Following the spec, on the subsequent request, the browser will send the If-Modified-Since condition header, which will cause the server to make the comparison of the two dates. Once it determines that the dates are the same, it will return an HTTP 304:\n  If we were to update any of the @feed_items or create a new item, the last_modified date would be changed, and the conditional validation will fail, resulting in an HTTP 200 instead of an HTTP 304.\nEven though this implementation works fine, let’s see how we can do that with fresh_when.\nUsing fresh_when Similar to before, finding the last_modified stays in the code. But all the other logic goes away:\n1 2 3 4 5 6 7 8 9 10 11  # app/controllers/static_pages_controller.rb def home if logged_in? @feed_items = current_user.feed.paginate(page: params[:page]) last_modified = @feed_items.map(\u0026:updated_at).max fresh_when(last_modified: last_modified) end end   That’s all! We substituted that logic with a single line of fresh_when. If we rerun the same tests, the behavior will stay identical:\n  In the first request-response cycle, we got the Last-Modified header set on the response.\nAnd similar to before, on the following request, the browser will send the If-Modified-Since condition header, which will cause the server to make the comparison of the two dates. Once it determines that the dates are the same, it will return an HTTP 304:\n  As you can see, both the manual and the built-in solutions work identically. Revalidating requests using Last-Modified and If-Modified-Since is a powerful mechanism of speeding up our applications by not sending (useless) bytes over the network.\nOutro We began our exploration of conditional requests by looking at the specification. We familiarized ourselves with validators, conditions,and how they work. We then went on to explore how we can implement conditional HTTP requests with some header comparisons. Our Last-Modified implementation works as well as the built-in framework one!\nWe saw how implementing such optimizations can improve the performance of our web applications. We all know the fastest requests are the ones that are never sent. But as the title of this article says: the second-fastest are the ones that need no response body!\nWhile there are more details that we could explore here, this covers the whole topic of conditional GET requests. We could further explore conditional requests for static files (such as assets) in combination with Content Delivery Networks (or popularly called CDNs). But that is a topic for another article.\nAnd, as always, I hope you all learned something.\nFurther reading  RFC-7232 HTTP conditional requests on MDN Conditional View Processing in Django ActionController::ConditionalGet in Rails ETag and Conditionals Package in Laravel  Liked this article? You can buy me a coffee. Or simply subscribe to my newsletter and get my fresh posts in your inbox. It's short and sweet, going out monthly to over 1,000 subscribers.  ","wordCount":"3929","inLanguage":"en","datePublished":"2021-06-01T00:00:00Z","dateModified":"2021-06-01T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/conditional-http-get-fastest-requests-need-no-response-body/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Conditional HTTP GET: The fastest requests need no response body</h1><div class=post-meta>June 1, 2021&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#http-caching-101 aria-label="HTTP caching 101">HTTP caching 101</a></li><li><a href=#conditional-http-requests aria-label="Conditional HTTP requests">Conditional HTTP requests</a></li><li><a href=#validator-types aria-label="Validator types">Validator types</a><ul><li><a href=#strong-validators aria-label="Strong validators">Strong validators</a></li><li><a href=#weak-validators aria-label="Weak validators">Weak validators</a></li></ul></li><li><a href=#deeper-into-the-validators aria-label="Deeper into the validators">Deeper into the validators</a><ul><li><a href=#last-modified aria-label=Last-modified><code>Last-modified</code></a><ul><li><a href=#setting-the-last-modified aria-label="Setting the Last-Modified">Setting the <code>Last-Modified</code></a></li></ul></li><li><a href=#etag aria-label=ETag><code>ETag</code></a><ul><li><a href=#comparing-etags aria-label="Comparing ETags">Comparing <code>ETag</code>s</a></li></ul></li></ul></li><li><a href=#conditional-requests-semantics-and-mechanisms aria-label="Conditional requests semantics and mechanisms">Conditional requests semantics and mechanisms</a><ul><li><a href=#familiarizing-with-our-application aria-label="Familiarizing with our application">Familiarizing with our application</a></li></ul></li><li><a href=#conditional-requests-using-etags-and-if-none-match aria-label="Conditional requests using ETags and If-None-Match">Conditional requests using <code>ETag</code>s and <code>If-None-Match</code></a><ul><li><a href=#a-manual-approach aria-label="A manual approach">A manual approach</a></li><li><a href=#using-helpers aria-label="Using helpers">Using helpers</a></li></ul></li><li><a href=#conditional-requests-using-last-modified-and-if-modified-since aria-label="Conditional requests using Last-modified and If-Modified-Since">Conditional requests using <code>Last-modified</code> and <code>If-Modified-Since</code></a><ul><li><a href=#a-manual-approach-1 aria-label="A manual approach">A manual approach</a></li><li><a href=#using-fresh_when aria-label="Using fresh_when">Using <code>fresh_when</code></a></li></ul></li><li><a href=#outro aria-label=Outro>Outro</a></li><li><a href=#further-reading aria-label="Further reading">Further reading</a></li></ul></div></details></div><div class=post-content><h2 id=http-caching-101>HTTP caching 101<a hidden class=anchor aria-hidden=true href=#http-caching-101>#</a></h2><p>Every browser implements its own in-memory caching. The information about the
cache size per browser is spotty, but there&rsquo;s one thing for sure: the cache
sizes vary. The great thing is that browsers are smart nowadays – they manage
their caches opaquely for us, the end-users.</p><p>There are a few ways to put these caches to use. But it all starts with HTTP
caching directives (or headers). The two HTTP response headers used for
specifying freshness (another word for should something be cached) are
<code>Cache-Control</code> and <code>Expires</code>:</p><ul><li><code>Expires</code> sets an explicit date and time when the content expires;</li><li><code>Cache-Control</code> specifies how long the browser can cache the content relative
to the fetch time</li></ul><p>In cases when the request has both headers specified, <code>Cache-Control</code> takes
precedence.</p><p>Another way to put the browser caches to use is by using conditional requests
and revalidation. We use the <code>Last-modified</code> and <code>ETag</code> (Entity Tag) response
headers for that purpose:</p><ul><li><code>Last-modified</code> is a timestamp that specifies when the backend last changed
the object.</li><li><code>ETag</code> is a unique identifier for the content as a string. The server decides
its format, but usually, it’s some form of a hash.</li></ul><p>As we advance, we will explore caching by using conditional GET requests.
In-depth!</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/browser-server-robots-etag-304.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=conditional-http-requests>Conditional HTTP requests<a hidden class=anchor aria-hidden=true href=#conditional-http-requests>#</a></h2><p>Conditional requests are HTTP requests that include headers that indicate a
certain precondition. When said headers are present, the HTTP server must check
the condition. The server must perform the check before executing the HTTP
method against the target resource. The result of the request can be
different based on the result of the check of the precondition.</p><p>At the core of the conditional HTTP requests are validators. Validators are
metadata the user-agent and the server use to discern if a resource is
stale or not. The revalidation mechanisms implemented by the HTTP server check
if the resource stored on the server matches a specific version that the
user-agent has cached. The HTTP server performs the check (validation) based on
the validators (metadata) sent by the user-agent.</p><p>Validators fall in two categories:</p><ul><li>timestamp of last modification of the resource - the <code>Last-Modified</code> header</li><li>unique string representing the resource version - the <code>ETag</code> (entity tag)
header</li></ul><h2 id=validator-types>Validator types<a hidden class=anchor aria-hidden=true href=#validator-types>#</a></h2><p>Both validators, <code>Last-Modified</code> and <code>ETag</code>, allow two types of validation:
weak and strong. Depending on the case, the complexity of implementing the
validation can vary.</p><h3 id=strong-validators>Strong validators<a hidden class=anchor aria-hidden=true href=#strong-validators>#</a></h3><p>Strong validators are metadata that changes its value whenever the
representational data of the resource changes. The representational data is the
data format that would be observable in the payload body of an HTTP 200 OK
response to <code>GET /resource/:id</code>.</p><p>I know that&rsquo;s loaded, so let me explain through an oversimplified example.
Imagine we have a user resource served by <code>GET /users/:id</code>. For example, the
response body of <code>GET /users/1</code> would be:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#0087ff>&#34;id&#34;</span>: <span style=color:#00afaf>1</span>,
  <span style=color:#0087ff>&#34;name&#34;</span>: <span style=color:#00afaf>&#34;Jane&#34;</span>,
  <span style=color:#0087ff>&#34;age&#34;</span>: <span style=color:#00afaf>30</span>
}</code></pre></td></tr></table></div></div><p>A strong validator in this particular case can be an <code>ETag</code> composed based on
the user&rsquo;s <code>id</code>, <code>name</code>, and <code>age</code> attributes. In Ruby, the MD5 hash of these
three values would be:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; <span style=color:#d75f00>Digest</span>::<span style=color:#d75f00>MD5</span>.hexdigest(<span style=color:#00afaf>&#34;1-Jane-30&#34;</span>)
=&gt; <span style=color:#00afaf>&#34;fb324ab8bda9e1cbb47c2a001fa36349&#34;</span></code></pre></td></tr></table></div></div><p>If any of the attributes of the user change, given that our <code>ETag</code> is supposed
to be a strong validator, we would like the <code>ETag</code> value to change. For
example, after <code>Jane</code>&rsquo;s birthday, the <code>age</code> will increase to <code>31</code>. The new
<code>ETag</code> would be:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; <span style=color:#d75f00>Digest</span>::<span style=color:#d75f00>MD5</span>.hexdigest(<span style=color:#00afaf>&#34;1-Jane-31&#34;</span>)
=&gt; <span style=color:#00afaf>&#34;f78e2fe80b589cd55a2fef324e877d34&#34;</span></code></pre></td></tr></table></div></div><p>But also the change in the representational data of the resource is observable
by <code>GET</code>-ing it from the server, e.g., <code>GET /users/1</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#0087ff>&#34;id&#34;</span>: <span style=color:#00afaf>1</span>,
  <span style=color:#0087ff>&#34;name&#34;</span>: <span style=color:#00afaf>&#34;Jane&#34;</span>,
  <span style=color:#0087ff>&#34;age&#34;</span>: <span style=color:#00afaf>31</span>
}</code></pre></td></tr></table></div></div><p>This means that the metadata sent in the <code>ETag</code> changed because it is also
observable by the user-agent in the data of the resource itself – not a magical
field in the server&rsquo;s database that the user-agent won&rsquo;t know about.</p><p>There are scenarios, such as content negotiation, in which strong validators
can change. The bottom line is: the origin server should only change the
validator’s value when it is necessary to invalidate the cached responses in
caches and other user-agents.</p><p>HTTP uses strong validation by default, but it provides a way for clients to
specify when they use weak validation. Clients can prepend <code>ETag</code>s with the
<code>W/</code> string, denoting that the server should perform a weak validation.</p><h3 id=weak-validators>Weak validators<a hidden class=anchor aria-hidden=true href=#weak-validators>#</a></h3><p>A weak validator is metadata that might not change for every change to the
representation data. It&rsquo;s the opposite of the strong validators – even if the
representation data changes, the HTTP server considers the change not worth
busting the cached representation in the user-agents and other proxies/caches.</p><p>Building on the example from above, let&rsquo;s imagine that the representation of
the user is as follows:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#0087ff>&#34;id&#34;</span>: <span style=color:#00afaf>1</span>,
  <span style=color:#0087ff>&#34;name&#34;</span>: <span style=color:#00afaf>&#34;Jane&#34;</span>,
  <span style=color:#0087ff>&#34;age&#34;</span>: <span style=color:#00afaf>31</span>,
  <span style=color:#0087ff>&#34;position&#34;</span>: <span style=color:#00afaf>&#34;Software Engineer&#34;</span>
}</code></pre></td></tr></table></div></div><p>If this user is promoted, from <code>Software Engineer</code> to <code>Senior Software Engineer</code>, a strong validator would be updated, causing user-agents and proxies
to invalidate their caches. But what about weak validators?</p><p><strong>It depends.</strong> The validator&rsquo;s weakness might stem from how the product uses
the data or the context in which it resides. For example, say we have an
endpoint as part of an employee directory within a company. In that context,
the change of <code>age</code> (i.e. birthday) might not be the reason to invalidate a
resource. Invalidation in such an event will bust the caches, and we will
incur a performance penalty for a non-essential change.</p><p>If that is the case, the <code>ETag</code> will not take all attributes from the
representation into account – only the relevant ones, hence being a weak
<code>ETag</code>. For example:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; etag = <span style=color:#d75f00>Digest</span>::<span style=color:#d75f00>MD5</span>.hexdigest(<span style=color:#00afaf>&#34;1-Jane-Software-Engineer&#34;</span>)
=&gt; <span style=color:#00afaf>&#34;d18968bf453b0208dbbbcb5bd72af3e1&#34;</span></code></pre></td></tr></table></div></div><p>But a change of <code>position</code> (a.k.a. promotion) is relevant information that
<em>should</em> cause the resource to be revalidated by caches.</p><p>In other words, an origin server should change a weak entity tag whenever it
considers prior representations to be unacceptable as a substitute for the
current representation.</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/browser-server-robots-weak-etag-304.png caption="Revalidating weak ETags" alt="Revalidating weak ETags">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em">Revalidating weak ETags</span></figure><p>Imagine <code>Jane</code> getting a promotion and then still seeing their old title in the
employees' directory, even though they worked so hard to get the promotion.
Soul-crushing. And all that because of a weak <code>ETag</code>. So choose your
validators wisely!</p><h2 id=deeper-into-the-validators>Deeper into the validators<a hidden class=anchor aria-hidden=true href=#deeper-into-the-validators>#</a></h2><p>Let&rsquo;s look at the format of <code>Last-Modified</code> and <code>ETag</code>, how to generate them,
how to perform the comparison, and when to use them.</p><h3 id=last-modified><code>Last-modified</code><a hidden class=anchor aria-hidden=true href=#last-modified>#</a></h3><p>As we already established, the <code>Last-Modified</code> response header is a timestamp
that indicates when the origin server believes the selected resource was last
modified while handling the request.</p><p>For example, if the origin server serves a request to <code>GET /users/1</code> at
<code>Date: 2021-05-05 12:00:00</code>, then the <code>Last-Modified</code> header will be set to a
timestamp that the server knows the user with an ID of 1 was last updated.
When the origin server responds to a <code>GET /users/1</code>, even a second later in time
(at <code>Date: 2021-05-05 12:00:01</code>), the server can potentially return a different
<code>Last-Modified</code> as in the meantime the underlying entity might be updated.</p><h4 id=setting-the-last-modified>Setting the <code>Last-Modified</code><a hidden class=anchor aria-hidden=true href=#setting-the-last-modified>#</a></h4><p>In the wild, the <code>Last-Modified</code> header on the response is rarely generated
based on a single resource. When set on web pages, the <code>Last-Modified</code> header
will be set based on all the different resources that are rendered on the page.</p><p>Therefore the most straightforward way to generating the <code>Last-Modified</code> header
is to take the most recent time that the server has changed any of those
resources. An additional angle to consider is if <strong>all</strong> resources rendered on
the page are worth busting the cache.</p><p>For example, a page that renders TV shows for watching, with a list of
recommended shows in the footer, could set the <code>Last-Modified</code> to the most
recent time server updated the TV show entity. When the recommendations in the
footer change, the origin server can still keep the <code>Last-Modified</code> tied to the
show update time, as the recommendations are secondary to the page.</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/browser-server-robots-the-crown-last-modified.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>When the TV show gets a new season, this is an event when the server should
update the <code>Last-Modified</code> header, as we would like all users to see that we
have added a new season.</p><p><strong>But</strong> if the recommendations keep people watching and discovering new shows,
then more recent (and better), recommendations should also be taken into
account when setting the <code>Last-Modified</code> header.</p><h3 id=etag><code>ETag</code><a hidden class=anchor aria-hidden=true href=#etag>#</a></h3><p><code>ETag</code> is an opaque validator - as we already mentioned, the server generates
the entity tags, but <em>how</em> it generates them is unknown to the user-agent. In
fact, from the user-agent perspective, the approach to generating the <code>ETag</code> is
irrelevant. It&rsquo;s only crucial that the <code>ETag</code> is changed once the resource
representation changes, so the user-agent can revalidate when the change
happens.</p><p>The main principle to generating and sending an <code>ETag</code> is always to create one
where the server can reliably and consistently determine the changes on the
underlying resource. Proper usage of <code>ETag</code>s will substantially reduce HTTP
network traffic and can be a significant factor in improving service
scalability and reliability.</p><h4 id=comparing-etags>Comparing <code>ETag</code>s<a hidden class=anchor aria-hidden=true href=#comparing-etags>#</a></h4><p><code>ETag</code>s opaqueness forced their inventors to add a weakness denominator: the
<code>W/</code> prefix. For example, the same <code>ETag</code> header will be differently handled by
the user-agent, based on the weakness indicator:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># Weak ETag
ETag: &#34;W/3cb377-13f27-5c0c816db0d40&#34;

# Strong ETag
ETag: &#34;3cb377-13f27-5c0c816db0d40&#34;</code></pre></td></tr></table></div></div><p>Although they contain the same value, these two headers are different due to
the weakness indicator. Looking at the example above, we can see that strong is
the default, or in other words, an <code>ETag</code> is weak only if the weak indicator
(<code>W/</code>) is present.</p><p>A comparison table on weak and strong <code>ETag</code>s looks like this:</p><table><thead><tr><th>ETag 1</th><th>ETag 2</th><th>Strong Comparison</th><th>Weak Comparison</th></tr></thead><tbody><tr><td><code>W/"Foo"</code></td><td><code>W/"Foo"</code></td><td>No match</td><td>Match</td></tr><tr><td><code>W/"Foo"</code></td><td><code>W/"Bar"</code></td><td>No match</td><td>No match</td></tr><tr><td><code>W/"Foo"</code></td><td><code>"Foo"</code></td><td>No match</td><td>Match</td></tr><tr><td><code>"Foo"</code></td><td><code>"Foo"</code></td><td>Match</td><td>Match</td></tr></tbody></table><h2 id=conditional-requests-semantics-and-mechanisms>Conditional requests semantics and mechanisms<a hidden class=anchor aria-hidden=true href=#conditional-requests-semantics-and-mechanisms>#</a></h2><p>Now that we understand the validator headers and their intricacies let&rsquo;s look
at the precondition and header semantics.</p><p>There are five headers used for communicating preconditions between the
user-agent and the servers:</p><ol><li><code>If-Match</code></li><li><code>If-None-Match</code></li><li><code>If-Modified-Since</code></li><li><code>If-Unmodified-Since</code></li><li><code>If-Range</code></li></ol><p>In this article, we are looking at only conditional reads, or conditional
<code>GET</code>s, as a way of caching content at the user-agent. That&rsquo;s why, out of the
five headers above, we will look only at the 2nd and 3rd: <code>If-None-Match</code> and
<code>If-Modified-Since</code>. The other three <strong>are</strong> used for conditional requests but
of a different kind that we will look into in another article.</p><p>Before we continue investigating the two headers, let&rsquo;s first familiarize
ourselves with the example application that we&rsquo;ll be using.</p><h3 id=familiarizing-with-our-application>Familiarizing with our application<a hidden class=anchor aria-hidden=true href=#familiarizing-with-our-application>#</a></h3><p>We will begin this exploration by looking at a sample application. For my
comfort, we will use a Ruby on Rails application. Yet, the concepts discussed
can be transferred to any web framework or language, as long as it can speak
HTTP.</p><p>The application that we will be using to demonstrate these concepts is the
&ldquo;Sample app&rdquo; built as part of the most popular Ruby on Rails book -
<a href=https://www.railstutorial.org/book>Ruby on Rails Tutorial</a> by Michael Hartl.
The complete source code is available <a href=https://github.com/mhartl/sample_app_6th_ed>on
Github</a>.</p><p>The sample application is a Twitter clone. It is a multi-tenant application
where users can create <em>microposts</em>. The application&rsquo;s root path (<code>/</code>) points
to the timeline of the logged-in user, which the <code>StaticPagesController#home</code>
action renders:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#5f8700>class</span> <span style=color:#0087ff>StaticPagesController</span> &lt; <span style=color:#d75f00>ApplicationController</span>
  <span style=color:#5f8700>def</span> <span style=color:#0087ff>home</span>
    <span style=color:#5f8700>if</span> logged_in?
      @feed_items = current_user.feed.paginate(<span style=color:#00afaf>page</span>: params[<span style=color:#00afaf>:page</span>])
    <span style=color:#5f8700>end</span>
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>Below you can see what the microposts feed looks like:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Let&rsquo;s use this action and explore the various ways we can implement conditional
HTTP requests.</p><h2 id=conditional-requests-using-etags-and-if-none-match>Conditional requests using <code>ETag</code>s and <code>If-None-Match</code><a hidden class=anchor aria-hidden=true href=#conditional-requests-using-etags-and-if-none-match>#</a></h2><p>As mentioned in <a href=https://datatracker.ietf.org/doc/html/rfc7232>RFC-7232</a>, the
implementation of <code>ETag</code>s is left to the server itself. That&rsquo;s why there is no
single implementation of <code>ETag</code>s. It is every server for itself.</p><p>The case for using conditional requests, in this case, is: when a user is
logged in, we would like <strong>not</strong> to send bytes over the network as long as there
are no new <code>@feed_items</code> on the page.</p><p>Why? Think about this: we open the page, get the latest microposts from the
people we follow and read them. That&rsquo;s it. The next time we refresh the page,
if there are no new microposts on the page, our browser already has all the
data in its cache, so there&rsquo;s no need to fetch new bytes from the server.</p><p>In such cases, we want to skip (most of) the network traffic and get an HTTP
304 Not modified from the server. As stated in section 4.1 of
<a href=https://datatracker.ietf.org/doc/html/rfc7232#section-4.1>RFC-7232</a>:</p><blockquote><p>The 304 (Not Modified) status code indicates that a conditional GET
or HEAD request has been received and would have resulted in a 200
(OK) response if it were not for the fact that the condition
evaluated to false. In other words, <strong>there is no need for the server
to transfer a representation of the target resource because the
request indicates that the client, which made the request
conditional, already has a valid representation</strong>; the server is
therefore redirecting the client to make use of that stored
representation as if it were the payload of a 200 (OK) response.</p></blockquote><p>This excerpt is packed, but the main point is: the client made the request
conditional (using a header), the server evaluated the condition and decided
that the client has the fresh content by returning an HTTP 304.</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/browser-server-robots-etag-304.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>In our example, having the latest <code>@feed_items</code> means that there&rsquo;s nothing new
to be returned by the server, so the server informs the client that the cached
<code>@feed_items</code> are still valid to be used by returning HTTP 304.</p><p>Now, <strong>how can we practically do that?</strong></p><h3 id=a-manual-approach>A manual approach<a hidden class=anchor aria-hidden=true href=#a-manual-approach>#</a></h3><p>As we mentioned before, the <code>ETag</code> is a string that differentiates between
multiple representations of the same resource. It means that if the
<code>@feed_items</code> collection changes, the <code>ETag</code> must also change. In addition, two
identical <code>@feed_items</code> collections must have the same <code>ETag</code>s.</p><p>Knowing all of this, our <code>ETag</code> has to consider the <code>id</code> and the <code>content</code> of
the <code>Micropost</code> (the <code>@feed_items</code> collection contains multiple <code>Micropost</code>
objects). If the <code>id</code> or <code>content</code> changes on any <code>Micropost</code>, we want the
<code>ETag</code> to change. When the <code>ETag</code> changes, the client will fail the
revalidation condition, and the server will respond with the latest data.</p><p>Therefore, the <code>ETag</code> of the <code>@feed_items</code> collection will consist of all
<code>ETag</code>s of each <code>Micropost</code> in the collection. The implementation would look
like this:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#4e4e4e># app/models/micropost.rb</span>

<span style=color:#5f8700>def</span> <span style=color:#0087ff>my_etag</span>
  [<span style=color:#0087ff>id</span>, <span style=color:#d75f00>Digest</span>::<span style=color:#d75f00>MD5</span>.hexdigest(content)].join(<span style=color:#00afaf>&#39;-&#39;</span>)
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>If we run this method against a micropost:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; m = <span style=color:#d75f00>Micropost</span>.last
=&gt; <span style=color:#4e4e4e>#&lt;Micropost id: 1, content: &#34;Soluta dolorem aspernatur doloremque vel.&#34;, user_id: 1, created_at:...</span>
&gt;&gt; m.id
=&gt; <span style=color:#00afaf>1</span>
&gt;&gt; m.content
=&gt; <span style=color:#00afaf>&#34;Soluta dolorem aspernatur doloremque vel.&#34;</span>
&gt;&gt; m.my_etag
=&gt; <span style=color:#00afaf>&#34;1-3268ba55dd9915c975821eda93eb22dc&#34;</span></code></pre></td></tr></table></div></div><p>We concatenate the MD5 hash of the <code>content</code> and the <code>id</code> to form an <code>ETag</code> for
the micropost.</p><div class="notice note"><p class="first notice-title"></p><p>Usually, we generate the <code>ETag</code> using an MD5 hash of the resource, allowing us
to use a single string value, with 32 hexadecimal digits, instead of long
arbitrary strings.</p><p>The MD5 hash will also change if any of the parameters used to generate it get
changed.</p></div><p>Now, back to our controller:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#4e4e4e># app/controllers/static_pages_controller.rb</span>

<span style=color:#5f8700>def</span> <span style=color:#0087ff>home</span>
  <span style=color:#5f8700>if</span> logged_in?
    @feed_items = current_user.feed.paginate(<span style=color:#00afaf>page</span>: params[<span style=color:#00afaf>:page</span>])

    my_etag = @feed_items.map(&amp;<span style=color:#00afaf>:my_etag</span>).join(<span style=color:#00afaf>&#39;-&#39;</span>)

    <span style=color:#5f8700>if</span> my_etag != request.headers[<span style=color:#00afaf>&#39;If-None-Match&#39;</span>]
      response.set_header(<span style=color:#00afaf>&#39;ETag&#39;</span>, my_etag)
    <span style=color:#5f8700>else</span>
      head <span style=color:#00afaf>:not_modified</span>
    <span style=color:#5f8700>end</span>
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>We generate <code>my_etag</code> for the <code>@feed_items</code> collection by joining all the
<code>Micropost#my_etag</code> outputs for each <code>micropost</code> in the collection. Then, we
take the <code>If-None-Match</code> header from the request and compare it with the
<code>my_etag</code> value. If the two are the same, that means that the browser already
has the latest <code>@feed_items</code> in its cache, and there&rsquo;s no point for the server
to return it again. Instead, it returns a response with <code>HTTP 304</code> status and
no body.</p><p>If the two values differ, then we set the response header <code>ETag</code> to that new
value, and we return the whole response.</p><p>But why the <code>If-None-Match</code> header? As described in section 3.2 of
<a href=https://datatracker.ietf.org/doc/html/rfc7232#section-3.2>RFC-7232</a>:</p><blockquote><p>The &ldquo;If-None-Match&rdquo; header field makes the request method conditional on a
recipient cache or origin server either not having any current representation
of the target resource, or having a selected representation with an
entity-tag that does not match any of those listed in the field-value.</p></blockquote><p>In other words, the client sends the <code>ETag</code> value in the <code>If-None-Match</code>
header, and our server decides whether that&rsquo;s the valid representation of the
content to be served. If it is valid, then the server will return an HTTP 304
to the
client.</p><p>If we send a request to the page again, we will see the following output:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-custom-etag-implementation.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Our (massive!) custom <code>ETag</code> is present. While such a long header is not
practical, it still works. If we rerun the same request, by refreshing the
page, we will see the server responding with an HTTP 304:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-custom-etag-implementation-304.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>That happened because our browser sent the <code>ETag</code> value as part of the
<code>If-none-match</code> header:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-custom-etag-implementation-304-if-none-match.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Voila! We implemented our conditional requests using Rails. Before we go on,
there&rsquo;s one thing I&rsquo;d like to point out – <strong>avoid custom implementations</strong>.
Our implementation is problematic, as it does not consider the differences
between strong and weak validators.</p><p>There&rsquo;s a better way to do it – using the built-in helpers by the web
framework or a library for the respective language/framework.</p><h3 id=using-helpers>Using helpers<a hidden class=anchor aria-hidden=true href=#using-helpers>#</a></h3><p>Similar to most web frameworks, Rails provides helpers to deal with conditional
GET requests. In our particular case, we can substitute all of the custom code
we wrote with a single method call: <code>fresh_when</code>.</p><p>Here&rsquo;s the new version of our controller action:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#4e4e4e># app/controllers/static_pages_controller.rb</span>

<span style=color:#5f8700>def</span> <span style=color:#0087ff>home</span>
  <span style=color:#5f8700>if</span> logged_in?
    @feed_items = current_user.feed.paginate(<span style=color:#00afaf>page</span>: params[<span style=color:#00afaf>:page</span>])

    fresh_when(<span style=color:#00afaf>etag</span>: @feed_items)
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>Internally <code>fresh_when</code> will do what our custom code did before, and a bit
more.</p><p>If we inspect the method&rsquo;s <a href=https://github.com/rails/rails/blob/85c6823b77b60f2a3a6a25d7a1013032e8c580ef/actionpack/lib/action_controller/metal/conditional_get.rb#L36-L122>source
code</a>,
we will see that <code>fresh_when</code> can handle both strong and weak <code>ETag</code>s and the
<code>Last-modified</code> header (which we will look into soon).</p><p>In our code snippet above, we explicitly set the <code>etag</code> to be set by
<code>fresh_when</code> based on the <code>@feed_items</code> collection.</p><p>But how Rails know how to calculate the <code>ETag</code>? Well, internally <code>fresh_when</code>
calls the <code>ActionDispatch::Http::Cache::Request#fresh?</code> method, which handles
the <code>ETag</code> validation. It taps into the <code>If-None-Match</code> value of the <code>request</code>
object and the <code>ETag</code> header value of the <code>response</code> and compares the two.</p><p>If we test out the new code, we will see a very similar behavior as before:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-fresh-when.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>The server set the <code>ETag</code> response header to a string, prepending it with <code>W/</code>
denoting a weak <code>ETag</code>. The server will exhibit the same behavior on the next
request: an empty response body with the HTTP 304 Not Modified status.</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-fresh-when-304.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=conditional-requests-using-last-modified-and-if-modified-since>Conditional requests using <code>Last-modified</code> and <code>If-Modified-Since</code><a hidden class=anchor aria-hidden=true href=#conditional-requests-using-last-modified-and-if-modified-since>#</a></h2><p>As we mentioned before, the <code>Last-modified</code> header contains a timestamp
specifying when the server last changed the object. If we continue to use the
same example with <code>@feed_items</code>, we are running into an interesting problem:
from all the <code>@feed_items</code> in the collection, we have to return only a single
last modified date. What object&rsquo;s last modified date should we pick then?</p><p>The easiest way to do it is to find the largest last updated date from all the
objects in the collection. Neatly, most Rails models have a <code>updated_at</code>
attribute updated when the record in the database is changed – perfect for us
to use it as the last updated date.</p><div class="notice note"><p class="first notice-title"></p><p>If your framework or application does not have the <code>updated_at</code> attribute (or
similar), you need to figure out another way to deduce when each record was
last updated. We can find the last updated timestamp through an audit trail or
another field in the database.</p><p>Still, I recommend adding a <code>updated_at</code> field as it is a neat way to solve the
problem.</p></div><p>In the example application, that would look like:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>last_modified = @feed_items.map(&amp;<span style=color:#00afaf>:updated_at</span>).max.httpdate</code></pre></td></tr></table></div></div><p>Knowing all this, let&rsquo;s implement this manually and then using <code>fresh_when</code>.</p><h3 id=a-manual-approach-1>A manual approach<a hidden class=anchor aria-hidden=true href=#a-manual-approach-1>#</a></h3><p>Validating the <code>If-Modified-Since</code> is a comparison between two <code>DateTime</code>
objects: the <code>last_modified</code> and the <code>if_modified_since</code>. We want to compare
the two and return an HTTP 304 if the <code>last_modified</code> is more recent (larger)
than the <code>if_modified_since</code>.</p><p>If the client does not send the <code>If-Modified-Since</code> header, we need to make
sure we return it to the client to send it on the subsequent request.</p><p>All of that, in code:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#4e4e4e># app/controllers/static_pages_controller.rb</span>

<span style=color:#5f8700>def</span> <span style=color:#0087ff>home</span>
  <span style=color:#5f8700>if</span> logged_in?
    @feed_items = current_user.feed.paginate(<span style=color:#00afaf>page</span>: params[<span style=color:#00afaf>:page</span>])

    last_modified = @feed_items.map(&amp;<span style=color:#00afaf>:updated_at</span>).max.httpdate

    <span style=color:#5f8700>if</span> request.headers.key?(<span style=color:#00afaf>&#39;If-Modified-Since&#39;</span>)
      if_modified_since = <span style=color:#d75f00>DateTime</span>.parse(request.headers[<span style=color:#00afaf>&#39;If-Modified-Since&#39;</span>]).httpdate

      head <span style=color:#00afaf>:not_modified</span> <span style=color:#5f8700>if</span> if_modified_since &gt;= last_modified
    <span style=color:#5f8700>end</span>

    response.set_header(<span style=color:#00afaf>&#39;Last-Modified&#39;</span>, last_modified)
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>If we give this a shot in the browser, we will see that on the first
request-response cycle, we will get the <code>Last-Modified</code> header set:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-custom-last-modified-implementation.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Following the spec, on the subsequent request, the browser will send the
<code>If-Modified-Since</code> condition header, which will cause the server to make the
comparison of the two dates. Once it determines that the dates are the same, it
will return an HTTP 304:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-custom-last-modified-implementation-304.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>If we were to update <em>any</em> of the <code>@feed_items</code> or create a new item, the
<code>last_modified</code> date would be changed, and the conditional validation will
fail, resulting in an HTTP 200 instead of an HTTP 304.</p><p>Even though this implementation works fine, let&rsquo;s see how we can do that with
<code>fresh_when</code>.</p><h3 id=using-fresh_when>Using <code>fresh_when</code><a hidden class=anchor aria-hidden=true href=#using-fresh_when>#</a></h3><p>Similar to before, finding the <code>last_modified</code> stays in the code. But all the
other logic goes away:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#4e4e4e># app/controllers/static_pages_controller.rb</span>

<span style=color:#5f8700>def</span> <span style=color:#0087ff>home</span>
  <span style=color:#5f8700>if</span> logged_in?
    @feed_items = current_user.feed.paginate(<span style=color:#00afaf>page</span>: params[<span style=color:#00afaf>:page</span>])

    last_modified = @feed_items.map(&amp;<span style=color:#00afaf>:updated_at</span>).max

    fresh_when(<span style=color:#00afaf>last_modified</span>: last_modified)
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>That&rsquo;s all! We substituted that logic with a single line of <code>fresh_when</code>. If
we rerun the same tests, the behavior will stay identical:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-fresh-when-last-modified.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>In the first request-response cycle, we got the <code>Last-Modified</code> header set on
the response.</p><p>And similar to before, on the following request, the browser will send the
<code>If-Modified-Since</code> condition header, which will cause the server to make the
comparison of the two dates. Once it determines that the dates are the same, it
will return an HTTP 304:</p><figure class=imagecaption><img class=caption src=/conditional-http-get-fastest-requests-needno-response-body/microposts-feed-fresh-when-last-modified-304.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>As you can see, both the manual and the built-in solutions work identically.
Revalidating requests using <code>Last-Modified</code> and <code>If-Modified-Since</code> is a
powerful mechanism of speeding up our applications by not sending (useless)
bytes over the network.</p><h2 id=outro>Outro<a hidden class=anchor aria-hidden=true href=#outro>#</a></h2><p>We began our exploration of conditional requests by looking at the
specification. We familiarized ourselves with validators, conditions,and how
they work. We then went on to explore how we can implement conditional HTTP
requests with some header comparisons. Our <code>Last-Modified</code> implementation works
as well as the built-in framework one!</p><p>We saw how implementing such optimizations can improve the performance of our
web applications. We all know the fastest requests are the ones that are never
sent. But as the title of this article says: the second-fastest are the ones
that need no response body!</p><p>While there are more details that we could explore here, this covers the whole
topic of conditional GET requests. We could further explore conditional
requests for static files (such as assets) in combination with Content Delivery
Networks (or popularly called CDNs). But that is a topic for another article.</p><p>And, as always, I hope you all learned something.</p><h2 id=further-reading>Further reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h2><ul><li><a href=https://datatracker.ietf.org/doc/html/rfc7232>RFC-7232</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests>HTTP conditional requests on MDN</a></li><li><a href=https://docs.djangoproject.com/en/3.2/topics/conditional-view-processing/>Conditional View Processing</a> in Django</li><li><a href=https://api.rubyonrails.org/v6.1.3.1/classes/ActionController/ConditionalGet.html><code>ActionController::ConditionalGet</code></a> in Rails</li><li><a href=https://laravel-news.com/laravel-etag-and-conditionals-package>ETag and Conditionals Package</a> in Laravel</li></ul><section class=subscribe><b>Liked this article?</b>
You can <a href=https://www.buymeacoffee.com/ieftimov>buy me a coffee</a>.
Or simply <a href=/newsletter>subscribe to my
newsletter</a> and get my fresh posts in your inbox. It's short and sweet,
going out monthly to over 1,000 subscribers.</section></div><footer class=post-footer><nav class=paginav><a class=next href=https://ieftimov.com/post/deep-dive-cors-history-how-it-works-best-practices/><span class=title>Next Page »</span><br><span>Deep dive in CORS: History, how it works, and best practices</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Conditional HTTP GET: The fastest requests need no response body on twitter" href="https://twitter.com/intent/tweet/?text=Conditional%20HTTP%20GET%3a%20The%20fastest%20requests%20need%20no%20response%20body&url=https%3a%2f%2fieftimov.com%2fpost%2fconditional-http-get-fastest-requests-need-no-response-body%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conditional HTTP GET: The fastest requests need no response body on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fconditional-http-get-fastest-requests-need-no-response-body%2f&title=Conditional%20HTTP%20GET%3a%20The%20fastest%20requests%20need%20no%20response%20body&summary=Conditional%20HTTP%20GET%3a%20The%20fastest%20requests%20need%20no%20response%20body&source=https%3a%2f%2fieftimov.com%2fpost%2fconditional-http-get-fastest-requests-need-no-response-body%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conditional HTTP GET: The fastest requests need no response body on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fconditional-http-get-fastest-requests-need-no-response-body%2f&title=Conditional%20HTTP%20GET%3a%20The%20fastest%20requests%20need%20no%20response%20body"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conditional HTTP GET: The fastest requests need no response body on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fconditional-http-get-fastest-requests-need-no-response-body%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conditional HTTP GET: The fastest requests need no response body on whatsapp" href="https://api.whatsapp.com/send?text=Conditional%20HTTP%20GET%3a%20The%20fastest%20requests%20need%20no%20response%20body%20-%20https%3a%2f%2fieftimov.com%2fpost%2fconditional-http-get-fastest-requests-need-no-response-body%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conditional HTTP GET: The fastest requests need no response body on telegram" href="https://telegram.me/share/url?text=Conditional%20HTTP%20GET%3a%20The%20fastest%20requests%20need%20no%20response%20body&url=https%3a%2f%2fieftimov.com%2fpost%2fconditional-http-get-fastest-requests-need-no-response-body%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>