<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Compose, stray PID files, Rails and beyond | Ilija Eftimov ⚡️</title><meta name=keywords content="docker,docker-compose,pid,tmpfs"><meta name=description content="Docker Compose + local development = ❤️ If you’re like me, you like a simple Docker Compose setup for your local project setup. It makes bringing up and tearing down different Docker containers easy with a single command. Especially if your application requires additional backing services, like a data store, a Docker Compose setup for local development makes it very easy to spin them all up in one go.
Another reason why I like Docker Compose because I am a bit of a purist when it comes to Dockerfiles – I believe that there should be only one Dockerfile for your service, and it should work for all environments."><meta name=author content="Ilija Eftimov"><link rel=canonical href=https://ieftimov.com/post/docker-compose-stray-pids-rails-beyond/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Docker Compose, stray PID files, Rails and beyond"><meta property="og:description" content="Docker Compose + local development = ❤️ If you’re like me, you like a simple Docker Compose setup for your local project setup. It makes bringing up and tearing down different Docker containers easy with a single command. Especially if your application requires additional backing services, like a data store, a Docker Compose setup for local development makes it very easy to spin them all up in one go.
Another reason why I like Docker Compose because I am a bit of a purist when it comes to Dockerfiles – I believe that there should be only one Dockerfile for your service, and it should work for all environments."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/docker-compose-stray-pids-rails-beyond/"><meta property="og:image" content="https://ieftimov.com/cards/docker-compose-stray-pids-rails-beyond.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-27T12:32:51+01:00"><meta property="article:modified_time" content="2021-10-27T12:32:51+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/docker-compose-stray-pids-rails-beyond.png"><meta name=twitter:title content="Docker Compose, stray PID files, Rails and beyond"><meta name=twitter:description content="Docker Compose + local development = ❤️ If you’re like me, you like a simple Docker Compose setup for your local project setup. It makes bringing up and tearing down different Docker containers easy with a single command. Especially if your application requires additional backing services, like a data store, a Docker Compose setup for local development makes it very easy to spin them all up in one go.
Another reason why I like Docker Compose because I am a bit of a purist when it comes to Dockerfiles – I believe that there should be only one Dockerfile for your service, and it should work for all environments."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Docker Compose, stray PID files, Rails and beyond","item":"https://ieftimov.com/post/docker-compose-stray-pids-rails-beyond/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Compose, stray PID files, Rails and beyond","name":"Docker Compose, stray PID files, Rails and beyond","description":"Docker Compose + local development = ❤️ If you’re like me, you like a simple Docker Compose setup for your local project setup. It makes bringing up and tearing down different Docker containers easy with a single command. Especially if your application requires additional backing services, like a data store, a Docker Compose setup for local development makes it very easy to spin them all up in one go.\nAnother reason why I like Docker Compose because I am a bit of a purist when it comes to Dockerfiles – I believe that there should be only one Dockerfile for your service, and it should work for all environments.","keywords":["docker","docker-compose","pid","tmpfs"],"articleBody":"Docker Compose + local development = ❤️ If you’re like me, you like a simple Docker Compose setup for your local project setup. It makes bringing up and tearing down different Docker containers easy with a single command. Especially if your application requires additional backing services, like a data store, a Docker Compose setup for local development makes it very easy to spin them all up in one go.\nAnother reason why I like Docker Compose because I am a bit of a purist when it comes to Dockerfiles – I believe that there should be only one Dockerfile for your service, and it should work for all environments. Nope, none of the Dockerfile.dev \u0026 Dockerfile.prod shenanigans. Why? Because I want my services to require only one set of dependencies, regardless of the deployment environment.\nFollowing that idea, Docker Compose uses the project’s Dockerfile and orchestrates all backing services via a simple YAML file. And the cherry on top: I can check-in docker-compose.yml version control, and everyone in my organization can reap the benefits.\nOK, OK, you know I like Docker Compose for local development. But, sometimes, it can be not very pleasant. For example, it doesn’t want to start a process or a server in a container because it never cleaned up its PID file.\nWhen running docker-compose up, you might have seen one of these error messages (or a variation):\nhttpd (pid 1) already running ERROR: Pidfile (celerybeat.pid) already exists. A server is already running. Check /usr/src/app/tmp/pids/server.pid. Seems familiar? Let’s work with a Rails application to reproduce the issue and fix it in four different ways.\nWhile this article uses a Rails application as an example to showcase the issue with stray PID files when using Docker Compose, the solution provided below is language- and framework-agnostic.\nIn other words, one can use the approaches showcased below with any programming language or framework, as long as the application is containerized.\n Dockerizing the app Let’s look at the Dockerfile of a simple Rails application, that uses no backing services. The Dockerfile will use the ruby:3.0.2-alpine3.14 image as base:\nFROMruby:3.0.2-alpine3.14 WORKDIR/app # Install runtime dependencies RUN apk add --no-cache \\  shared-mime-info \\  tzdata \\  sqlite-libs # Install the project dependencies COPY Gemfile* /app # Bundle build dependencies RUN apk add --no-cache --virtual build-dependencies \\  build-base \\  sqlite-dev \\  \u0026\u0026 bundle install \\  \u0026\u0026 rm -rf /usr/local/bundle/cache/*.gem \\  \u0026\u0026 find /usr/local/bundle/gems/ -name \"*.[co]\" -delete \\  \u0026\u0026 apk del --no-network build-dependencies COPY . . ENTRYPOINT [\"/bin/sh\", \"-c\"] CMD [\"bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT\"] In the Dockerfile, we first set the working directory (WORKDIR) and then install a mix of build and runtime dependencies. Next, we copy the Gemfile and Gemfile.lock files to download and compile the bundle in the next step. But before we run bundle, we install some build tooling so Docker can build and install the gems.\nLastly, we COPY all project files to the image and run the Rails server using the rails s command. We COPY all files because we want all the project files to be inside the container to run. If we fail to copy a required file, the application will fail to boot, rendering our Docker image useless.\nTo run this container, we first need to build its image:\n$ docker build -t jarjar:latest . [+] Building 14.9s (11/11) FINISHED = [internal] load build definition from Dockerfile 0.0s = = transferring dockerfile: 622B 0.0s = [internal] load .dockerignore 0.0s = = transferring context: 2B 0.0s = [internal] load metadata for docker.io/library/ruby:3.0.2-alpine3.14 0.6s = [1/6] FROM docker.io/library/ruby:3.0.2-alpine3.14@sha256:5bb06d7e3853903b9e9480b647b2d99ca289f9511 0.0s = [internal] load build context 0.0s = = transferring context: 18.47kB 0.0s = CACHED [2/6] WORKDIR /app 0.0s = CACHED [3/6] RUN apk add --no-cache shared-mime-info tzdata sqlite-libs 0.0s = CACHED [4/6] COPY Gemfile* /app 0.0s = [5/6] RUN apk add --no-cache --virtual build-dependencies build-base sqlite-dev \u0026\u0026 bundle in 13.6s = [6/6] COPY . . 0.0s = exporting to image 0.5s = = exporting layers 0.5s = = writing image sha256:c24befc2a0ce11f5550672e4f7aa64a5f6d8169609d173c35d039bf459bce757 0.0s = = naming to docker.io/library/jarjar:latest 0.0s After the image is built, we can create a container:\n$ docker run --env SERVER_PORT=3000 -p 3000:3000 jarjar:latest = Booting Puma = Rails 6.1.4.1 application starting in development = Run `bin/rails server --help` for more startup options Puma starting in single mode... * Puma version: 5.5.2 (ruby 3.0.2-p107) (\"Zawgyi\") * Min threads: 5 * Max threads: 5 * Environment: development * PID: 1 * Listening on http://0.0.0.0:3000 Use Ctrl-C to stop Voilá! Our container is off to the races!\nBecause we map the container port 3000 to the host machine’s port 3000, we can curl the Rails application from our host machine. Fortunately, we will get an HTTP 200:\n$ curl -X GET -I localhost:3000 HTTP/1.1 200 OK X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Content-Type-Options: nosniff X-Download-Options: noopen X-Permitted-Cross-Domain-Policies: none Referrer-Policy: strict-origin-when-cross-origin Content-Type: text/html; charset=utf-8 Vary: Accept Cache-Control: no-store, must-revalidate, private, max-age=0 Content-Security-Policy: script-src 'unsafe-inline'; style-src 'unsafe-inline' X-Request-Id: a4befe81-30be-4859-b757-feac45f90b08 X-Runtime: 0.312531 X-MiniProfiler-Original-Cache-Control: max-age=0, private, must-revalidate X-MiniProfiler-Ids: 8hq1e1quzqh4uacc9xb8 Set-Cookie: __profilin=p%3Dt; path=/; HttpOnly; SameSite=Lax Content-Length: 400499 Now, instead of running our application with the complicated docker run command, let’s throw in a Docker Compose file and make our lifes easier:\nversion: '3.8' services: http: build: . image: jarjar environment: SERVER_PORT: ${SERVER_PORT} ports: - ${SERVER_PORT}:${SERVER_PORT} # Set to 4000 in .env file volumes: - .:/app The file sets up the required environment variables, ports and volumes for the Rails application. To build our image now, we can use docker-compose build:\n$ docker-compose build Building http [+] Building 0.7s (11/11) FINISHED = [internal] load build definition from Dockerfile 0.0s = = transferring dockerfile: 622B 0.0s = [internal] load .dockerignore 0.0s = = transferring context: 2B 0.0s = [internal] load metadata for docker.io/library/ruby:3.0.2-alpine3.14 0.6s = [1/6] FROM docker.io/library/ruby:3.0.2-alpine3.14@sha256:5bb06d7e3853903b9e9480b647b2d99ca289f9511 0.0s = [internal] load build context 0.0s = = transferring context: 32.32kB 0.0s = CACHED [2/6] WORKDIR /app 0.0s = CACHED [3/6] RUN apk add --no-cache shared-mime-info tzdata sqlite-libs 0.0s = CACHED [4/6] COPY Gemfile* /app 0.0s = CACHED [5/6] RUN apk add --no-cache --virtual build-dependencies build-base sqlite-dev \u0026\u0026 bun 0.0s = CACHED [6/6] COPY . . 0.0s = exporting to image 0.0s = = exporting layers 0.0s = = writing image sha256:c24befc2a0ce11f5550672e4f7aa64a5f6d8169609d173c35d039bf459bce757 0.0s = = naming to docker.io/library/jarjar 0.0s Now that we have the image built, we can run the service:\n$ docker-compose up Starting jarjar_http_1 ... done Attaching to jarjar_http_1 http_1 | = Booting Puma http_1 | = Rails 6.1.4.1 application starting in development http_1 | = Run `bin/rails server --help` for more startup options http_1 | Puma starting in single mode... http_1 | * Puma version: 5.5.2 (ruby 3.0.2-p107) (\"Zawgyi\") http_1 | * Min threads: 5 http_1 | * Max threads: 5 http_1 | * Environment: development http_1 | * PID: 1 http_1 | * Listening on http://0.0.0.0:4000 http_1 | Use Ctrl-C to stop We have our service running using Docker Compose! Let’s curl it, again:\n$ curl -X GET -I localhost:4000 HTTP/1.1 200 OK X-Frame-Options: SAMEORIGIN X-XSS-Protection: 1; mode=block X-Content-Type-Options: nosniff X-Download-Options: noopen X-Permitted-Cross-Domain-Policies: none Referrer-Policy: strict-origin-when-cross-origin Content-Type: text/html; charset=utf-8 Vary: Accept Cache-Control: no-store, must-revalidate, private, max-age=0 Content-Security-Policy: script-src 'unsafe-inline'; style-src 'unsafe-inline' X-Request-Id: d7a72b16-9630-4e4c-9e9e-8781c8207b52 X-Runtime: 0.020082 X-MiniProfiler-Original-Cache-Control: max-age=0, private, must-revalidate X-MiniProfiler-Ids: dvwfody0av0h45hub5bw,pp70s0op22fdolh4u8zt,hdpxqj8kohhs6r3jf7xp,c080m80j1zfarr0b4qxw Set-Cookie: __profilin=p%3Dt; path=/; HttpOnly; SameSite=Lax Content-Length: 400562 We get an HTTP 200. If we bring down the container and up again, we’ll run into a familiar problem:\n$ docker-compose up Starting jarjar_http_1 ... done [...] http_1 | = Booting Puma http_1 | = Rails 6.1.4.1 application starting in development http_1 | = Run `bin/rails server --help` for more startup options http_1 | Exiting http_1 | A server is already running. Check /app/tmp/pids/server.pid. jarjar_http_1 exited with code 1 Apparently we have a stray PID file, and our server can’t boot.\nStray PID files The default web server for Rails, Puma, creates a PID file. A PID, shorthand for Process ID, is a file that contains only the ID of the server process on the operating system. So, if we boot our server container, we attach to it and open the PID file; we will see that the file contains only the PID number in it:\n/app # cat tmp/pids/server.pid 1 Before I got to this section, I had no idea why PID files were useful. However, after consulting an excellent StackOverflow answer (that I recommend reading thoroughly), it appears that we can use PID files for:\n as a signal to other processes and users of the system that that particular program is running, or at least started successfully allows one to write a script to check if a particular process is running and issue a plain kill command (e.g., if one wants to end it) it is a cheap way for a program to see if any of its previous instances did not exit successfully  That last point hits close to home - Puma’s PID file is still present before the container shuts down, and, when booting, Rails thinks there’s already another server running.\nOne thing that threw me off with the stray PID file is that containers and their file systems are supposed to be ephemeral. Once you stop them – they’re gone for good. What I found out is that Docker Compose reuses containers whose configurations have not changed:\n Compose caches the configuration used to create a container. When you restart a service that has not changed, Compose re-uses the existing containers. Re-using containers means that you can make changes to your environment very quickly.\n This is a neat feature of Compose, but it means that Compose does not destroy the container that contains the stray PID file. Actually, Compose reuses it. And it’s the reason why the lost PID file is detected, and Puma cannot start when using Docker Compose.\nThere are several ways to force Docker Compose to recreate the containers, but from a workflow perspective, we want docker-compose up to just do the trick. There’s always docker-compose up --force-recreate, but from a developer experience perspective, that seems… hacky.\nIf container reuse is a feature of Docker Compose, then the solution to our stray PID files must lie with Puma. In other words, how can we make Puma clean up its mess before exiting?\nCleaning up the mess For Puma to clean up its PID file, it has to receive the proper interrupt signal (SIGINT) when we press Ctrl-C so it can act upon it. But when we press Ctrl-C, even though we think we are interrupting Puma, we are not.\nInspect this output, carefully:\n$ docker-compose up Recreating jarjar_http_1 ... done Attaching to jarjar_http_1 http_1 | = Booting Puma http_1 | = Rails 6.1.4.1 application starting in development http_1 | = Run `bin/rails server --help` for more startup options http_1 | Puma starting in single mode... http_1 | * Puma version: 5.5.2 (ruby 3.0.2-p107) (\"Zawgyi\") http_1 | * Min threads: 5 http_1 | * Max threads: 5 http_1 | * Environment: development http_1 | * PID: 1 http_1 | * Listening on http://0.0.0.0:4000 http_1 | Use Ctrl-C to stop From STDOUT we see Puma saying Use Ctrl-C to stop, but when we press Ctrl-C we interrupt Docker Compose (its up command), not Puma. This is because upon pressing Ctrl-C we rely on Docker Compose to send that same SIGINT to the Puma process, but that is not how Compose works.\nThe fact that Docker Compose does not “bubble up” the SIGINT to Puma means that the Puma process is abruptly killed by the container shutting down, and Puma can’t clean up its PID file.\nSo, how can we make sure we remove the PID file?\nAttempt no. 1: Remove PID before Puma boot The most straightforward way is to remove the PID file before we kick-off the Puma server. It can be done by modifying the CMD of the Dockerfile:\nCMD [\"rm -f tmp/pids/server.pid \u0026\u0026 bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT\"] The Internet is riddled with variations of this approach. From Reddit threads, to many different Stack Overflow answers, “just remove the PID file” seems to be the default workaround for this problem.\nBefore I comment on this approach, let’s look at a similar but better approach.\nAttempt no. 2: Use an entrypoint script This solution is suggested by Docker Compose’s documentation on Rails \u0026 Postgres:\n …provide an entrypoint script to fix a Rails-specific issue that prevents the server from restarting when a certain server.pid file pre-exists. This script will be executed every time the container gets started.\n The entrypoint.sh script, as taken from the documentation:\n#!/bin/bash  # Stops the execution of a script in case of error set -e # Remove a potentially pre-existing server.pid for Rails. rm -f /myapp/tmp/pids/server.pid # Then exec the container's main process (what's set as CMD in the Dockerfile). exec \"$@\" This script will work in unison with the Dockerfile, which will have to make the script executable and run it as an ENTRYPOINT:\n[...] # Add a script to be executed every time the container starts. COPY entrypoint.sh /usr/bin/ RUN chmod +x /usr/bin/entrypoint.sh ENTRYPOINT [\"entrypoint.sh\"] CMD [\"bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT\"] While the above solutions work and the second is even officially recommended by Compose, I do not like them for three reasons:\n Any code we write, such as the script, will need to be checked in source control and maintained The solution pollutes the Dockerfile due to a shortcoming of docker-compose up The solution adds accidental complexity in the Dockerfile for any non-local environment (e.g. cloud). In other words, if we deploy our application to a cloud provider, we wouldn’t use Docker Compose, but we will still end up carrying the entrypoint script to the cloud.  For the above reasons, let’s take a step deeper and see if there’s a better/more self-contained solution.\nOverriding Puma’s PID file When deploying your application to the cloud, it is critical to keep the Dockerfile minimal, containing only the absolute essentials. If you have seen bloated Dockerfiles, or even worse, a proliferation of Dockerfiles in a project, you know what I am talking about.\nTo keep the Dockerfile minimal, we must make tradeoffs: any potential local setup complexity will end up in the docker-compose.yml file.\nPuma allows us to set the PID file path from the command line using the -p toggle. Unfortunately, this will add complexity to our Dockerfile:\nCMD [\"bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT -P /some/path/server.pid\"] This is a no-go, as we want to stick to the defaults in any other (cloud) environment. The good news is that since 2019, Rails has supported setting the PID file path using an environment variable, allowing us to set the PIDFILE environment variable, and Rails will use it transparently.\nOK, now that we have a way to transparently set the PID file path, what should its value be? Unix operating systems have one place where all bits go to die: /dev/null.\nAttempt no. 3: Send the PID file to /dev/null This is easily achieved by adding a single line in the docker-compose.yml:\nversion: '3.8' services: http: build: . image: jarjar environment: SERVER_PORT: ${SERVER_PORT} + PIDFILE: /dev/null  ports: - ${SERVER_PORT}:${SERVER_PORT} volumes: - .:/app It will work as expected if we test this out: docker-compose up can be ran and interrupted (using Ctrl-C) without problems.\nBut, by setting the PID file path to /dev/null we lose all valuable aspects of PID files: we can’t check whether a process is running or whether a previous instance has failed.\nCan we do better? Could we place the PID file in an ephemeral location that would be present for the duration of the container life, but it would evaporate after Compose takes the container down?\nSolution: Use tmpfs Docker ships with tmpfs mounts as a storage option that works only on containers running Linux. When we create a container with a tmpfs mount, the container can create files outside the container’s writable layer.\nAs opposed to volumes and bind mounts, a tmpfs mount is temporary and persists in the host memory. So when the container stops, the tmpfs mount is removed, and all files in it will be gone. tmpfs mounts seem like the perfect ephemeral storage for our problem.\nTo add a tmpfs path in our Compose file and to store the PID file in that path, we need to make the following changes:\nversion: '3.8' services: http: build: . image: jarjar environment: SERVER_PORT: ${SERVER_PORT} - PIDFILE: /dev/null + PIDFILE: /tmp/pids/server.pid  ports: - ${SERVER_PORT}:${SERVER_PORT} volumes: - .:/app + tmpfs: + - /tmp/pids/ Docker Compose will create a path and mount it in the host’s memory when we run docker-compose up. This will allow us to set the PID file in that ephemeral path, /tmp/pids in our example, and use the PID file during the duration of the container. When the container is torn down, we lose the temporary mount in the void with all PID files in it.\nLet’s give this a shot and see if we can run docker-compose up and interrupt it ad infinitum.\nFirst run:\n$ docker-compose up Creating jarjar_http_1 ... done [...] http_1 | = Booting Puma http_1 | = Rails 6.1.4.1 application starting in development http_1 | = Run `bin/rails server --help` for more startup options http_1 | Puma starting in single mode... http_1 | * Puma version: 5.5.2 (ruby 3.0.2-p107) (\"Zawgyi\") http_1 | * Min threads: 5 http_1 | * Max threads: 5 http_1 | * Environment: development http_1 | * PID: 1 http_1 | * Listening on http://0.0.0.0:4000 http_1 | Use Ctrl-C to stop ^CGracefully stopping... (press Ctrl+C again to force) Killing jarjar_http_1 ... done Looking good! Next run:\n$ docker-compose up Starting jarjar_http_1 ... done [...] http_1 | = Booting Puma http_1 | = Rails 6.1.4.1 application starting in development http_1 | = Run `bin/rails server --help` for more startup options http_1 | Puma starting in single mode... http_1 | * Puma version: 5.5.2 (ruby 3.0.2-p107) (\"Zawgyi\") http_1 | * Min threads: 5 http_1 | * Max threads: 5 http_1 | * Environment: development http_1 | * PID: 1 http_1 | * Listening on http://0.0.0.0:4000 http_1 | Use Ctrl-C to stop Works as advertised!\nUsing a tmpfs mount, we can leave our Dockerfile unscathed without additional entrypoints scripts or dependencies. Instead, we are using a native Docker solution that has been around for a while, with just two extra lines in our Docker Compose file.\nAnd maybe the best part is that our solution is stack agnostic. It will work with any process that creates a PID file, whether a web server (such as Puma) or another program. The tmpfs approach requires only the program to set a custom path for the PID file – that’s all!\n","wordCount":"3096","inLanguage":"en","datePublished":"2021-10-27T12:32:51+01:00","dateModified":"2021-10-27T12:32:51+01:00","author":{"@type":"Person","name":"Ilija Eftimov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/docker-compose-stray-pids-rails-beyond/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Docker Compose, stray PID files, Rails and beyond</h1><div class=post-meta>October 27, 2021&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Ilija Eftimov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#docker-compose--local-development-- aria-label="Docker Compose + local development = ❤️">Docker Compose + local development = ❤️</a></li><li><a href=#dockerizing-the-app aria-label="Dockerizing the app">Dockerizing the app</a></li><li><a href=#stray-pid-files aria-label="Stray PID files">Stray PID files</a></li><li><a href=#cleaning-up-the-mess aria-label="Cleaning up the mess">Cleaning up the mess</a><ul><li><a href=#attempt-no-1-remove-pid-before-puma-boot aria-label="Attempt no. 1: Remove PID before Puma boot">Attempt no. 1: Remove PID before Puma boot</a></li><li><a href=#attempt-no-2-use-an-entrypoint-script aria-label="Attempt no. 2: Use an entrypoint script">Attempt no. 2: Use an entrypoint script</a></li></ul></li><li><a href=#overriding-pumas-pid-file aria-label="Overriding Puma&amp;rsquo;s PID file">Overriding Puma&rsquo;s PID file</a><ul><li><a href=#attempt-no-3-send-the-pid-file-to-devnull aria-label="Attempt no. 3: Send the PID file to /dev/null">Attempt no. 3: Send the PID file to <code>/dev/null</code></a></li></ul></li><li><a href=#solution-use-tmpfs aria-label="Solution: Use tmpfs">Solution: Use <code>tmpfs</code></a></li></ul></div></details></div><div class=post-content><h2 id=docker-compose--local-development-->Docker Compose + local development = ❤️<a hidden class=anchor aria-hidden=true href=#docker-compose--local-development-->#</a></h2><p>If you’re like me, you like a simple Docker Compose setup for your local
project setup. It makes bringing up and tearing down different Docker
containers easy with a single command. Especially if your application requires
additional backing services, like a data store, a Docker Compose setup for
local development makes it very easy to spin them all up in one go.</p><p>Another reason why I like Docker Compose because I am a bit of a purist when it
comes to Dockerfiles – I believe that there should be only one Dockerfile for
your service, and it should work for all environments. Nope, none of the
<code>Dockerfile.dev</code> & <code>Dockerfile.prod</code> shenanigans. Why? Because I want my
services to require only one set of dependencies, regardless of the deployment
environment.</p><p>Following that idea, Docker Compose uses the project&rsquo;s Dockerfile and
orchestrates all backing services via a simple YAML file. And the cherry on
top: I can check-in <code>docker-compose.yml</code> version control, and everyone in my
organization can reap the benefits.</p><p>OK, OK, you know I like Docker Compose for local development. But, sometimes,
it can be not very pleasant. For example, it doesn’t want to start a process or
a server in a container because it never cleaned up its PID file.</p><p>When running <code>docker-compose up</code>, you might have seen one of these error
messages (or a variation):</p><pre><code>httpd (pid 1) already running
</code></pre><pre><code>ERROR: Pidfile (celerybeat.pid) already exists.
</code></pre><pre><code>A server is already running. Check /usr/src/app/tmp/pids/server.pid.
</code></pre><p>Seems familiar? Let&rsquo;s work with a Rails application to reproduce the issue and
fix it in four different ways.</p><div class="notice tip"><p class="first notice-title"></p><p>While this article uses a Rails application as an example to showcase the issue
with stray PID files when using Docker Compose, the solution provided below is
language- and framework-agnostic.</p><p>In other words, one can use the approaches showcased below with any programming
language or framework, as long as the application is containerized.</p></div><h2 id=dockerizing-the-app>Dockerizing the app<a hidden class=anchor aria-hidden=true href=#dockerizing-the-app>#</a></h2><p>Let&rsquo;s look at the <code>Dockerfile</code> of a simple Rails application, that uses no
backing services. The <code>Dockerfile</code> will use the <code>ruby:3.0.2-alpine3.14</code> image
as base:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#719e07>FROM</span><span style=color:#2aa198> ruby:3.0.2-alpine3.14</span>

<span style=color:#719e07>WORKDIR</span><span style=color:#2aa198> /app</span>

<span style=color:#586e75># Install runtime dependencies</span>
<span style=color:#719e07>RUN</span> apk add --no-cache <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  shared-mime-info <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  tzdata <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  sqlite-libs

<span style=color:#586e75># Install the project dependencies</span>
<span style=color:#719e07>COPY</span> Gemfile* /app

<span style=color:#586e75># Bundle build dependencies</span>
<span style=color:#719e07>RUN</span> apk add --no-cache --virtual build-dependencies <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  build-base <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  sqlite-dev <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> bundle install <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> rm -rf /usr/local/bundle/cache/*.gem <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> find /usr/local/bundle/gems/ -name <span style=color:#2aa198>&#34;*.[co]&#34;</span> -delete <span style=color:#cb4b16>\
</span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> apk del --no-network build-dependencies

<span style=color:#719e07>COPY</span> . .

<span style=color:#719e07>ENTRYPOINT</span> [<span style=color:#2aa198>&#34;/bin/sh&#34;</span>, <span style=color:#2aa198>&#34;-c&#34;</span>]

<span style=color:#719e07>CMD</span> [<span style=color:#2aa198>&#34;bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT&#34;</span>]
</code></pre></div><p>In the <code>Dockerfile</code>, we first set the working directory (<code>WORKDIR</code>) and then
install a mix of build and runtime dependencies. Next, we copy the <code>Gemfile</code>
and <code>Gemfile.lock</code> files to download and compile the bundle in the next step.
But before we run <code>bundle</code>, we install some build tooling so Docker can build
and install the gems.</p><p>Lastly, we <code>COPY</code> all project files to the image and run the Rails server using
the <code>rails s</code> command. We <code>COPY</code> all files because we want all the project
files to be inside the container to run. If we fail to copy a required file,
the application will fail to boot, rendering our Docker image useless.</p><p>To run this container, we first need to build its image:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker build -t jarjar:latest .
<span style=color:#719e07>[</span>+<span style=color:#719e07>]</span> Building 14.9s <span style=color:#719e07>(</span>11/11<span style=color:#719e07>)</span> <span style=color:#268bd2>FINISHED</span>
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load build definition from Dockerfile                                                     0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; transferring dockerfile: 622B                                                                     0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load .dockerignore                                                                        0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; transferring context: 2B                                                                          0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load metadata <span style=color:#719e07>for</span> docker.io/library/ruby:3.0.2-alpine3.14                                 0.6s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>1/6<span style=color:#719e07>]</span> FROM docker.io/library/ruby:3.0.2-alpine3.14@sha256:5bb06d7e3853903b9e9480b647b2d99ca289f9511  0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load build context                                                                        0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; transferring context: 18.47kB                                                                     0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>2/6<span style=color:#719e07>]</span> WORKDIR /app                                                                            0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>3/6<span style=color:#719e07>]</span> RUN apk add --no-cache   shared-mime-info   tzdata   sqlite-libs                        0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>4/6<span style=color:#719e07>]</span> COPY Gemfile* /app                                                                      0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>5/6<span style=color:#719e07>]</span> RUN apk add --no-cache --virtual build-dependencies   build-base   sqlite-dev   <span style=color:#719e07>&amp;&amp;</span> bundle in  13.6s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>6/6<span style=color:#719e07>]</span> COPY . .                                                                                       0.0s
 <span style=color:#719e07>=</span>&gt; exporting to image                                                                                   0.5s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; exporting layers                                                                                  0.5s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; writing image sha256:c24befc2a0ce11f5550672e4f7aa64a5f6d8169609d173c35d039bf459bce757             0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; naming to docker.io/library/jarjar:latest                                                         0.0s
</code></pre></div><p>After the image is built, we can create a container:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker run --env <span style=color:#268bd2>SERVER_PORT</span><span style=color:#719e07>=</span><span style=color:#2aa198>3000</span> -p 3000:3000 jarjar:latest
<span style=color:#719e07>=</span>&gt; Booting <span style=color:#268bd2>Puma</span>
<span style=color:#719e07>=</span>&gt; Rails 6.1.4.1 application starting in <span style=color:#268bd2>development</span>
<span style=color:#719e07>=</span>&gt; Run <span style=color:#586e75>`</span>bin/rails server --help<span style=color:#586e75>`</span> <span style=color:#719e07>for</span> more startup options
Puma starting in single mode...
* Puma version: 5.5.2 <span style=color:#719e07>(</span>ruby 3.0.2-p107<span style=color:#719e07>)</span> <span style=color:#719e07>(</span><span style=color:#2aa198>&#34;Zawgyi&#34;</span><span style=color:#719e07>)</span>
*  Min threads: <span style=color:#2aa198>5</span>
*  Max threads: <span style=color:#2aa198>5</span>
*  Environment: development
*          PID: <span style=color:#2aa198>1</span>
* Listening on http://0.0.0.0:3000
Use Ctrl-C to stop
</code></pre></div><p>Voilá! Our container is off to the races!</p><p>Because we map the container port 3000 to the host machine&rsquo;s port 3000, we can
<code>curl</code> the Rails application from our host machine. Fortunately, we will get
an HTTP 200:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl -X GET -I localhost:3000
HTTP/1.1 <span style=color:#2aa198>200</span> OK
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; <span style=color:#268bd2>mode</span><span style=color:#719e07>=</span>block
X-Content-Type-Options: nosniff
X-Download-Options: noopen
X-Permitted-Cross-Domain-Policies: none
Referrer-Policy: strict-origin-when-cross-origin
Content-Type: text/html; <span style=color:#268bd2>charset</span><span style=color:#719e07>=</span>utf-8
Vary: Accept
Cache-Control: no-store, must-revalidate, private, max-age<span style=color:#719e07>=</span><span style=color:#2aa198>0</span>
Content-Security-Policy: script-src <span style=color:#2aa198>&#39;unsafe-inline&#39;</span>; style-src <span style=color:#2aa198>&#39;unsafe-inline&#39;</span>
X-Request-Id: a4befe81-30be-4859-b757-feac45f90b08
X-Runtime: 0.312531
X-MiniProfiler-Original-Cache-Control: max-age<span style=color:#719e07>=</span>0, private, must-revalidate
X-MiniProfiler-Ids: 8hq1e1quzqh4uacc9xb8
Set-Cookie: <span style=color:#268bd2>__profilin</span><span style=color:#719e07>=</span>p%3Dt; <span style=color:#268bd2>path</span><span style=color:#719e07>=</span>/; HttpOnly; <span style=color:#268bd2>SameSite</span><span style=color:#719e07>=</span>Lax
Content-Length: <span style=color:#2aa198>400499</span>
</code></pre></div><p>Now, instead of running our application with the complicated <code>docker run</code> command,
let&rsquo;s throw in a Docker Compose file and make our lifes easier:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#268bd2>version</span>: <span style=color:#2aa198>&#39;3.8&#39;</span>

<span style=color:#268bd2>services</span>:
  <span style=color:#268bd2>http</span>:
    <span style=color:#268bd2>build</span>: .
    <span style=color:#268bd2>image</span>: jarjar
    <span style=color:#268bd2>environment</span>:
      <span style=color:#268bd2>SERVER_PORT</span>: ${SERVER_PORT}
    <span style=color:#268bd2>ports</span>:
      - ${SERVER_PORT}:${SERVER_PORT}  <span style=color:#586e75># Set to 4000 in .env file</span>
    <span style=color:#268bd2>volumes</span>:
      - .:/app
</code></pre></div><p>The file sets up the required environment variables, ports and volumes for the
Rails application. To build our image now, we can use <code>docker-compose build</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker-compose build
Building http
<span style=color:#719e07>[</span>+<span style=color:#719e07>]</span> Building 0.7s <span style=color:#719e07>(</span>11/11<span style=color:#719e07>)</span> <span style=color:#268bd2>FINISHED</span>
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load build definition from Dockerfile                                                     0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; transferring dockerfile: 622B                                                                     0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load .dockerignore                                                                        0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; transferring context: 2B                                                                          0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load metadata <span style=color:#719e07>for</span> docker.io/library/ruby:3.0.2-alpine3.14                                 0.6s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>1/6<span style=color:#719e07>]</span> FROM docker.io/library/ruby:3.0.2-alpine3.14@sha256:5bb06d7e3853903b9e9480b647b2d99ca289f9511  0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>internal<span style=color:#719e07>]</span> load build context                                                                        0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; transferring context: 32.32kB                                                                     0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>2/6<span style=color:#719e07>]</span> WORKDIR /app                                                                            0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>3/6<span style=color:#719e07>]</span> RUN apk add --no-cache   shared-mime-info   tzdata   sqlite-libs                        0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>4/6<span style=color:#719e07>]</span> COPY Gemfile* /app                                                                      0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>5/6<span style=color:#719e07>]</span> RUN apk add --no-cache --virtual build-dependencies   build-base   sqlite-dev   <span style=color:#719e07>&amp;&amp;</span> bun  0.0s
 <span style=color:#719e07>=</span>&gt; CACHED <span style=color:#719e07>[</span>6/6<span style=color:#719e07>]</span> COPY . .                                                                                0.0s
 <span style=color:#719e07>=</span>&gt; exporting to image                                                                                   0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; exporting layers                                                                                  0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; writing image sha256:c24befc2a0ce11f5550672e4f7aa64a5f6d8169609d173c35d039bf459bce757             0.0s
 <span style=color:#719e07>=</span>&gt; <span style=color:#719e07>=</span>&gt; naming to docker.io/library/jarjar                                                                0.0s
</code></pre></div><p>Now that we have the image built, we can run the service:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker-compose up
Starting jarjar_http_1 ... <span style=color:#719e07>done</span>
Attaching to jarjar_http_1
http_1  | <span style=color:#719e07>=</span>&gt; Booting Puma
http_1  | <span style=color:#719e07>=</span>&gt; Rails 6.1.4.1 application starting in development
http_1  | <span style=color:#719e07>=</span>&gt; Run <span style=color:#586e75>`</span>bin/rails server --help<span style=color:#586e75>`</span> <span style=color:#719e07>for</span> more startup options
http_1  | Puma starting in single mode...
http_1  | * Puma version: 5.5.2 <span style=color:#719e07>(</span>ruby 3.0.2-p107<span style=color:#719e07>)</span> <span style=color:#719e07>(</span><span style=color:#2aa198>&#34;Zawgyi&#34;</span><span style=color:#719e07>)</span>
http_1  | *  Min threads: <span style=color:#2aa198>5</span>
http_1  | *  Max threads: <span style=color:#2aa198>5</span>
http_1  | *  Environment: development
http_1  | *          PID: <span style=color:#2aa198>1</span>
http_1  | * Listening on http://0.0.0.0:4000
http_1  | Use Ctrl-C to stop
</code></pre></div><p>We have our service running using Docker Compose! Let&rsquo;s <code>curl</code> it, again:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl -X GET -I localhost:4000
HTTP/1.1 <span style=color:#2aa198>200</span> OK
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; <span style=color:#268bd2>mode</span><span style=color:#719e07>=</span>block
X-Content-Type-Options: nosniff
X-Download-Options: noopen
X-Permitted-Cross-Domain-Policies: none
Referrer-Policy: strict-origin-when-cross-origin
Content-Type: text/html; <span style=color:#268bd2>charset</span><span style=color:#719e07>=</span>utf-8
Vary: Accept
Cache-Control: no-store, must-revalidate, private, max-age<span style=color:#719e07>=</span><span style=color:#2aa198>0</span>
Content-Security-Policy: script-src <span style=color:#2aa198>&#39;unsafe-inline&#39;</span>; style-src <span style=color:#2aa198>&#39;unsafe-inline&#39;</span>
X-Request-Id: d7a72b16-9630-4e4c-9e9e-8781c8207b52
X-Runtime: 0.020082
X-MiniProfiler-Original-Cache-Control: max-age<span style=color:#719e07>=</span>0, private, must-revalidate
X-MiniProfiler-Ids: dvwfody0av0h45hub5bw,pp70s0op22fdolh4u8zt,hdpxqj8kohhs6r3jf7xp,c080m80j1zfarr0b4qxw
Set-Cookie: <span style=color:#268bd2>__profilin</span><span style=color:#719e07>=</span>p%3Dt; <span style=color:#268bd2>path</span><span style=color:#719e07>=</span>/; HttpOnly; <span style=color:#268bd2>SameSite</span><span style=color:#719e07>=</span>Lax
Content-Length: <span style=color:#2aa198>400562</span>
</code></pre></div><p>We get an HTTP 200. If we bring down the container and up again, we&rsquo;ll run
into a familiar problem:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker-compose up
Starting jarjar_http_1     ... <span style=color:#719e07>done</span>
<span style=color:#719e07>[</span>...<span style=color:#719e07>]</span>
http_1      | <span style=color:#719e07>=</span>&gt; Booting Puma
http_1      | <span style=color:#719e07>=</span>&gt; Rails 6.1.4.1 application starting in development
http_1      | <span style=color:#719e07>=</span>&gt; Run <span style=color:#586e75>`</span>bin/rails server --help<span style=color:#586e75>`</span> <span style=color:#719e07>for</span> more startup options
http_1      | Exiting
http_1      | A server is already running. Check /app/tmp/pids/server.pid.
jarjar_http_1 exited with code <span style=color:#2aa198>1</span>
</code></pre></div><p>Apparently we have a stray PID file, and our server can&rsquo;t boot.</p><h2 id=stray-pid-files>Stray PID files<a hidden class=anchor aria-hidden=true href=#stray-pid-files>#</a></h2><p>The default web server for Rails, Puma, creates a PID file. A PID, shorthand
for Process ID, is a file that contains only the ID of the server process on
the operating system. So, if we boot our server container, we attach to it and
open the PID file; we will see that the file contains only the PID number in
it:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>/app <span style=color:#586e75># cat tmp/pids/server.pid</span>
<span style=color:#2aa198>1</span>
</code></pre></div><p>Before I got to this section, I had no idea why PID files were useful. However,
after consulting an excellent <a href=https://unix.stackexchange.com/a/12818/410360>StackOverflow
answer</a> (that I recommend
reading thoroughly), it appears that we can use PID files for:</p><ul><li>as a signal to other processes and users of the system that that particular
program is running, or at least started successfully</li><li>allows one to write a script to check if a particular process is running and
issue a plain kill command (e.g., if one wants to end it)</li><li>it is a cheap way for a program to see if any of its previous instances did
not exit successfully</li></ul><p>That last point hits close to home - Puma’s PID file is still present before
the container shuts down, and, when booting, Rails thinks there’s already
another server running.</p><p>One thing that threw me off with the stray PID file is that containers and
their file systems are supposed to be ephemeral. Once you stop them – they&rsquo;re
gone for good. What I found out is that Docker Compose <a href=https://docs.docker.com/compose/#only-recreate-containers-that-have-changed>reuses containers whose
configurations have not
changed</a>:</p><blockquote><p>Compose caches the configuration used to create a container. When you restart
a service that has not changed, Compose re-uses the existing containers.
Re-using containers means that you can make changes to your environment very
quickly.</p></blockquote><p>This is a neat feature of Compose, but it means that Compose does not destroy
the container that contains the stray PID file. Actually, Compose reuses it.
And it’s the reason why the lost PID file is detected, and Puma cannot start
when using Docker Compose.</p><p>There are several ways to force Docker Compose to recreate the containers, but
from a workflow perspective, we want <code>docker-compose up</code> to <em>just</em> do the
trick. There&rsquo;s always <code>docker-compose up --force-recreate</code>, but from a
developer experience perspective, that seems&mldr; hacky.</p><p>If container reuse is a feature of Docker Compose, then the solution to our
stray PID files must lie with Puma. In other words, how can we make Puma
clean up its mess before exiting?</p><h2 id=cleaning-up-the-mess>Cleaning up the mess<a hidden class=anchor aria-hidden=true href=#cleaning-up-the-mess>#</a></h2><p>For Puma to clean up its PID file, it has to receive the proper interrupt
signal (SIGINT) when we press Ctrl-C so it can act upon it. But when we press
Ctrl-C, even though we think we are interrupting Puma, we are not.</p><p>Inspect this output, carefully:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker-compose up
Recreating jarjar_http_1 ... <span style=color:#719e07>done</span>
Attaching to jarjar_http_1
http_1  | <span style=color:#719e07>=</span>&gt; Booting Puma
http_1  | <span style=color:#719e07>=</span>&gt; Rails 6.1.4.1 application starting in development
http_1  | <span style=color:#719e07>=</span>&gt; Run <span style=color:#586e75>`</span>bin/rails server --help<span style=color:#586e75>`</span> <span style=color:#719e07>for</span> more startup options
http_1  | Puma starting in single mode...
http_1  | * Puma version: 5.5.2 <span style=color:#719e07>(</span>ruby 3.0.2-p107<span style=color:#719e07>)</span> <span style=color:#719e07>(</span><span style=color:#2aa198>&#34;Zawgyi&#34;</span><span style=color:#719e07>)</span>
http_1  | *  Min threads: <span style=color:#2aa198>5</span>
http_1  | *  Max threads: <span style=color:#2aa198>5</span>
http_1  | *  Environment: development
http_1  | *          PID: <span style=color:#2aa198>1</span>
http_1  | * Listening on http://0.0.0.0:4000
http_1  | Use Ctrl-C to stop
</code></pre></div><p>From STDOUT we see Puma saying <code>Use Ctrl-C to stop</code>, but when we press Ctrl-C
we interrupt Docker Compose (its <code>up</code> command), not Puma. This is because upon
pressing Ctrl-C we rely on Docker Compose to send that same SIGINT to the Puma
process, but that is <a href=https://github.com/docker/compose/issues/7135>not how Compose
works</a>.</p><p>The fact that Docker Compose does not &ldquo;bubble up&rdquo; the SIGINT to Puma means that
the Puma process is abruptly killed by the container shutting down, and Puma
can&rsquo;t clean up its PID file.</p><p>So, how can we make sure we remove the PID file?</p><h3 id=attempt-no-1-remove-pid-before-puma-boot>Attempt no. 1: Remove PID before Puma boot<a hidden class=anchor aria-hidden=true href=#attempt-no-1-remove-pid-before-puma-boot>#</a></h3><p>The most straightforward way is to remove the PID file before we kick-off the
Puma server. It can be done by modifying the <code>CMD</code> of the <code>Dockerfile</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#719e07>CMD</span> [<span style=color:#2aa198>&#34;rm -f tmp/pids/server.pid &amp;&amp; bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT&#34;</span>]
</code></pre></div><p>The Internet is riddled with variations of this approach. From <a href=https://www.reddit.com/r/rails/comments/aphq08/rails_docker_and_tmppidsserverpid/>Reddit
threads</a>,
to <a href=https://stackoverflow.com/a/53289249/601555>many</a>
<a href=https://stackoverflow.com/a/54686566/601555>different</a> <a href=https://stackoverflow.com/a/35023225/601555>Stack
Overflow</a>
<a href=https://stackoverflow.com/a/50828192/601555>answers</a>, &ldquo;just remove the PID
file&rdquo; seems to be the default workaround for this problem.</p><p>Before I comment on this approach, let&rsquo;s look at a similar but better approach.</p><h3 id=attempt-no-2-use-an-entrypoint-script>Attempt no. 2: Use an entrypoint script<a hidden class=anchor aria-hidden=true href=#attempt-no-2-use-an-entrypoint-script>#</a></h3><p>This solution is suggested by <a href=https://docs.docker.com/samples/rails/>Docker Compose&rsquo;s
documentation</a> on Rails & Postgres:</p><blockquote><p>&mldr;provide an entrypoint script to fix a Rails-specific issue that prevents
the server from restarting when a certain <code>server.pid</code> file pre-exists. This
script will be executed every time the container gets started.</p></blockquote><p>The <code>entrypoint.sh</code> script, as taken from the documentation:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#719e07>#!/bin/bash
</span><span style=color:#719e07></span>
<span style=color:#586e75># Stops the execution of a script in case of error</span>
<span style=color:#b58900>set</span> -e

<span style=color:#586e75># Remove a potentially pre-existing server.pid for Rails.</span>
rm -f /myapp/tmp/pids/server.pid

<span style=color:#586e75># Then exec the container&#39;s main process (what&#39;s set as CMD in the Dockerfile).</span>
<span style=color:#b58900>exec</span> <span style=color:#2aa198>&#34;</span><span style=color:#268bd2>$@</span><span style=color:#2aa198>&#34;</span>
</code></pre></div><p>This script will work in unison with the <code>Dockerfile</code>, which will have to
make the script executable and run it as an <code>ENTRYPOINT</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#719e07>[</span>...<span style=color:#719e07>]</span>

<span style=color:#586e75># Add a script to be executed every time the container starts.</span>
<span style=color:#719e07>COPY</span> entrypoint.sh /usr/bin/
<span style=color:#719e07>RUN</span> chmod +x /usr/bin/entrypoint.sh
<span style=color:#719e07>ENTRYPOINT</span> [<span style=color:#2aa198>&#34;entrypoint.sh&#34;</span>]

<span style=color:#719e07>CMD</span> [<span style=color:#2aa198>&#34;bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT&#34;</span>]
</code></pre></div><p>While the above solutions work and the second is even officially recommended
by Compose, I do not like them for three reasons:</p><ol><li>Any code we write, such as the script, will need to be checked in source
control and maintained</li><li>The solution pollutes the Dockerfile due to a shortcoming of <code>docker-compose up</code></li><li>The solution adds <a href=https://www.nutshell.com/blog/accidental-complexity-software-design>accidental
complexity</a>
in the <code>Dockerfile</code> for any non-local environment (e.g. cloud). In other
words, if we deploy our application to a cloud provider, we wouldn&rsquo;t use
Docker Compose, but we will still end up carrying the entrypoint script to
the cloud.</li></ol><p>For the above reasons, let&rsquo;s take a step deeper and see if there&rsquo;s a
better/more self-contained solution.</p><h2 id=overriding-pumas-pid-file>Overriding Puma&rsquo;s PID file<a hidden class=anchor aria-hidden=true href=#overriding-pumas-pid-file>#</a></h2><p>When deploying your application to the cloud, it is critical to keep the
Dockerfile minimal, containing only the absolute essentials. If you have seen
bloated Dockerfiles, or even worse, a proliferation of Dockerfiles in a
project, you know what I am talking about.</p><p>To keep the <code>Dockerfile</code> minimal, we must make tradeoffs: any potential local
setup complexity will end up in the <code>docker-compose.yml</code> file.</p><p>Puma allows us to set the PID file path from the command line using the <code>-p</code>
toggle. Unfortunately, this will add complexity to our Dockerfile:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#719e07>CMD</span> [<span style=color:#2aa198>&#34;bundle exec rails s -b 0.0.0.0 -p $SERVER_PORT -P /some/path/server.pid&#34;</span>]
</code></pre></div><p>This is a no-go, as we want to stick to the defaults in any other (cloud)
environment. The good news is that since 2019, Rails has supported <a href=https://github.com/rails/rails/pull/36486>setting the
PID file path using an environment
variable</a>, allowing us to set the
<code>PIDFILE</code> environment variable, and Rails will use it transparently.</p><p>OK, now that we have a way to transparently set the PID file path, what should
its value be? Unix operating systems have one place where all bits go to die:
<code>/dev/null</code>.</p><h3 id=attempt-no-3-send-the-pid-file-to-devnull>Attempt no. 3: Send the PID file to <code>/dev/null</code><a hidden class=anchor aria-hidden=true href=#attempt-no-3-send-the-pid-file-to-devnull>#</a></h3><p>This is easily achieved by adding a single line in the <code>docker-compose.yml</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff> version: &#39;3.8&#39;

 services:
   http:
     build: .
     image: jarjar
     environment:
       SERVER_PORT: ${SERVER_PORT}
<span style=color:#719e07>+      PIDFILE: /dev/null
</span><span style=color:#719e07></span>     ports:
       - ${SERVER_PORT}:${SERVER_PORT}
     volumes:
       - .:/app
</code></pre></div><p>It will work as expected if we test this out: <code>docker-compose up</code> can be ran
and interrupted (using Ctrl-C) without problems.</p><p>But, by setting the PID file path to <code>/dev/null</code> we lose all valuable aspects
of PID files: we can&rsquo;t check whether a process is running or whether a previous
instance has failed.</p><p>Can we do better? Could we place the PID file in an ephemeral location that
would be present for the duration of the container life, but it would evaporate
after Compose takes the container down?</p><h2 id=solution-use-tmpfs>Solution: Use <code>tmpfs</code><a hidden class=anchor aria-hidden=true href=#solution-use-tmpfs>#</a></h2><p>Docker ships with <a href=https://docs.docker.com/storage/tmpfs/><code>tmpfs</code> mounts</a> as a
storage option that works <strong>only on containers running Linux</strong>. When we create
a container with a <code>tmpfs</code> mount, the container can create files outside the
container’s writable layer.</p><p>As opposed to volumes and bind mounts, a <code>tmpfs</code> mount is temporary and
persists in the host memory. So when the container stops, the <code>tmpfs</code> mount is
removed, and all files in it will be gone. <code>tmpfs</code> mounts seem like the perfect
ephemeral storage for our problem.</p><p>To add a <code>tmpfs</code> path in our Compose file and to store the PID file in that
path, we need to make the following changes:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>version: &#39;3.8&#39;

services:
  http:
    build: .
    image: jarjar
    environment:
      SERVER_PORT: ${SERVER_PORT}
<span style=color:#dc322f>-     PIDFILE: /dev/null
</span><span style=color:#dc322f></span><span style=color:#719e07>+     PIDFILE: /tmp/pids/server.pid
</span><span style=color:#719e07></span>    ports:
      - ${SERVER_PORT}:${SERVER_PORT}
    volumes:
      - .:/app
<span style=color:#719e07>+   tmpfs:
</span><span style=color:#719e07>+     - /tmp/pids/
</span></code></pre></div><p>Docker Compose will create a path and mount it in the host’s memory when we run
<code>docker-compose up</code>. This will allow us to set the PID file in that ephemeral
path, <code>/tmp/pids</code> in our example, and use the PID file during the duration of
the container. When the container is torn down, we lose the temporary mount in
the void with all PID files in it.</p><p>Let&rsquo;s give this a shot and see if we can run <code>docker-compose up</code> and interrupt
it ad infinitum.</p><p>First run:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker-compose up
Creating jarjar_http_1     ... <span style=color:#719e07>done</span>
<span style=color:#719e07>[</span>...<span style=color:#719e07>]</span>
http_1      | <span style=color:#719e07>=</span>&gt; Booting Puma
http_1      | <span style=color:#719e07>=</span>&gt; Rails 6.1.4.1 application starting in development
http_1      | <span style=color:#719e07>=</span>&gt; Run <span style=color:#586e75>`</span>bin/rails server --help<span style=color:#586e75>`</span> <span style=color:#719e07>for</span> more startup options
http_1      | Puma starting in single mode...
http_1      | * Puma version: 5.5.2 <span style=color:#719e07>(</span>ruby 3.0.2-p107<span style=color:#719e07>)</span> <span style=color:#719e07>(</span><span style=color:#2aa198>&#34;Zawgyi&#34;</span><span style=color:#719e07>)</span>
http_1      | *  Min threads: <span style=color:#2aa198>5</span>
http_1      | *  Max threads: <span style=color:#2aa198>5</span>
http_1      | *  Environment: development
http_1      | *          PID: <span style=color:#2aa198>1</span>
http_1      | * Listening on http://0.0.0.0:4000
http_1      | Use Ctrl-C to stop
^CGracefully stopping... <span style=color:#719e07>(</span>press Ctrl+C again to force<span style=color:#719e07>)</span>
Killing jarjar_http_1      ... <span style=color:#719e07>done</span>
</code></pre></div><p>Looking good! Next run:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ docker-compose up
Starting jarjar_http_1     ... <span style=color:#719e07>done</span>
<span style=color:#719e07>[</span>...<span style=color:#719e07>]</span>
http_1      | <span style=color:#719e07>=</span>&gt; Booting Puma
http_1      | <span style=color:#719e07>=</span>&gt; Rails 6.1.4.1 application starting in development
http_1      | <span style=color:#719e07>=</span>&gt; Run <span style=color:#586e75>`</span>bin/rails server --help<span style=color:#586e75>`</span> <span style=color:#719e07>for</span> more startup options
http_1      | Puma starting in single mode...
http_1      | * Puma version: 5.5.2 <span style=color:#719e07>(</span>ruby 3.0.2-p107<span style=color:#719e07>)</span> <span style=color:#719e07>(</span><span style=color:#2aa198>&#34;Zawgyi&#34;</span><span style=color:#719e07>)</span>
http_1      | *  Min threads: <span style=color:#2aa198>5</span>
http_1      | *  Max threads: <span style=color:#2aa198>5</span>
http_1      | *  Environment: development
http_1      | *          PID: <span style=color:#2aa198>1</span>
http_1      | * Listening on http://0.0.0.0:4000
http_1      | Use Ctrl-C to stop
</code></pre></div><p>Works as advertised!</p><p>Using a <code>tmpfs</code> mount, we can leave our <code>Dockerfile</code> unscathed without
additional entrypoints scripts or dependencies. Instead, we are using a native
Docker solution that has been around for a while, with just two extra lines in
our Docker Compose file.</p><p>And maybe the best part is that our solution is stack agnostic. It will work
with any process that creates a PID file, whether a web server (such as Puma)
or another program. The <code>tmpfs</code> approach requires only the program to set a
custom path for the PID file – that&rsquo;s all!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/docker/>docker</a></li><li><a href=https://ieftimov.com/tags/docker-compose/>docker-compose</a></li><li><a href=https://ieftimov.com/tags/pid/>pid</a></li><li><a href=https://ieftimov.com/tags/tmpfs/>tmpfs</a></li></ul><nav class=paginav><a class=next href=https://ieftimov.com/post/conditional-http-get-fastest-requests-need-no-response-body/><span class=title>Next Page »</span><br><span>Conditional HTTP GET: The fastest requests need no response body</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker Compose, stray PID files, Rails and beyond on twitter" href="https://twitter.com/intent/tweet/?text=Docker%20Compose%2c%20stray%20PID%20files%2c%20Rails%20and%20beyond&url=https%3a%2f%2fieftimov.com%2fpost%2fdocker-compose-stray-pids-rails-beyond%2f&hashtags=docker%2cdocker-compose%2cpid%2ctmpfs"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Compose, stray PID files, Rails and beyond on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fdocker-compose-stray-pids-rails-beyond%2f&title=Docker%20Compose%2c%20stray%20PID%20files%2c%20Rails%20and%20beyond&summary=Docker%20Compose%2c%20stray%20PID%20files%2c%20Rails%20and%20beyond&source=https%3a%2f%2fieftimov.com%2fpost%2fdocker-compose-stray-pids-rails-beyond%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Compose, stray PID files, Rails and beyond on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fdocker-compose-stray-pids-rails-beyond%2f&title=Docker%20Compose%2c%20stray%20PID%20files%2c%20Rails%20and%20beyond"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Compose, stray PID files, Rails and beyond on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fdocker-compose-stray-pids-rails-beyond%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Compose, stray PID files, Rails and beyond on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20Compose%2c%20stray%20PID%20files%2c%20Rails%20and%20beyond%20-%20https%3a%2f%2fieftimov.com%2fpost%2fdocker-compose-stray-pids-rails-beyond%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Compose, stray PID files, Rails and beyond on telegram" href="https://telegram.me/share/url?text=Docker%20Compose%2c%20stray%20PID%20files%2c%20Rails%20and%20beyond&url=https%3a%2f%2fieftimov.com%2fpost%2fdocker-compose-stray-pids-rails-beyond%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>