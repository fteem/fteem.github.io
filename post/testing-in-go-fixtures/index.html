<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing in Go: Fixtures | Ilija Eftimov ⚡️</title><meta name=keywords content><meta name=description content="When I was researching the topic of test fixtures, I couldn&rsquo;t find much about their beginnings. My first search was about the name of the person who coined &ldquo;test fixtures&rdquo;. Unfortunately, that was not a fruitful endeavor. The next logical step was to look for the etymology of the phrase &ldquo;test fixtures&rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Judging by the Wiki page, it&rsquo;s clear that Ruby on Rails has heavily popularized test fixtures as a concept."><meta name=author content="Ilija Eftimov"><link rel=canonical href=https://ieftimov.com/post/testing-in-go-fixtures/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Testing in Go: Fixtures"><meta property="og:description" content="When I was researching the topic of test fixtures, I couldn&rsquo;t find much about their beginnings. My first search was about the name of the person who coined &ldquo;test fixtures&rdquo;. Unfortunately, that was not a fruitful endeavor. The next logical step was to look for the etymology of the phrase &ldquo;test fixtures&rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Judging by the Wiki page, it&rsquo;s clear that Ruby on Rails has heavily popularized test fixtures as a concept."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/testing-in-go-fixtures/"><meta property="og:image" content="https://ieftimov.com/cards/testing-in-go-fixtures.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-16T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-16T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/testing-in-go-fixtures.png"><meta name=twitter:title content="Testing in Go: Fixtures"><meta name=twitter:description content="When I was researching the topic of test fixtures, I couldn&rsquo;t find much about their beginnings. My first search was about the name of the person who coined &ldquo;test fixtures&rdquo;. Unfortunately, that was not a fruitful endeavor. The next logical step was to look for the etymology of the phrase &ldquo;test fixtures&rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Judging by the Wiki page, it&rsquo;s clear that Ruby on Rails has heavily popularized test fixtures as a concept."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Testing in Go: Fixtures","item":"https://ieftimov.com/post/testing-in-go-fixtures/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing in Go: Fixtures","name":"Testing in Go: Fixtures","description":"When I was researching the topic of test fixtures, I couldn\u0026rsquo;t find much about their beginnings. My first search was about the name of the person who coined \u0026ldquo;test fixtures\u0026rdquo;. Unfortunately, that was not a fruitful endeavor. The next logical step was to look for the etymology of the phrase \u0026ldquo;test fixtures\u0026rdquo;, but the only search result that made sense was a Wikipedia page on the topic.\nJudging by the Wiki page, it\u0026rsquo;s clear that Ruby on Rails has heavily popularized test fixtures as a concept.","keywords":[],"articleBody":"When I was researching the topic of test fixtures, I couldn’t find much about their beginnings. My first search was about the name of the person who coined “test fixtures”. Unfortunately, that was not a fruitful endeavor. The next logical step was to look for the etymology of the phrase “test fixtures”, but the only search result that made sense was a Wikipedia page on the topic.\nJudging by the Wiki page, it’s clear that Ruby on Rails has heavily popularized test fixtures as a concept. Likely though, folks that have been in the industry for a longer time will say that the idea of test fixtures is older than Rails itself.\nTest fixtures contribute to setting up the system for the testing process by providing it with all the necessary data for initialization. The setup using fixtures is done to satisfy any preconditions there may be for the code under test. For example, code that we want to test might require some configuration before being executed or tested. In such cases, we would have to recreate these preconditions to run the code every time we have to test the code.\nMore annoyingly, if the configuration of the tested code would change, we would have to update the configuration structure everywhere where we test that particular code.\nTo avoid such scenarios, we use fixtures. Fixtures allow us to reliably and repeatably create the state our code relies on upon without worrying about the details. When the required state of the code under test changes, we need to tweak a fixture instead of scouring all tests for the code that needs changing.\nI know, I know. My introduction made you dizzy from all the praise of fixtures. So let’s stop the sales pitch here and move on to see how simple fixtures can be and how you can master them as another tool in your testing tool belt.\nMaking a simple grade book As always, when talking about code without having code to look at is not great. Let’s introduce an example representing a grade book populated from a CSV file, using a builder function. After, we will create a lookup method per column and add some tests for both functions.\ntype Record struct { student string subject string grade string } type Gradebook []Record The Record type will have three attributes: student, subject and grade, all three of type string. The Gradebook type is just a slice of Records, nothing more.\nNext, let’s create a builder function for a Gradebook. We want the function to be simple - receive a path to a CSV file as an argument and return a Gradebook with all of the records parsed from the CSV.\nfunc NewGradebook(csvFile io.Reader) (Gradebook, error) { var gradebook Gradebook reader := csv.NewReader(csvFile) for { line, err := reader.Read() if err == io.EOF { break } if err != nil { return gradebook, err } if len(line) 3 { return gradebook, fmt.Errorf(\"Invalid file structure\") } gradebook = append(gradebook, Record{ student: line[0], subject: line[1], grade: line[2], }) } return gradebook, nil } Although a bit bloated, the function doesn’t do much. It receives an io.Reader as an argument (which is the file reader), wraps it in a CSV reader, and reads it line by line. For each line it reads, it will create a new Record struct and append it to the collection of Record’s gradebook. After parsing the whole file, it will exit the loop and return the grade book.\nOf course, in true Go fashion, we gracefully handle the errors in every step of the reading and parsing the file. If there’s an error in any scenario, the function will return the error along with the empty gradebook.\nThe last piece of the puzzle is the function that will find all records in the grade book for a particular student:\nfunc (gb *Gradebook) FindByStudent(student string) []Record { var records []Record for _, record := range *gb { if student == record.student { records = append(records, record) } } return records } The FindByStudent function takes the student name as argument. First, it will loop through the Gradebook’s records and collect the records where the student name matches. Then, it will return the records found for the particular student name.\nTo manually test the code, let’s create a small CSV file, called grades.csv:\nJane,Chemistry,A John,Biology,A Jane,Algebra,B Jane,Biology,A John,Algebra,B John,Chemistry,C In the main function of the file, we will parse it and then get all of Jane’s grades:\nfunc main() { csvFile, err := os.Open(\"grades.csv\") if err != nil { fmt.Println(fmt.Errorf(\"error opening file: %v\", err)) } grades, err := NewGradebook(csvFile) fmt.Printf(\"%+v\\n\", grades.FindByStudent(\"Jane\")) } The output of the function will be:\n$ go run grades.go [{student:Jane subject:Chemistry grade:A} {student:Jane subject:Algebra grade:B} {student:Jane subject:Biology grade:A}] From the output, it is clear what are Jane’s grades in the grade book we have created. Having these two types and two functions is good enough to explain how we can use fixtures in the testing we’re about to do.\nTesting the builder function Whenever we need to test a piece of code, we have to identify its key components. In other words, we have to understand the essential steps that that code takes to accomplish its mission. For example, to test the NewGradebook function, an overly simplified breakdown of its doings would look like:\n Read through each of the lines of the CSV When reading through each line, create a new struct from the data Put the new struct in the collection of structs Return the collection of structs  Now, there’s no need to test if opening a file and parsing it works - we trust Go to take care of that. So instead, we are interested in two things: will our function handle invalid CSV files gracefully, and will it create a Gradebook that we expect from a valid file?\nTo test the error handling, we will introduce a test function:\nfunc TestNewGradebook_ErrorHandling(t *testing.T) { cases := []struct { fixture string returnErr bool name string }{ { fixture: \"testdata/grades/empty.csv\", returnErr: false, name: \"EmptyFile\", }, { fixture: \"testdata/grades/invalid.csv\", returnErr: true, name: \"InvalidFile\", }, { fixture: \"testdata/grades/valid.csv\", returnErr: false, name: \"ValidFile\", }, } for _, tc := range cases { t.Run(tc.name, func(t *testing.T) { _, err := NewGradebook(tc.fixture) returnedErr := err != nil if returnedErr != tc.returnErr { t.Fatalf(\"Expected returnErr: %v, got: %v\", tc.returnErr, returnedErr) } }) } } To run these test cases, we will need three accompanying CSV files in the root of our project: empty.csv, invalid.csv and valid.csv. An empty CSV, an invalid CSV and a valid CSV file, respectively.\nEach of these files is fixtures - files that go together with the test suite, enabling us to assume the state of the system that we run our tests on. Now, the content of these files should be evident from the file names. The invalid.csv will contain just text, but not in a CSV format. The empty.csv will be just an empty file, while the valid.csv file will be a real CSV that our function can parse and use. Lastly, the nonexisting.csv actually will not be a file – we want our tests to fail when this path is passed to the NewGradebook function. And this is the first thing we need to remember about fixtures: we can (and should) create as many fixture files as it makes sense, but not more.\nFixtures should always be placed in a directory (in our example testdata) at the root of our project. We should always put our fixtures in the testdata directory at the root of our project because go test will ignore that path when building our packages. Quoting the output of go help test:\n The go tool will ignore a directory named “testdata”, making it available to hold ancillary data needed by the tests.\n Placing it in the root of the package works great because when we run go test, for each package in the directory tree, go test will execute the test binary with its working directory set to the source directory of the package under test. (Read more about it in Dave Cheney’s article on the topic.)\nIn the example above, we used two nested directories: testdata and grades. We use two nested directories because we want to logically group our fixtures and leave the room for another kind of fixtures within the same project if need be. Software is built to grow, so why not set some sane defaults from the start.\nTesting the FindByStudent function The functionality of the FindByStudent function is a linear search through a Gradebook type (which is a slice of Record’s). It compares the student name from the argument and the name of each of the records in the Gradebook. When a match is found, the matching record is added to the collection records.\nTesting this function is can be based on a couple of state assumptions. The first one is to test FindByStudent we have to have a Gradebook available. The Gradebook can be in three states: empty, without a matching Record, and with a Record that matches the student name from the argument. If we flipped this on its head, it would mean that to test the function, we will need three different Gradebooks: one empty, one without a matching Record, and one with a matching Record.\nTo create such Gradebook’s, we can take two different approaches: define the Gradebook’s directly in the test or use a fixture file. Using the first approach might be preferable, but we will use the second approach to see how we can use fixtures. While we already have the fixture files from the previous test, we can use them in the test of the FindByStudent function:\nfunc TestFindByStudent(t *testing.T) { cases := []struct { fixture string student string want Gradebook name string }{ { fixture: \"fixtures/grades/empty.csv\", student: \"Jane\", want: Gradebook{}, name: \"EmptyFixture\", }, { fixture: \"fixtures/grades/valid.csv\", student: \"Jane\", want: Gradebook{ Record{ student: \"Jane\", subject: \"Chemistry\", grade: \"A\", }, Record{ student: \"Jane\", subject: \"Algebra\", grade: \"A\", }, }, name: \"ValidFixtures\", }, } for _, tc := range cases { t.Run(tc.name, func(t *testing.T) { gradebook, err := NewGradebook(tc.fixture) if err != nil { t.Fatalf(\"Cannot create gradebook: %v\", err) } got := gradebook.FindByStudent(tc.student) for idx, gotGrade := range got { wantedGrade := tc.want[idx] if gotGrade != wantedGrade { t.Errorf(\"Expected: %v, got: %v\", wantedGrade, gotGrade) } } }) } } In this test function, we have defined two test cases: the first one uses the empty.csv fixture, while the other uses the valid.csv fixture. By looking at the test cases, it is clear what we expect to get from each one. For example, when working with the empty CSV, we hope to get a blank grade book - no grades, no grade book. But, on the other hand, when working with the valid.csv we expect to get a Gradebook, with all student grades specified.\nThe test function does not have any magic. It merely builds a Gradebook using the NewGradebook function and the fixture file. Then, we invoke the FindByStudent function on the Gradebook, and we make sure that all of the grades that we got are the ones we expected.\nIf we run the test, we’ll get an output looking like this:\n$ go test -v -run=TestFindByStudent === RUN TestFindByStudent === RUN TestFindByStudent/EmptyFixture === RUN TestFindByStudent/ValidFixture --- PASS: TestFindByStudent (0.00s) --- PASS: TestFindByStudent/EmptyFixture (0.00s) --- PASS: TestFindByStudent/ValidFixture (0.00s) PASS ok _/Users/Ilija/Documents/fixtures\t0.004s The tests pass - building the Gradebooks with the fixtures worked well, so we could range over the test cases and test our expectations.\nTidying up our tests Looking at both test functions that we wrote at the beginning of the t.Run blocks, we can notice that we have to create a new Gradebook using the NewGradebook builder function. In essence, this is the test setup in these two test functions - we have to have an instance of the Gradebook type to run our tests.\nWhen we use fixtures, the failure to use a fixture can mean that we can’t run the tests - they depend on the fixture files being available and usable. If the fixture renders to be unusable, we have to stop the tests further and bail out with an error.\nIt is a quick win to extract a test helper to use in the test setup for such reasons. We can extract all error handling for loading the fixture and test setup outside of the test functions. Let’s create a small function that will do just that:\nfunc buildGradebook(t *testing.T, path string) *Gradebook { gradebook, err := NewGradebook(path) if err != nil { t.Fatalf(\"Cannot create Gradebook: %v\", err) } return \u0026gradebook } The buildGradebook is simply a wrapper around the call to NewGradebook, with one key difference: if a Gradebook cannot be produced using NewGradebook it will mark the test as failed. Signaling the failure is done using t.Fatalf, where instead of returning an empty Gradebook, we immediately make the test fail. In other words: being unable to create a Gradebook is an unrecoverable error. A nice side-effect is that the caller function of buildGradebook does not need to handle the error that might be returned from NewGradebook - that will all be handled by buildGradebook.\nIf we revisit our TestFindByStudent function now, it will not have changed much. Still, it will contain the improvements coming from the buildGradebook function:\nfunc TestFindByStudent(t *testing.T) { cases := []struct { fixture string student string want Gradebook name string }{ { fixture: \"fixtures/grades/empty.csv\", student: \"Jane\", want: Gradebook{}, name: \"EmptyFixture\", }, { fixture: \"fixtures/grades/valid.csv\", student: \"Jane\", want: Gradebook{ Record{ student: \"Jane\", subject: \"Chemistry\", grade: \"A\", }, Record{ student: \"Jane\", subject: \"Algebra\", grade: \"A\", }, }, name: \"ValidFixture\", }, } for _, tc := range cases { t.Run(tc.name, func(t *testing.T) { gradebook := buildGradebook(t, tc.fixture) got := gradebook.FindByStudent(tc.student) for idx, gotGrade := range got { wantedGrade := tc.want[idx] if gotGrade != wantedGrade { t.Errorf(\"Expected: %v, got: %v\", wantedGrade, gotGrade) } } }) } } If we would remove any of the fixture files, we will see how the test will be marked as failed due to the t.Fatal invocation:\n$ rm testdata/grades/valid.csv # We remove the fixture $ go test ./... -count=1 -v -run=TestFindByStudent === RUN TestFindByStudent === RUN TestFindByStudent/ValidFixture === RUN TestFindByStudent/EmptyFixture --- FAIL: TestFindByStudent (0.00s) --- FAIL: TestFindByStudent/ValidFixture (0.00s) grades_test.go:8: Cannot create Gradebook: open testdata/grades/valid.csv: no such file or directory --- PASS: TestFindByStudent/EmptyFixture (0.00s) FAIL FAIL\t_/Users/Ilija/Documents/fixtures\t0.004s By having another function that takes care of building the Gradebook, we can offload the complexity of the missing fixtures outside of the tests themselves. While these concepts are simple, they’re powerful as they lead to cleaner tests with local test functions that are easy to maintain.\nEDIT October 8, 2019: As Andreas Schröpfer suggested in the comments, it’s more idiomatic Go when the function receives a io.Reader instead of a file path. I have updated the example code and the article to reflect that. Thanks Andreas!\nLiked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to hundreds of other engineers.\n    ","wordCount":"2516","inLanguage":"en","datePublished":"2019-09-16T00:00:00Z","dateModified":"2021-06-16T00:00:00Z","author":{"@type":"Person","name":"Ilija Eftimov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/testing-in-go-fixtures/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://www.getrevue.co/profile/itsilija title=Subscribe><span>Subscribe</span></a></li><li><a href=https://ieftimov.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testing in Go: Fixtures</h1><div class=post-meta>September 16, 2019&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Ilija Eftimov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#making-a-simple-grade-book aria-label="Making a simple grade book">Making a simple grade book</a></li><li><a href=#testing-the-builder-function aria-label="Testing the builder function">Testing the builder function</a></li><li><a href=#testing-the-findbystudent-function aria-label="Testing the FindByStudent function">Testing the <code>FindByStudent</code> function</a></li><li><a href=#tidying-up-our-tests aria-label="Tidying up our tests">Tidying up our tests</a></li></ul></div></details></div><div class=post-content><p>When I was researching the topic of test fixtures, I couldn&rsquo;t find much about
their beginnings. My first search was about the name of the person who coined
&ldquo;test fixtures&rdquo;. Unfortunately, that was not a fruitful endeavor. The next
logical step was to look for the etymology of the phrase &ldquo;test fixtures&rdquo;, but
the only search result that made sense was a <a href=https://en.wikipedia.org/wiki/Test_fixture>Wikipedia
page</a> on the topic.</p><p>Judging by the Wiki page, it&rsquo;s clear that Ruby on Rails has heavily popularized
test fixtures as a concept. Likely though, folks that have been in the industry
for a longer time will say that the idea of test fixtures is older than Rails
itself.</p><p>Test fixtures contribute to setting up the system for the testing process by
providing it with all the necessary data for initialization. The setup using
fixtures is done to satisfy any preconditions there may be for the code under
test. For example, code that we want to test might require some configuration
before being executed or tested. In such cases, we would have to recreate these
preconditions to run the code every time we have to test the code.</p><p>More annoyingly, if the configuration of the tested code would change, we would
have to update the configuration structure everywhere where we test that
particular code.</p><p>To avoid such scenarios, we use fixtures. Fixtures allow us to <em>reliably</em> and
<em>repeatably</em> create the state our code relies on upon without worrying about
the details. When the required state of the code under test changes, we need to
tweak a fixture instead of scouring all tests for the code that needs changing.</p><p>I know, I know. My introduction made you dizzy from all the praise of fixtures.
So let&rsquo;s stop the sales pitch here and move on to see how simple fixtures can
be and how you can master them as another tool in your testing tool belt.</p><h2 id=making-a-simple-grade-book>Making a simple grade book<a hidden class=anchor aria-hidden=true href=#making-a-simple-grade-book>#</a></h2><p>As always, when talking about code without having code to look at is not great.
Let&rsquo;s introduce an example representing a grade book populated from a CSV file,
using a builder function. After, we will create a lookup method per column and
add some tests for both functions.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> Record <span style=color:#268bd2>struct</span> {
	student <span style=color:#dc322f>string</span>
	subject <span style=color:#dc322f>string</span>
	grade   <span style=color:#dc322f>string</span>
}

<span style=color:#268bd2>type</span> Gradebook []Record
</code></pre></div><p>The <code>Record</code> type will have three attributes: <code>student</code>, <code>subject</code> and <code>grade</code>,
all three of type <code>string</code>. The <code>Gradebook</code> type is just a slice of <code>Record</code>s,
nothing more.</p><p>Next, let&rsquo;s create a builder function for a <code>Gradebook</code>. We want the function
to be simple - receive a path to a CSV file as an argument and return a
<code>Gradebook</code> with all of the records parsed from the CSV.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>NewGradebook</span>(csvFile io.Reader) (Gradebook, <span style=color:#dc322f>error</span>) {
	<span style=color:#268bd2>var</span> gradebook Gradebook
	reader <span style=color:#719e07>:=</span> csv.<span style=color:#268bd2>NewReader</span>(csvFile)

	<span style=color:#719e07>for</span> {
		line, err <span style=color:#719e07>:=</span> reader.<span style=color:#268bd2>Read</span>()

		<span style=color:#719e07>if</span> err <span style=color:#719e07>==</span> io.EOF {
			<span style=color:#719e07>break</span>
		}

		<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			<span style=color:#719e07>return</span> gradebook, err
		}

		<span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(line) &lt; <span style=color:#2aa198>3</span> {
			<span style=color:#719e07>return</span> gradebook, fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Invalid file structure&#34;</span>)
		}

		gradebook = <span style=color:#b58900>append</span>(gradebook, Record{
			student: line[<span style=color:#2aa198>0</span>],
			subject: line[<span style=color:#2aa198>1</span>],
			grade:   line[<span style=color:#2aa198>2</span>],
		})
	}

	<span style=color:#719e07>return</span> gradebook, <span style=color:#cb4b16>nil</span>
}
</code></pre></div><p>Although a bit bloated, the function doesn&rsquo;t do much. It receives an
<code>io.Reader</code> as an argument (which is the file reader), wraps it in a CSV
reader, and reads it line by line. For each line it reads, it will create a new
<code>Record</code> struct and <code>append</code> it to the collection of <code>Record</code>&rsquo;s <code>gradebook</code>.
After parsing the whole file, it will exit the loop and return the grade book.</p><p>Of course, in true Go fashion, we gracefully handle the errors in every step of
the reading and parsing the file. If there&rsquo;s an error in any scenario, the
function will return the error along with the empty <code>gradebook</code>.</p><p>The last piece of the puzzle is the function that will find all records in the
grade book for a particular student:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (gb <span style=color:#719e07>*</span>Gradebook) <span style=color:#268bd2>FindByStudent</span>(student <span style=color:#dc322f>string</span>) []Record {
	<span style=color:#268bd2>var</span> records []Record
	<span style=color:#719e07>for</span> _, record <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> <span style=color:#719e07>*</span>gb {
		<span style=color:#719e07>if</span> student <span style=color:#719e07>==</span> record.student {
			records = <span style=color:#b58900>append</span>(records, record)
		}
	}
	<span style=color:#719e07>return</span> records
}
</code></pre></div><p>The <code>FindByStudent</code> function takes the <code>student</code> name as argument. First, it
will loop through the <code>Gradebook</code>&rsquo;s records and collect the records where the
student name matches. Then, it will return the records found for the particular
<code>student</code> name.</p><p>To manually test the code, let&rsquo;s create a small CSV file, called <code>grades.csv</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>Jane,Chemistry,A
John,Biology,A
Jane,Algebra,B
Jane,Biology,A
John,Algebra,B
John,Chemistry,C
</code></pre></div><p>In the <code>main</code> function of the file, we will parse it and then get all of Jane&rsquo;s
grades:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	csvFile, err <span style=color:#719e07>:=</span> os.<span style=color:#268bd2>Open</span>(<span style=color:#2aa198>&#34;grades.csv&#34;</span>)
	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
		fmt.<span style=color:#268bd2>Println</span>(fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;error opening file: %v&#34;</span>, err))
	}
	grades, err <span style=color:#719e07>:=</span> <span style=color:#268bd2>NewGradebook</span>(csvFile)
	fmt.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;%+v\n&#34;</span>, grades.<span style=color:#268bd2>FindByStudent</span>(<span style=color:#2aa198>&#34;Jane&#34;</span>))
}
</code></pre></div><p>The output of the function will be:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go run grades.go
<span style=color:#719e07>[{</span>student:Jane subject:Chemistry grade:A<span style=color:#719e07>}</span> <span style=color:#719e07>{</span>student:Jane subject:Algebra grade:B<span style=color:#719e07>}</span> <span style=color:#719e07>{</span>student:Jane subject:Biology grade:A<span style=color:#719e07>}]</span>
</code></pre></div><p>From the output, it is clear what are Jane&rsquo;s grades in the grade book we have
created. Having these two types and two functions is good enough to explain how
we can use fixtures in the testing we&rsquo;re about to do.</p><h2 id=testing-the-builder-function>Testing the builder function<a hidden class=anchor aria-hidden=true href=#testing-the-builder-function>#</a></h2><p>Whenever we need to test a piece of code, we have to identify its key
components. In other words, we have to understand the essential steps that that
code takes to accomplish its mission. For example, to test the <code>NewGradebook</code>
function, an overly simplified breakdown of its doings would look like:</p><ol><li>Read through each of the lines of the CSV</li><li>When reading through each line, create a new struct from the data</li><li>Put the new struct in the collection of structs</li><li>Return the collection of structs</li></ol><p>Now, there&rsquo;s no need to test if opening a file and parsing it works - we trust
Go to take care of that. So instead, we are interested in two things: will our
function handle invalid CSV files gracefully, and will it create a <code>Gradebook</code>
that we expect from a valid file?</p><p>To test the error handling, we will introduce a test function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>TestNewGradebook_ErrorHandling</span>(t <span style=color:#719e07>*</span>testing.T) {
	cases <span style=color:#719e07>:=</span> []<span style=color:#268bd2>struct</span> {
		fixture   <span style=color:#dc322f>string</span>
		returnErr <span style=color:#dc322f>bool</span>
		name      <span style=color:#dc322f>string</span>
	}{
		{
			fixture:   <span style=color:#2aa198>&#34;testdata/grades/empty.csv&#34;</span>,
			returnErr: <span style=color:#cb4b16>false</span>,
			name:      <span style=color:#2aa198>&#34;EmptyFile&#34;</span>,
		},
		{
			fixture:   <span style=color:#2aa198>&#34;testdata/grades/invalid.csv&#34;</span>,
			returnErr: <span style=color:#cb4b16>true</span>,
			name:      <span style=color:#2aa198>&#34;InvalidFile&#34;</span>,
		},
		{
			fixture:   <span style=color:#2aa198>&#34;testdata/grades/valid.csv&#34;</span>,
			returnErr: <span style=color:#cb4b16>false</span>,
			name:      <span style=color:#2aa198>&#34;ValidFile&#34;</span>,
		},
	}

	<span style=color:#719e07>for</span> _, tc <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> cases {
		t.<span style=color:#268bd2>Run</span>(tc.name, <span style=color:#268bd2>func</span>(t <span style=color:#719e07>*</span>testing.T) {
			_, err <span style=color:#719e07>:=</span> <span style=color:#268bd2>NewGradebook</span>(tc.fixture)
			returnedErr <span style=color:#719e07>:=</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span>

			<span style=color:#719e07>if</span> returnedErr <span style=color:#719e07>!=</span> tc.returnErr {
				t.<span style=color:#268bd2>Fatalf</span>(<span style=color:#2aa198>&#34;Expected returnErr: %v, got: %v&#34;</span>, tc.returnErr, returnedErr)
			}
		})
	}
}
</code></pre></div><p>To run these test cases, we will need three accompanying CSV files in the root
of our project: <code>empty.csv</code>, <code>invalid.csv</code> and <code>valid.csv</code>. An empty CSV, an
invalid CSV and a valid CSV file, respectively.</p><p>Each of these files is fixtures - files that go together with the test suite,
enabling us to assume the state of the system that we run our tests on. Now,
the content of these files should be evident from the file names. The
<code>invalid.csv</code> will contain just text, but not in a CSV format. The <code>empty.csv</code>
will be just an empty file, while the <code>valid.csv</code> file will be a real CSV that
our function can parse and use. Lastly, the <code>nonexisting.csv</code> actually will not
be a file – we want our tests to fail when this path is passed to the
<code>NewGradebook</code> function. And this is the first thing we need to remember about
fixtures: we can (and should) create as many fixture files as it makes sense,
but not more.</p><p>Fixtures should always be placed in a directory (in our example <code>testdata</code>) at
the root of our project. We should always put our fixtures in the <code>testdata</code>
directory at the root of our project because <code>go test</code> will ignore that path
when building our packages. Quoting the output of <code>go help test</code>:</p><blockquote><p>The go tool will ignore a directory named &ldquo;testdata&rdquo;, making it available
to hold ancillary data needed by the tests.</p></blockquote><p>Placing it in the root of the package works great because when we run <code>go test</code>, for each package in the directory tree, <code>go test</code> will execute the test
binary with its working directory set to the source directory of the package
under test. (Read more about it in <a href=https://dave.cheney.net/2016/05/10/test-fixtures-in-go>Dave Cheney&rsquo;s
article</a> on the topic.)</p><p>In the example above, we used two nested directories: <code>testdata</code> and <code>grades</code>.
We use two nested directories because we want to logically group our fixtures
and leave the room for another kind of fixtures within the same project if need
be. Software is built to grow, so why not set some sane defaults from the
start.</p><h2 id=testing-the-findbystudent-function>Testing the <code>FindByStudent</code> function<a hidden class=anchor aria-hidden=true href=#testing-the-findbystudent-function>#</a></h2><p>The functionality of the <code>FindByStudent</code> function is a linear search through a
<code>Gradebook</code> type (which is a slice of <code>Record</code>&rsquo;s). It compares the student name
from the argument and the name of each of the records in the <code>Gradebook</code>. When
a match is found, the matching record is added to the collection <code>records</code>.</p><p>Testing this function is can be based on a couple of state assumptions. The
first one is to test <code>FindByStudent</code> we have to have a <code>Gradebook</code> available.
The <code>Gradebook</code> can be in three states: empty, without a matching <code>Record</code>, and
with a <code>Record</code> that matches the student name from the argument. If we flipped
this on its head, it would mean that to test the function, we will need three
different <code>Gradebooks</code>: one empty, one without a matching <code>Record</code>, and one
with a matching <code>Record</code>.</p><p>To create such <code>Gradebook</code>&rsquo;s, we can take two different approaches: define the
<code>Gradebook</code>&rsquo;s directly in the test or use a fixture file. Using the first
approach might be preferable, but we will use the second approach to see how we
can use fixtures. While we already have the fixture files from the previous
test, we can use them in the test of the <code>FindByStudent</code> function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>TestFindByStudent</span>(t <span style=color:#719e07>*</span>testing.T) {
	cases <span style=color:#719e07>:=</span> []<span style=color:#268bd2>struct</span> {
		fixture <span style=color:#dc322f>string</span>
		student <span style=color:#dc322f>string</span>
		want    Gradebook
		name    <span style=color:#dc322f>string</span>
	}{
		{
			fixture: <span style=color:#2aa198>&#34;fixtures/grades/empty.csv&#34;</span>,
			student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
			want:    Gradebook{},
			name:    <span style=color:#2aa198>&#34;EmptyFixture&#34;</span>,
		},
		{
			fixture: <span style=color:#2aa198>&#34;fixtures/grades/valid.csv&#34;</span>,
			student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
			want: Gradebook{
				Record{
					student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
					subject: <span style=color:#2aa198>&#34;Chemistry&#34;</span>,
					grade:   <span style=color:#2aa198>&#34;A&#34;</span>,
				},
				Record{
					student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
					subject: <span style=color:#2aa198>&#34;Algebra&#34;</span>,
					grade:   <span style=color:#2aa198>&#34;A&#34;</span>,
				},
			},
                        name: <span style=color:#2aa198>&#34;ValidFixtures&#34;</span>,
		},
	}

	<span style=color:#719e07>for</span> _, tc <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> cases {
		t.<span style=color:#268bd2>Run</span>(tc.name, <span style=color:#268bd2>func</span>(t <span style=color:#719e07>*</span>testing.T) {
			gradebook, err <span style=color:#719e07>:=</span> <span style=color:#268bd2>NewGradebook</span>(tc.fixture)
			<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
				t.<span style=color:#268bd2>Fatalf</span>(<span style=color:#2aa198>&#34;Cannot create gradebook: %v&#34;</span>, err)
			}

			got <span style=color:#719e07>:=</span> gradebook.<span style=color:#268bd2>FindByStudent</span>(tc.student)
			<span style=color:#719e07>for</span> idx, gotGrade <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> got {
				wantedGrade <span style=color:#719e07>:=</span> tc.want[idx]
				<span style=color:#719e07>if</span> gotGrade <span style=color:#719e07>!=</span> wantedGrade {
					t.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Expected: %v, got: %v&#34;</span>, wantedGrade, gotGrade)
				}
			}

		})
	}

}
</code></pre></div><p>In this test function, we have defined two test cases: the first one uses the
<code>empty.csv</code> fixture, while the other uses the <code>valid.csv</code> fixture. By looking
at the test cases, it is clear what we expect to get from each one. For
example, when working with the empty CSV, we hope to get a blank grade book -
no grades, no grade book. But, on the other hand, when working with the
<code>valid.csv</code> we expect to get a <code>Gradebook</code>, with all student grades specified.</p><p>The test function does not have any magic. It merely builds a <code>Gradebook</code> using
the <code>NewGradebook</code> function and the fixture file. Then, we invoke the
<code>FindByStudent</code> function on the <code>Gradebook</code>, and we make sure that all of the
grades that we got are the ones we expected.</p><p>If we run the test, we&rsquo;ll get an output looking like this:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span> -v -run<span style=color:#719e07>=</span><span style=color:#268bd2>TestFindByStudent</span>
<span style=color:#719e07>===</span> RUN   <span style=color:#268bd2>TestFindByStudent</span>
<span style=color:#719e07>===</span> RUN   TestFindByStudent/EmptyFixture
<span style=color:#719e07>===</span> RUN   TestFindByStudent/ValidFixture
--- PASS: TestFindByStudent <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    --- PASS: TestFindByStudent/EmptyFixture <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    --- PASS: TestFindByStudent/ValidFixture <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
PASS
ok  	_/Users/Ilija/Documents/fixtures	0.004s
</code></pre></div><p>The tests pass - building the <code>Gradebook</code>s with the fixtures worked well, so we
could <code>range</code> over the test cases and test our expectations.</p><h2 id=tidying-up-our-tests>Tidying up our tests<a hidden class=anchor aria-hidden=true href=#tidying-up-our-tests>#</a></h2><p>Looking at both test functions that we wrote at the beginning of the <code>t.Run</code>
blocks, we can notice that we have to create a new <code>Gradebook</code> using the
<code>NewGradebook</code> builder function. In essence, this is the test setup in these
two test functions - we have to have an instance of the <code>Gradebook</code> type to run
our tests.</p><p>When we use fixtures, the failure to use a fixture can mean that we can&rsquo;t run
the tests - they depend on the fixture files being available and usable. If the
fixture renders to be unusable, we have to stop the tests further and bail out
with an error.</p><p>It is a quick win to extract a test helper to use in the test setup for such
reasons. We can extract all error handling for loading the fixture and test
setup outside of the test functions. Let&rsquo;s create a small function that will do
just that:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>buildGradebook</span>(t <span style=color:#719e07>*</span>testing.T, path <span style=color:#dc322f>string</span>) <span style=color:#719e07>*</span>Gradebook {
	gradebook, err <span style=color:#719e07>:=</span> <span style=color:#268bd2>NewGradebook</span>(path)
	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
		t.<span style=color:#268bd2>Fatalf</span>(<span style=color:#2aa198>&#34;Cannot create Gradebook: %v&#34;</span>, err)
	}

	<span style=color:#719e07>return</span> <span style=color:#719e07>&amp;</span>gradebook
}
</code></pre></div><p>The <code>buildGradebook</code> is simply a wrapper around the call to <code>NewGradebook</code>,
with one key difference: if a <code>Gradebook</code> cannot be produced using
<code>NewGradebook</code> it will mark the test as failed. Signaling the failure is done
using <code>t.Fatalf</code>, where instead of returning an empty <code>Gradebook</code>, we
immediately make the test fail. In other words: being unable to create a
<code>Gradebook</code> is an unrecoverable error. A nice side-effect is that the caller
function of <code>buildGradebook</code> does not need to handle the error that might be
returned from <code>NewGradebook</code> - that will all be handled by <code>buildGradebook</code>.</p><p>If we revisit our <code>TestFindByStudent</code> function now, it will not have changed
much. Still, it will contain the improvements coming from the <code>buildGradebook</code>
function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>TestFindByStudent</span>(t <span style=color:#719e07>*</span>testing.T) {
	cases <span style=color:#719e07>:=</span> []<span style=color:#268bd2>struct</span> {
		fixture <span style=color:#dc322f>string</span>
		student <span style=color:#dc322f>string</span>
		want    Gradebook
		name    <span style=color:#dc322f>string</span>
	}{
		{
			fixture: <span style=color:#2aa198>&#34;fixtures/grades/empty.csv&#34;</span>,
			student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
			want:    Gradebook{},
			name:    <span style=color:#2aa198>&#34;EmptyFixture&#34;</span>,
		},
		{ fixture: <span style=color:#2aa198>&#34;fixtures/grades/valid.csv&#34;</span>,
			student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
			want: Gradebook{
				Record{
					student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
					subject: <span style=color:#2aa198>&#34;Chemistry&#34;</span>,
					grade:   <span style=color:#2aa198>&#34;A&#34;</span>,
				},
				Record{
					student: <span style=color:#2aa198>&#34;Jane&#34;</span>,
					subject: <span style=color:#2aa198>&#34;Algebra&#34;</span>,
					grade:   <span style=color:#2aa198>&#34;A&#34;</span>,
				},
			},
			name: <span style=color:#2aa198>&#34;ValidFixture&#34;</span>,
		},
	}

	<span style=color:#719e07>for</span> _, tc <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> cases {
		t.<span style=color:#268bd2>Run</span>(tc.name, <span style=color:#268bd2>func</span>(t <span style=color:#719e07>*</span>testing.T) {
			gradebook <span style=color:#719e07>:=</span> <span style=color:#268bd2>buildGradebook</span>(t, tc.fixture)

			got <span style=color:#719e07>:=</span> gradebook.<span style=color:#268bd2>FindByStudent</span>(tc.student)
			<span style=color:#719e07>for</span> idx, gotGrade <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> got {
				wantedGrade <span style=color:#719e07>:=</span> tc.want[idx]
				<span style=color:#719e07>if</span> gotGrade <span style=color:#719e07>!=</span> wantedGrade {
					t.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Expected: %v, got: %v&#34;</span>, wantedGrade, gotGrade)
				}
			}

		})
	}
}
</code></pre></div><p>If we would remove any of the fixture files, we will see how the test will be
marked as failed due to the <code>t.Fatal</code> invocation:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ rm testdata/grades/valid.csv <span style=color:#586e75># We remove the fixture</span>

$ go <span style=color:#b58900>test</span> ./... -count<span style=color:#719e07>=</span><span style=color:#2aa198>1</span> -v -run<span style=color:#719e07>=</span><span style=color:#268bd2>TestFindByStudent</span>
<span style=color:#719e07>===</span> RUN   <span style=color:#268bd2>TestFindByStudent</span>
<span style=color:#719e07>===</span> RUN   TestFindByStudent/ValidFixture
<span style=color:#719e07>===</span> RUN   TestFindByStudent/EmptyFixture
--- FAIL: TestFindByStudent <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    --- FAIL: TestFindByStudent/ValidFixture <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
        grades_test.go:8: Cannot create Gradebook: open testdata/grades/valid.csv: no such file or directory
    --- PASS: TestFindByStudent/EmptyFixture <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
FAIL
FAIL	_/Users/Ilija/Documents/fixtures	0.004s
</code></pre></div><p>By having another function that takes care of building the <code>Gradebook</code>, we can
offload the complexity of the missing fixtures outside of the tests themselves.
While these concepts are simple, they&rsquo;re powerful as they lead to cleaner tests
with local test functions that are easy to maintain.</p><p><strong>EDIT October 8, 2019</strong>: As <a href=https://github.com/lyckade>Andreas Schröpfer</a>
suggested in the comments, it&rsquo;s more idiomatic Go when the function receives a
<code>io.Reader</code> instead of a file path. I have updated the example code and the
article to reflect that. Thanks Andreas!</p><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to hundreds of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://ieftimov.com/post/simple-golang-database-seeding-abstraction-gorm/><span class=title>« Prev Page</span><br><span>Simple Golang database seeding abstraction for Gorm</span></a>
<a class=next href=https://ieftimov.com/post/testing-in-go-subtests/><span class=title>Next Page »</span><br><span>Testing in Go: Subtests</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Fixtures on twitter" href="https://twitter.com/intent/tweet/?text=Testing%20in%20Go%3a%20Fixtures&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-fixtures%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Fixtures on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-fixtures%2f&title=Testing%20in%20Go%3a%20Fixtures&summary=Testing%20in%20Go%3a%20Fixtures&source=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-fixtures%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Fixtures on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-fixtures%2f&title=Testing%20in%20Go%3a%20Fixtures"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Fixtures on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-fixtures%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Fixtures on whatsapp" href="https://api.whatsapp.com/send?text=Testing%20in%20Go%3a%20Fixtures%20-%20https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-fixtures%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Fixtures on telegram" href="https://telegram.me/share/url?text=Testing%20in%20Go%3a%20Fixtures&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-fixtures%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2022 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>