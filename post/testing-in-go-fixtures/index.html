<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Testing in Go: Fixtures - Ilija Eftimov</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Testing in Go: Fixtures" />
<meta property="og:description" content="When I was researching the topic of test fixtures, I couldn&#39;t find much about their beginnings. My first search was about the name of the person who coined &ldquo;test fixtures&rdquo;. Unfortunately, that was not a fruitful edeavour. The next logical step was to look for etymology of the phrase &ldquo;test fixtures&rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Judging by the Wiki page, it&#39;s clear that test fixutures as a concept has been heavily popularized by Ruby on Rails." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ieftimov.com/post/testing-in-go-fixtures/" />
<meta property="og:image" content="https://ieftimov.com/cards/testing-in-go-fixtures.png" />
<meta property="article:published_time" content="2019-09-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-09-16T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ieftimov.com/cards/testing-in-go-fixtures.png"/>

<meta name="twitter:title" content="Testing in Go: Fixtures"/>
<meta name="twitter:description" content="When I was researching the topic of test fixtures, I couldn&#39;t find much about their beginnings. My first search was about the name of the person who coined &ldquo;test fixtures&rdquo;. Unfortunately, that was not a fruitful edeavour. The next logical step was to look for etymology of the phrase &ldquo;test fixtures&rdquo;, but the only search result that made sense was a Wikipedia page on the topic.
Judging by the Wiki page, it&#39;s clear that test fixutures as a concept has been heavily popularized by Ruby on Rails."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.com/css/main.css" />
		<link rel="stylesheet" type="text/css" href="https://ieftimov.com/css/overrides.css" />
	

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://ieftimov.com/js/main.js"></script><script src="https://ieftimov.com/js/tooltip.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://ieftimov.com/">
				<img src="https://pbs.twimg.com/profile_images/1194757753585225728/JbET17PZ_400x400.jpg" alt="Ilija Eftimov" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://ieftimov.com/">Ilija Eftimov</a></h1>
	<div class="site-description"><p>Software engineer, author and open source contributor</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/fteem" title="Github"><i data-feather="github"></i></a></li><li><a href="https://twitter.com/fteem" title="Twitter"><i data-feather="twitter"></i></a></li><li><a href="https://www.linkedin.com/in/ieftimov" title="Linkedin"><i data-feather="linkedin"></i></a></li><li><a href="mailto:blog@ieftimov.com" title="Email"><i data-feather="mail"></i></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">Archive</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="https://forms.gle/orfXK5jh1LRaiFzo8">Suggest a topic</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">16</span>
							<span class="rest">Sep 2019</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Testing in Go: Fixtures</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p><img src="/testing-in-go-fixtures/sculpting.png" alt=""></p>
<p>When I was researching the topic of test fixtures, I couldn't find much about
their beginnings. My first search was about the name of the person who coined
&ldquo;test fixtures&rdquo;. Unfortunately, that was not a fruitful edeavour. The next
logical step was to look for etymology of the phrase &ldquo;test fixtures&rdquo;, but the
only search result that made sense was a <a href="https://en.wikipedia.org/wiki/Test_fixture">Wikipedia
page</a> on the topic.</p>
<p>Judging by the Wiki page, it's clear that test fixutures as a concept has been
heavily popularized by Ruby on Rails. Likely though, folks that have been in
the industry for a longer time will say that the idea of test fixutres is older
than Rails itself. What I feel is more important in this discussion is putting
the historical facts aside and who/what is to blame to the popularization of
the concept. Instead, we should focus on understanding the motivation behind it
and how we can improve its implementations.</p>
<p>Test fixtures contribute to setting up the system for the testing process by
providing it with all the necessary data for initialization. This is done to
satisfy any preconditions there may be for the code under test. For example,
code that we want to test might require some configuration before it can be
executed or tested. This means that every time we have to test such code, we
would have to recreate these preconditions to run the code.</p>
<p>More annoyingly, if the configuration of the tested code would change, we would
have to update the structure of the configuration everywhere where we test that
particular code.</p>
<p>To avoid such scenarios, we use fixtures. Fixtures allow us to <em>reliably</em> and
<em>repeatably</em> create the state that our code relies on, without worrying about
the details. If the required state for the code under test would change, we
need only to tweak a fixture, instead of scouring all of our tests for the code
that needs to be changed.</p>
<p>I know, I know. My introduction made you dizzy from all the praise of fixtures.
Let's stop the sales pitch here and move on to see how simple fixtures can be
and how you can master them as another tool in your testing toolbelt.</p>
<p><img src="/testing-in-go-fixtures/progress_tracking.png" alt=""></p>
<h2 id="making-a-simple-gradebook">Making a simple gradebook</h2>
<p>As always, talking about code without having code to talk about is not great.
Let's introduce an example representing a gradebook that will be populated from
a CSV file, using a builder function. After, we will create a lookup method per
column and add some tests for both functions.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> Record <span style="font-weight:bold">struct</span> {
	student <span style="color:#458;font-weight:bold">string</span>
	subject <span style="color:#458;font-weight:bold">string</span>
	grade   <span style="color:#458;font-weight:bold">string</span>
}

<span style="font-weight:bold">type</span> Gradebook []Record</code></pre></div>
<p>The <code>Record</code> type will have three attributes: <code>student</code>, <code>subject</code> and <code>grade</code>,
all three of type <code>string</code>. The <code>Gradebook</code> type is just a slice of <code>Record</code>s,
nothing more.</p>
<p>Next, let's create a builder function for a <code>Gradebook</code>. We want the function
to be simple - receive a path to a CSV file as argument and return a
<code>Gradebook</code> with all of the records parsed from the CSV.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">NewGradebook</span>(csvFile io.Reader) (Gradebook, <span style="color:#458;font-weight:bold">error</span>) {
	<span style="font-weight:bold">var</span> gradebook Gradebook
	reader <span style="font-weight:bold">:=</span> csv.<span style="color:#900;font-weight:bold">NewReader</span>(csvFile)

	<span style="font-weight:bold">for</span> {
		line, err <span style="font-weight:bold">:=</span> reader.<span style="color:#900;font-weight:bold">Read</span>()

		<span style="font-weight:bold">if</span> err <span style="font-weight:bold">==</span> io.EOF {
			<span style="font-weight:bold">break</span>
		}

		<span style="font-weight:bold">if</span> err <span style="font-weight:bold">!=</span> <span style="font-weight:bold">nil</span> {
			<span style="font-weight:bold">return</span> gradebook, err
		}

		<span style="font-weight:bold">if</span> <span style="color:#999">len</span>(line) &lt; <span style="color:#099">3</span> {
			<span style="font-weight:bold">return</span> gradebook, fmt.<span style="color:#900;font-weight:bold">Errorf</span>(<span style="color:#b84">&#34;Invalid file structure&#34;</span>)
		}

		gradebook = <span style="color:#999">append</span>(gradebook, Record{
			student: line[<span style="color:#099">0</span>],
			subject: line[<span style="color:#099">1</span>],
			grade:   line[<span style="color:#099">2</span>],
		})
	}

	<span style="font-weight:bold">return</span> gradebook, <span style="font-weight:bold">nil</span>
}</code></pre></div>
<p>Although a bit bloated, the function actually doesn't do much. It receives an
<code>io.Reader</code> as argument (which is the file reader), wraps it in a CSV reader
and reads it line by line. For each line it reads, it will create a new
<code>Record</code> struct and <code>append</code> it to the collection of <code>Record</code>s, <code>gradebook</code>.
After parsing the whole file it will exit the loop and return the gradebook.</p>
<p>Of course, in true Go fashion, in every step of the reading and parsing the
file we gracefully handle the errors. If in any scenario there's an error, the
function will return the error along with the empty <code>gradebook</code>.</p>
<p>The last piece of the puzzle is the function which will find all records in the
gradebook for a particular student:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> (gb <span style="font-weight:bold">*</span>Gradebook) <span style="color:#900;font-weight:bold">FindByStudent</span>(student <span style="color:#458;font-weight:bold">string</span>) []Record {
	<span style="font-weight:bold">var</span> records []Record
	<span style="font-weight:bold">for</span> _, record <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> <span style="font-weight:bold">*</span>gb {
		<span style="font-weight:bold">if</span> student <span style="font-weight:bold">==</span> record.student {
			records = <span style="color:#999">append</span>(records, record)
		}
	}
	<span style="font-weight:bold">return</span> records
}</code></pre></div>
<p>The <code>FindByStudent</code> function takes the <code>student</code> name as argument. Then, it
will loop through all the records of the <code>Gradebook</code> and will collect all of
the records where the name of the student matches. Lastly, it will return the
records found for the particular <code>student</code> name.</p>
<p>To manually test the code, let's create a small CSV file, called <code>grades.csv</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">Jane,Chemistry,A
John,Biology,A
Jane,Algebra,B
Jane,Biology,A
John,Algebra,B
John,Chemistry,C</code></pre></div>
<p>In the <code>main</code> function of the file we will parse it and then get all of Jane's
grades:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
	csvFile, err <span style="font-weight:bold">:=</span> os.<span style="color:#900;font-weight:bold">Open</span>(<span style="color:#b84">&#34;grades.csv&#34;</span>)
	<span style="font-weight:bold">if</span> err <span style="font-weight:bold">!=</span> <span style="font-weight:bold">nil</span> {
		fmt.<span style="color:#900;font-weight:bold">Println</span>(fmt.<span style="color:#900;font-weight:bold">Errorf</span>(<span style="color:#b84">&#34;error opening file: %v&#34;</span>, err))
	}
	grades, err <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">NewGradebook</span>(csvFile)
	fmt.<span style="color:#900;font-weight:bold">Printf</span>(<span style="color:#b84">&#34;%+v\n&#34;</span>, grades.<span style="color:#900;font-weight:bold">FindByStudent</span>(<span style="color:#b84">&#34;Jane&#34;</span>))
}</code></pre></div>
<p>The output of the function will be:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go run grades.go
<span style="font-weight:bold">[</span><span style="font-weight:bold">{</span>student:Jane subject:Chemistry grade:A<span style="font-weight:bold">}</span> <span style="font-weight:bold">{</span>student:Jane subject:Algebra grade:B<span style="font-weight:bold">}</span> <span style="font-weight:bold">{</span>student:Jane subject:Biology grade:A<span style="font-weight:bold">}</span><span style="font-weight:bold">]</span></code></pre></div>
<p>From the output it is clear what are Jane's grades in the gradebook we have
created. Having these two types and two functions is good enough to explain how
we can use fixtures in the testing we're about to do.</p>
<h2 id="testing-the-builder-function">Testing the builder function</h2>
<p>Whenever we need to test a piece of code, we have to identify what are its key
components. In other words, we have to understand what are the important steps
that that code takes to accomplish its mission. For example, to test the
<code>NewGradebook</code> function an overly simplified breakdown of its doings would look
like:</p>
<ol>
<li>Read through each of the lines of the CSV</li>
<li>When reading through each line, create a new struct from the data</li>
<li>Put the new struct in the collection of structs</li>
<li>Return the collection of structs</li>
</ol>
<p>Now, there's no need to test if opening a file and parsing it works - we trust
Go to take care of that. There are two things we are interested at: will our
function handle invalid CSV files gracefully, and will it create a <code>Gradebook</code>
that what we expect from a valid file?</p>
<p>To test the error handling, we will introduce a test function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestNewGradebook_ErrorHandling</span>(t <span style="font-weight:bold">*</span>testing.T) {
	cases <span style="font-weight:bold">:=</span> []<span style="font-weight:bold">struct</span> {
		fixture   <span style="color:#458;font-weight:bold">string</span>
		returnErr <span style="color:#458;font-weight:bold">bool</span>
		name      <span style="color:#458;font-weight:bold">string</span>
	}{
		{
			fixture:   <span style="color:#b84">&#34;testdata/grades/empty.csv&#34;</span>,
			returnErr: <span style="font-weight:bold">false</span>,
			name:      <span style="color:#b84">&#34;EmptyFile&#34;</span>,
		},
		{
			fixture:   <span style="color:#b84">&#34;testdata/grades/invalid.csv&#34;</span>,
			returnErr: <span style="font-weight:bold">true</span>,
			name:      <span style="color:#b84">&#34;InvalidFile&#34;</span>,
		},
		{
			fixture:   <span style="color:#b84">&#34;testdata/grades/valid.csv&#34;</span>,
			returnErr: <span style="font-weight:bold">false</span>,
			name:      <span style="color:#b84">&#34;ValidFile&#34;</span>,
		},
	}

	<span style="font-weight:bold">for</span> _, tc <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> cases {
		t.<span style="color:#900;font-weight:bold">Run</span>(tc.name, <span style="font-weight:bold">func</span>(t <span style="font-weight:bold">*</span>testing.T) {
			_, err <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">NewGradebook</span>(tc.fixture)
			returnedErr <span style="font-weight:bold">:=</span> err <span style="font-weight:bold">!=</span> <span style="font-weight:bold">nil</span>

			<span style="font-weight:bold">if</span> returnedErr <span style="font-weight:bold">!=</span> tc.returnErr {
				t.<span style="color:#900;font-weight:bold">Fatalf</span>(<span style="color:#b84">&#34;Expected returnErr: %v, got: %v&#34;</span>, tc.returnErr, returnedErr)
			}
		})
	}
}</code></pre></div>
<p>To run these test cases, we will need three accompanying CSV files, in the root
of our project: <code>empty.csv</code>, <code>invalid.csv</code> and <code>valid.csv</code>. An empty CSV, an
invalid CSV and a valid CSV file, respectively.</p>
<p>Each of these files are actually fixtures - files that go together with the
test suite of this project, enabling us to assume the state of the system that
we run our tests on. Now, the content of these files should be obvious from the
file names. The <code>invalid.csv</code> will contain just text, not in a CSV format
though. The <code>empty.csv</code> will be just an empty file, while the <code>valid.csv</code> file
will be a real CSV that our function can parse and use. Lastly, the
<code>nonexisting.csv</code> actually will not be a file – we want our tests to fail when
this path is passed to the <code>NewGradebook</code> function. And this is the first thing
we need to remember about fixtures: we can (and should) create as many fixture
files as it makes sense, but not more than that.</p>
<p>Fixtures should always be placed in a directory (in our example <code>testdata</code>) in
the root of our project. In fact, we should always place our fixtures in the
<code>testdata</code> directory at the root of our project because <code>go test</code> will ignore
that path when building our packages. Quoting the ouput of <code>go help test</code>:</p>
<blockquote>
<p>The go tool will ignore a directory named &ldquo;testdata&rdquo;, making it available
to hold ancillary data needed by the tests.</p>
</blockquote>
<p>Placing it in the root of the directory works great because when we run <code>go test</code>, for each package in the directory tree, the test binary will be executed
with its working directory set to the source directory of the package under
test. (Read more about it in <a href="https://dave.cheney.net/2016/05/10/test-fixtures-in-go">Dave Cheney's
article</a> on the topic.)</p>
<p>In the example above, we used two nested directories: <code>testdata</code> and <code>grades</code>.
This is because we want to logically group our fixtures and leave the room for
other kind of fixtures within the same project, if need be. Software is built
to grow, so why not set some sane defaults from the start.</p>
<p><img src="/testing-in-go-fixtures/exams.png" alt=""></p>
<h2 id="testing-the-findbystudent-function">Testing the <code>FindByStudent</code> function</h2>
<p>The functionality of the <code>FindByStudent</code> function is a linear search though a
<code>Gradebook</code> type (which is a slice of <code>Record</code>s). It compares the student name
from the argument and the name of each of the records in the <code>Gradebook</code>. When
a match is found, the matching record is added to the collection <code>records</code>.</p>
<p>Testing this function is can be based on couple of state assumptions. The first
one is that to test <code>FindByStudent</code> we have to have a <code>Gradebook</code> available.
The <code>Gradebook</code> can be in three states: empty, without a matching <code>Record</code> and
with a <code>Record</code> that matches the student name from the argument. If we would
flip this on its head, it would mean that to test the function we will need
three different <code>Gradebooks</code>: one empty, one without a matching <code>Record</code>, and
one with a matching <code>Record</code>.</p>
<p>To be able to create such <code>Gradebook</code>s we can take two different approaches:
define the <code>Gradebook</code>s directly in the test, or use a fixture file. Using the
first approach might be more preferred by some, but for the purpose of seeing
how we can use fixtures we will use the second approach. While we already have
the fixture files from the previous test, we can use them in the test of the
<code>FindByStudent</code> function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestFindByStudent</span>(t <span style="font-weight:bold">*</span>testing.T) {
	cases <span style="font-weight:bold">:=</span> []<span style="font-weight:bold">struct</span> {
		fixture <span style="color:#458;font-weight:bold">string</span>
		student <span style="color:#458;font-weight:bold">string</span>
		want    Gradebook
		name    <span style="color:#458;font-weight:bold">string</span>
	}{
		{
			fixture: <span style="color:#b84">&#34;fixtures/grades/empty.csv&#34;</span>,
			student: <span style="color:#b84">&#34;Jane&#34;</span>,
			want:    Gradebook{},
			name:    <span style="color:#b84">&#34;EmptyFixture&#34;</span>,
		},
		{
			fixture: <span style="color:#b84">&#34;fixtures/grades/valid.csv&#34;</span>,
			student: <span style="color:#b84">&#34;Jane&#34;</span>,
			want: Gradebook{
				Record{
					student: <span style="color:#b84">&#34;Jane&#34;</span>,
					subject: <span style="color:#b84">&#34;Chemistry&#34;</span>,
					grade:   <span style="color:#b84">&#34;A&#34;</span>,
				},
				Record{
					student: <span style="color:#b84">&#34;Jane&#34;</span>,
					subject: <span style="color:#b84">&#34;Algebra&#34;</span>,
					grade:   <span style="color:#b84">&#34;A&#34;</span>,
				},
			},
                        name: <span style="color:#b84">&#34;ValidFixtures&#34;</span>,
		},
	}

	<span style="font-weight:bold">for</span> _, tc <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> cases {
		t.<span style="color:#900;font-weight:bold">Run</span>(tc.name, <span style="font-weight:bold">func</span>(t <span style="font-weight:bold">*</span>testing.T) {
			gradebook, err <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">NewGradebook</span>(tc.fixture)
			<span style="font-weight:bold">if</span> err <span style="font-weight:bold">!=</span> <span style="font-weight:bold">nil</span> {
				t.<span style="color:#900;font-weight:bold">Fatalf</span>(<span style="color:#b84">&#34;Cannot create gradebook: %v&#34;</span>, err)
			}

			got <span style="font-weight:bold">:=</span> gradebook.<span style="color:#900;font-weight:bold">FindByStudent</span>(tc.student)
			<span style="font-weight:bold">for</span> idx, gotGrade <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> got {
				wantedGrade <span style="font-weight:bold">:=</span> tc.want[idx]
				<span style="font-weight:bold">if</span> gotGrade <span style="font-weight:bold">!=</span> wantedGrade {
					t.<span style="color:#900;font-weight:bold">Errorf</span>(<span style="color:#b84">&#34;Expected: %v, got: %v&#34;</span>, wantedGrade, gotGrade)
				}
			}

		})
	}

}</code></pre></div>
<p>In this test function we have defined two test cases: the first one uses the
<code>empty.csv</code> fixture, while the other uses <code>valid.csv</code> fixture. By looking at
the test cases it is clear what we expect to get from each one. When working
with the empty CSV we expect to get an empty gradebook - no grades, no gradebook.
But, when working with the <code>valid.csv</code> we expect to get a <code>Gradebook</code> that will
have all of the grades for the student specified in that particular test case,
in this case <code>Jane</code>.</p>
<p>The test function does not have any magic. It merely builds a <code>Gradebook</code> using
the <code>NewGradebook</code> function and the fixture file. Then, we invoke the
<code>FindByStudent</code> function on the <code>Gradebook</code> and we make srue that all of the
grades that we got are the ones we expected.</p>
<p>If we run the test, we'll get an output looking like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go <span style="color:#999">test</span> -v -run<span style="font-weight:bold">=</span><span style="color:#008080">TestFindByStudent</span>
<span style="font-weight:bold">=</span><span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> RUN   <span style="color:#008080">TestFindByStudent</span>
<span style="font-weight:bold">=</span><span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> RUN   TestFindByStudent/EmptyFixture
<span style="font-weight:bold">=</span><span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> RUN   TestFindByStudent/ValidFixture
--- PASS: TestFindByStudent <span style="font-weight:bold">(</span>0.00s<span style="font-weight:bold">)</span>
    --- PASS: TestFindByStudent/EmptyFixture <span style="font-weight:bold">(</span>0.00s<span style="font-weight:bold">)</span>
    --- PASS: TestFindByStudent/ValidFixture <span style="font-weight:bold">(</span>0.00s<span style="font-weight:bold">)</span>
PASS
ok  	_/Users/Ilija/Documents/fixtures	0.004s</code></pre></div>
<p>The tests pass - building the <code>Gradebook</code>s with the fixtures worked well, so we
could <code>range</code> over the test cases and test our expectations.</p>
<p><img src="/testing-in-go-fixtures/clean_up.png" alt=""></p>
<h2 id="tidying-up-our-tests">Tidying up our tests</h2>
<p>Looking at both test functions that we wrote, at the beginning of the <code>t.Run</code>
blocks we can notice that we have to create a new <code>Gradebook</code> by using the
<code>NewGradebook</code> builder function. In essence, this is the test setup in these
two test functions - we have to have an instance of the <code>Gradebook</code> type to run
our tests.</p>
<p>When we use fixtures the failure to use a fixture can mean that the tests
cannot be run - they depend on the fixture files being available and usable. In
case where the fixture renders to be unusable, we have to stop the execution of
the tests futher and bail out with an error.</p>
<p>For such reasons it is a quick win to extract a test helper that can be used in
the test setup. By doing that, we all of the error handling for loading the
fixture and test setup can be extracted outside of the tests functions. Let's
create a small function that will do just that:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">buildGradebook</span>(t <span style="font-weight:bold">*</span>testing.T, path <span style="color:#458;font-weight:bold">string</span>) <span style="font-weight:bold">*</span>Gradebook {
	gradebook, err <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">NewGradebook</span>(path)
	<span style="font-weight:bold">if</span> err <span style="font-weight:bold">!=</span> <span style="font-weight:bold">nil</span> {
		t.<span style="color:#900;font-weight:bold">Fatalf</span>(<span style="color:#b84">&#34;Cannot create Gradebook: %v&#34;</span>, err)
	}

	<span style="font-weight:bold">return</span> <span style="font-weight:bold">&amp;</span>gradebook
}</code></pre></div>
<p>The <code>buildGradebook</code> is simply a wrapper around the call to <code>NewGradebook</code>,
with one key difference: if a <code>Gradebook</code> cannot be produced using
<code>NewGradebook</code> it will actually mark the as failed. This is done using
<code>t.Fatalf</code>, where instead of returning an empty <code>Gradebook</code> we immediately make
the test fail. In other words: being unable to create a <code>Gradebook</code> is an
unrecoverable error. A nice sideffect of this is that the caller function of
<code>buildGradebook</code> does not need to handle the error that might be returned from
<code>NewGradebook</code> - that will all be handled by <code>buildGradebook</code>.</p>
<p>If we revisit our <code>TestFindByStudent</code> function now, it will not have changed
much. Still, it will contain the improvements coming from the <code>buildGradebook</code>
function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestFindByStudent</span>(t <span style="font-weight:bold">*</span>testing.T) {
	cases <span style="font-weight:bold">:=</span> []<span style="font-weight:bold">struct</span> {
		fixture <span style="color:#458;font-weight:bold">string</span>
		student <span style="color:#458;font-weight:bold">string</span>
		want    Gradebook
		name    <span style="color:#458;font-weight:bold">string</span>
	}{
		{
			fixture: <span style="color:#b84">&#34;fixtures/grades/empty.csv&#34;</span>,
			student: <span style="color:#b84">&#34;Jane&#34;</span>,
			want:    Gradebook{},
			name:    <span style="color:#b84">&#34;EmptyFixture&#34;</span>,
		},
		{ fixture: <span style="color:#b84">&#34;fixtures/grades/valid.csv&#34;</span>,
			student: <span style="color:#b84">&#34;Jane&#34;</span>,
			want: Gradebook{
				Record{
					student: <span style="color:#b84">&#34;Jane&#34;</span>,
					subject: <span style="color:#b84">&#34;Chemistry&#34;</span>,
					grade:   <span style="color:#b84">&#34;A&#34;</span>,
				},
				Record{
					student: <span style="color:#b84">&#34;Jane&#34;</span>,
					subject: <span style="color:#b84">&#34;Algebra&#34;</span>,
					grade:   <span style="color:#b84">&#34;A&#34;</span>,
				},
			},
			name: <span style="color:#b84">&#34;ValidFixture&#34;</span>,
		},
	}

	<span style="font-weight:bold">for</span> _, tc <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> cases {
		t.<span style="color:#900;font-weight:bold">Run</span>(tc.name, <span style="font-weight:bold">func</span>(t <span style="font-weight:bold">*</span>testing.T) {
			gradebook <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">buildGradebook</span>(t, tc.fixture)

			got <span style="font-weight:bold">:=</span> gradebook.<span style="color:#900;font-weight:bold">FindByStudent</span>(tc.student)
			<span style="font-weight:bold">for</span> idx, gotGrade <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> got {
				wantedGrade <span style="font-weight:bold">:=</span> tc.want[idx]
				<span style="font-weight:bold">if</span> gotGrade <span style="font-weight:bold">!=</span> wantedGrade {
					t.<span style="color:#900;font-weight:bold">Errorf</span>(<span style="color:#b84">&#34;Expected: %v, got: %v&#34;</span>, wantedGrade, gotGrade)
				}
			}

		})
	}
}</code></pre></div>
<p>If we would remove any of the fixture files, we will see how the test will be
marked as failed due to the <code>t.Fatal</code> invocation:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rm testdata/grades/valid.csv <span style="color:#998;font-style:italic"># We remove the fixture</span>

$ go <span style="color:#999">test</span> ./... -count<span style="font-weight:bold">=</span><span style="color:#099">1</span> -v -run<span style="font-weight:bold">=</span><span style="color:#008080">TestFindByStudent</span>
<span style="font-weight:bold">=</span><span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> RUN   <span style="color:#008080">TestFindByStudent</span>
<span style="font-weight:bold">=</span><span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> RUN   TestFindByStudent/ValidFixture
<span style="font-weight:bold">=</span><span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> RUN   TestFindByStudent/EmptyFixture
--- FAIL: TestFindByStudent <span style="font-weight:bold">(</span>0.00s<span style="font-weight:bold">)</span>
    --- FAIL: TestFindByStudent/ValidFixture <span style="font-weight:bold">(</span>0.00s<span style="font-weight:bold">)</span>
        grades_test.go:8: Cannot create Gradebook: open testdata/grades/valid.csv: no such file or directory
    --- PASS: TestFindByStudent/EmptyFixture <span style="font-weight:bold">(</span>0.00s<span style="font-weight:bold">)</span>
FAIL
FAIL	_/Users/Ilija/Documents/fixtures	0.004s</code></pre></div>
<p>By having another function that takes care of building the <code>Gradebook</code> we're
able to offload the complexity of the missing fixtures outside of the tests
themselves. While these concepts are simple, they're powerful as they lead to
cleaner tests and functions that are local to the test and easy to maintain.</p>
<!-- raw HTML omitted -->
<p><strong>EDIT October 8, 2019</strong>: As <a href="https://github.com/lyckade">Andreas Schröpfer</a> suggested in the comments, it's more idiomatic Go when the function receives a <code>io.Reader</code> instead of a file path. I have updated the example code and the article to reflect that. Thanks Andreas!</p>

			</div>

			<div class="tags">
				
					
				
			</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'eftimov';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> Copyright © 2014 - 2019 Ilija Eftimov |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-11264459-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
