<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles in Ruby | Ilija Eftimov ⚡️</title><meta name=keywords content="services,provider"><meta name=description content="Regardless of your knowledge level, as a programmer you love to write awesome code. It&rsquo;s what we do. We like it and we do it every single day. But, we all know that writing awesome code is not easy at all. So, how can we improve the code we produce every day?
An awareness (or a reminder!) of SOLID principles is beneficial here. SOLID is a group of five principles that when applied correctly can help us produce better code."><meta name=author content="Ilija Eftimov"><link rel=canonical href=https://ieftimov.com/post/solid-principles-ruby/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="SOLID Principles in Ruby"><meta property="og:description" content="Regardless of your knowledge level, as a programmer you love to write awesome code. It&rsquo;s what we do. We like it and we do it every single day. But, we all know that writing awesome code is not easy at all. So, how can we improve the code we produce every day?
An awareness (or a reminder!) of SOLID principles is beneficial here. SOLID is a group of five principles that when applied correctly can help us produce better code."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/solid-principles-ruby/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles in Ruby"><meta name=twitter:description content="Regardless of your knowledge level, as a programmer you love to write awesome code. It&rsquo;s what we do. We like it and we do it every single day. But, we all know that writing awesome code is not easy at all. So, how can we improve the code we produce every day?
An awareness (or a reminder!) of SOLID principles is beneficial here. SOLID is a group of five principles that when applied correctly can help us produce better code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"SOLID Principles in Ruby","item":"https://ieftimov.com/post/solid-principles-ruby/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles in Ruby","name":"SOLID Principles in Ruby","description":"Regardless of your knowledge level, as a programmer you love to write awesome code. It\u0026rsquo;s what we do. We like it and we do it every single day. But, we all know that writing awesome code is not easy at all. So, how can we improve the code we produce every day?\nAn awareness (or a reminder!) of SOLID principles is beneficial here. SOLID is a group of five principles that when applied correctly can help us produce better code.","keywords":["services","provider"],"articleBody":"Regardless of your knowledge level, as a programmer you love to write awesome code. It’s what we do. We like it and we do it every single day. But, we all know that writing awesome code is not easy at all. So, how can we improve the code we produce every day?\nAn awareness (or a reminder!) of SOLID principles is beneficial here. SOLID is a group of five principles that when applied correctly can help us produce better code.\nSo, what are the SOLID principles? SOLID is a mnemonic acronym coined by Uncle Bob back in the early 2000s. It represents a group of five principles:\n Single Responsibility Principle Open/Closed Principle Liskov Substitution Principle Interface Segregation Principle Dependency Inversion Principle  Sounds good? Great. Let’s take a look at each of these principles.\nIn my opinion, this is the easiest principle to understand. What SRP says is:\n Every class should have a single responsibility, and that responsibility should be entirely encapsulated by the class.\n What does this mean? Basically, every class in your app must have a single responsibility. Easy as that. The best way to detect if your class obeys this principle is to answer this question:\n What does this class do?\n If your answer contains the word AND, then your class does not obey the SRP.\nLets see a quick example. There’s the Student class and every student has grades for different terms.\nclass Student attr_accessor :first_term_home_work, :first_term_test, :first_term_paper attr_accessor :second_term_home_work, :second_term_test, :second_term_paper def first_term_grade (first_term_home_work + first_term_test + first_term_paper) / 3 end def second_term_grade (second_term_home_work + second_term_test + second_term_paper) / 3 end end Some of you may already be thinking “that is wrong sir!”, some of you may not. Regardless of that, yes, this does not obey the SRP. The reason is that the class Student contains the logic that calculates the average grade for each term. The responsibility of Student is to hold info/logic about the student, not the grades. The logic that calculates the grades should be part of a class Grade, not Student.\nLet’s refactor the code.\nclass Student def initialize @terms = [ Grade.new(:first), Grade.new(:second) ] end def first_term_grade term(:first).grade end def second_term_grade term(:second).grade end private def term reference @terms.find {|term| term.name == reference} end end class Grade attr_reader :name, :home_work, :test, :paper def initialize(name) @name = name @home_work = 0 @test = 0 @paper = 0 end def grade (home_work + test + paper) / 3 end end You can see that now Grade holds the logic for calculation of the grade and Student only stores the grades into a collection. Now this complies to the SRP, because, every class has it’s own responsibility.\nThe Open/closed principle (OCP) is a principle whose definition is:\n One software entity (class/module) must be open for extension but closed for modification.\n What does this mean? Once a class implements the current scope of requirements, the implementation should not need to change in order to fulfil future requirements.\nIt doesn’t make sense? Let’s take a look at a quick example.\nclass MyLogger def initialize @format_string = \"%s: %s\\n\" end def log(msg) STDOUT.write @format_string % [Time.now, msg] end end Simple logger class right? It has a format string and sends the current time and the message to STDOUT. Cool, simple enough. Lets test it:\nirb MyLogger.new.log('test!') = 2014-04-25 16:16:32 +0200: test! Awesome. But, what would happen if someone in the future needs the logger to prepend the string “[LOG]” to the log message, so the output would look like:\n[LOG] 2014-04-25 16:16:32 +0200: MyLogger calling! For example, a programmer that does not know about the OCP can possibly do this change:\nclass MyLogger def initialize @format_string = \"[LOG] %s: %s\\n\" end end And the output of the new MyLogger class would be:\nirb MyLogger.new.log('test!') = [LOG] 2014-04-25 16:16:32 +0200: test! Everything looks good, right? But, wait a second? Does it?\nThink about this - if this was a core class of an app, the change we introduced to the format_string would break the functionality of that classes that rely on the MyLogger class. There’s the possibility that a whole world out there relies on the former funcionality of the class, but now, that we changed it, a lot of things can break. This is a violation of the OCP and it is bad!\nSo, what is the good way to do it? Inheritance! Or object composition!\nLet’s see an example that uses inheritance:\nclass NewCoolLogger  MyLogger def initialize @format_string = \"[LOG] %s: %s\\n\" end end irb NewCoolLogger.new.log('test!') = [LOG] 2014-04-25 16:16:32 +0200: test! Nice, works as expected! What about the functionality of MyLogger?\nirb MyLogger.new.log('test!') = 2014-04-25 16:16:32 +0200: test! Great! So, what did we just do? We extended the MyLogger class and created a brand new class called NewCoolLogger that extends the former class. Now the code that relies on the functionality of the old logger will not break due to the changes we introduced. The old logger will work just like it did before and the new one will provide the new functionality that the programmer wanted.\nAlso, I mentioned object composition. Take this refactor in cosideration:\nclass MyLogger def log(msg, formatter: MyLogFormatter.new) STDOUT.write formatter.format(msg) end end You can notice that the log method receives an optional parameter called formatter. The format of the log string is responsibility of the MyLogFormatter class not the logger class itself. This is good because now MyLogger#log can accept different formatter classes that will set the format of the log message. For example, you can create ErrorLogFormatter that will prepend [ERROR] to the log message but MyLogger will not care because all it needs is a string that it will send to STDOUT.\nLiskov substitution principle Barbara Liskov defined the principle within these lines:\n If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).\n Honestly, I found this definition pretty hard to understand. So, after some thinking, this is what it boils down to:\nThere is a class Bird. And there are two objects, obj1 and obj2. The class of obj1 is Duck which is a child-class of Bird. Let’s say we discover that obj2’s class is Pigeon, which is also a child-class of Bird. Liskov substitution principle states that in this situation, when obj2 has a type of Bird sub-class and obj1 which is of class Duck which is also a sub-type of Bird, I should be able to treat obj1 and obj2 in the same way - as Birds.\nStill confusing? Take a look at the example below.\nclass Person def greet puts \"Hey there!\" end end class Student  Person def years_old(age) return \"I'm #{age}years old.\" end end person = Person.new student = Student.new # What LSP says is if I know the interface of person, I need to be able to # guess the interface of student because the Student class is a subtype of # the Person class. student.greet # returns \"Hey there!\" Hope that explained LSP.\nInterface segregation principle The interface-segregation principle (ISP) states that:\n No client should be forced to depend on methods it does not use.\n Simple as that. Lets see some code examples and explain them.\nclass Computer def turn_on # turns on the computer end def type # type on the keyboard end def change_hard_drive # opens the computer body # and changes the hard drive end end class Programmer def use_computer @computer.turn_on @computer.type end end class Technician def fix_computer @computer.change_hard_drive end end In this example, there are Computer, Programmer and Technician classes. Both, Programmer and Technician use the Computer in a different way. The programmer uses the computer for typing, but the technician knows how to change the computer hard drive. What Interface Segregation Principle (ISP) enforces is that one class should not depend on methods it does not use. In our case, Programmer is unnecessarily coupled to the Computer#change_hard_drive method because it does not use it, but the state changes that this method enforces can affect the Programmer. Let’s refactor the code to obey the LSP.\nclass Computer def turn_on end def type end end class ComputerInternals def change_hard_drive end end class Programmer def use_computer @computer.turn_on @computer.type end end class Technician def fix_computer @computer_internals.change_hard_drive end end After this refactor the Technician uses a different object from the type ComputerInternals which is isolated from the state of the Computer. The state of the Computer object can be influenced by the Programmer but the changes wont affect the Technician in any way.\nDependency inversion principle refers to a specific form of decoupling software modules. It’s definition has two parts:\n  High-level modules should not depend on low-level modules. Both should depend on abstractions.   Abstractions should not depend upon details. Details should depend upon abstractions.  I know that this might be a bit confusing. But, before we jump to a example I want to make sure that you must not mix Dependecy Inversion Principle with Dependency Injection. The later is a technique (or pattern) and the former is the principle.\nHaving that said, lets see the example:\nclass Report def initialize @body = \"whatever\" end def print XmlFormatter.new.generate @body end end class XmlFormatter def generate(body) # convert the body argument into XML end end The Report class is used to generate an XML report. In it’s initializer we setup the report and its body. The print method uses the XmlFormatter class to convert the body of the report to XML. Easy as that.\nLet’s think a bit about this class. Look at it’s name - Report. It’s a generic name and it tells us that it will return a report of some kind, but, it doesnt say much about it’s format. In fact, in our example, we can easily rename our class to XmlReport since we know the implementation details. But insead of making it very specific, let’s think about abstracting this code.\nRight now, our class is dependant on the XmlFormatter class and it’s interface i.e. generate. Report right now is dependent on a detail, not on abstraction. It knows that there must be a class XmlFormatter so it can work. Also, another question - what would happen if we wanted an CSV report? Or a JSON report? We’d have to have multiple methods like print_xml, print_csv or print_json. This means that our class right now is very tied to the details, it knows about the formatter class type instead of knowing just how to use it (abstraction).\nLet’s refactor it:\nclass Report def initialize @body = \"whatever\" end def print(formatter) formatter.generate @body end end class XmlFormatter def generate(body) # convert the body argument into XML end end Look at the print method now. It knows that it needs a formatter, but it only cares about it’s interface. To be more specific, it only cares that that formatter has a method called generate. How is this better? Well, if we wanted CSV reports, all we would need is to add the following class:\nclass CSVFormatter def generate(body) # convert the body argument into CSV end end The Report#print method would accept a CSVFormatter object as a parameter which would convert the report body into a CSV string.\nThat pretty much sums up all of the five SOLID principles. All of our refactoring examples are very basic and we just scratched the surface. I’m sure that in your carreer as a programmer you’d come on to much more complex problems. But, be assured that having SOLID foundations can definitely help you to write better code that is easier to maintain.\nLiked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to hundreds of other engineers.\n    ","wordCount":"1971","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija Eftimov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/solid-principles-ruby/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://www.getrevue.co/profile/itsilija title=Subscribe><span>Subscribe</span></a></li><li><a href=https://ieftimov.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles in Ruby</h1><div class=post-meta>June 5, 2014&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Ilija Eftimov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#so-what-are-the-solid-principles aria-label="So, what are the SOLID principles?">So, what are the SOLID principles?</a></li><li><a href=#liskov-substitution-principle aria-label="Liskov substitution principle">Liskov substitution principle</a></li><li><a href=#interface-segregation-principle aria-label="Interface segregation principle">Interface segregation principle</a></li></ul></div></details></div><div class=post-content><p>Regardless of your knowledge level, as a programmer you love to write awesome
code. It&rsquo;s what we do. We like it and we do it every single day. But, we all
know that writing awesome code is not easy at all. So, how can we improve the
code we produce every day?</p><p>An awareness (or a reminder!) of SOLID principles is beneficial here. SOLID is
a group of five principles that when <em>applied correctly</em> can help us produce
better code.</p><h4 id=so-what-are-the-solid-principles>So, what are the SOLID principles?<a hidden class=anchor aria-hidden=true href=#so-what-are-the-solid-principles>#</a></h4><p>SOLID is a mnemonic acronym coined by
<a href=http://en.wikipedia.org/wiki/Robert_C._Martin>Uncle Bob</a> back in the early
2000s. It represents a group of five principles:</p><ul><li><strong>S</strong>ingle Responsibility Principle</li><li><strong>O</strong>pen/Closed Principle</li><li><strong>L</strong>iskov Substitution Principle</li><li><strong>I</strong>nterface Segregation Principle</li><li><strong>D</strong>ependency Inversion Principle</li></ul><p>Sounds good? Great. Let&rsquo;s take a look at each of these principles.</p><p>In my opinion, this is the easiest principle to understand. What SRP says is:</p><blockquote><p>Every class should have a single responsibility, and that responsibility
should be entirely encapsulated by the class.</p></blockquote><p>What does this mean? Basically, every class in your app <strong>must</strong> have a single
responsibility. Easy as that. The best way to detect if your class obeys this
principle is to answer this question:</p><blockquote><p><strong>What does this class do?</strong></p></blockquote><p>If your answer contains the word <strong>AND</strong>, then your class does not obey the SRP.</p><p>Lets see a quick example. There&rsquo;s the Student class and every student has
grades for different terms.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>Student</span>
  <span style=color:#719e07>attr_accessor</span> <span style=color:#2aa198>:first_term_home_work</span>, <span style=color:#2aa198>:first_term_test</span>,
    <span style=color:#2aa198>:first_term_paper</span>
  <span style=color:#719e07>attr_accessor</span> <span style=color:#2aa198>:second_term_home_work</span>, <span style=color:#2aa198>:second_term_test</span>,
    <span style=color:#2aa198>:second_term_paper</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>first_term_grade</span>
    (first_term_home_work <span style=color:#719e07>+</span> first_term_test <span style=color:#719e07>+</span> first_term_paper) <span style=color:#719e07>/</span> <span style=color:#2aa198>3</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>second_term_grade</span>
    (second_term_home_work <span style=color:#719e07>+</span> second_term_test <span style=color:#719e07>+</span> second_term_paper) <span style=color:#719e07>/</span> <span style=color:#2aa198>3</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>Some of you may already be thinking &ldquo;that is wrong sir!&rdquo;, some of you may not.
Regardless of that, yes, this <strong>does not</strong> obey the SRP. The reason is that the
class Student contains the logic that calculates the average grade for each
term. The responsibility of <code>Student</code> is to hold info/logic about the
student, not the grades. The logic that calculates the grades should be part of
a class <code>Grade</code>, not <code>Student</code>.</p><p>Let&rsquo;s refactor the code.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>Student</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>
    @terms <span style=color:#719e07>=</span> <span style=color:#719e07>[</span>
      <span style=color:#cb4b16>Grade</span><span style=color:#719e07>.</span>new(<span style=color:#2aa198>:first</span>),
      <span style=color:#cb4b16>Grade</span><span style=color:#719e07>.</span>new(<span style=color:#2aa198>:second</span>)
      <span style=color:#719e07>]</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>first_term_grade</span>
    term(<span style=color:#2aa198>:first</span>)<span style=color:#719e07>.</span>grade
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>second_term_grade</span>
    term(<span style=color:#2aa198>:second</span>)<span style=color:#719e07>.</span>grade
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>private</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>term</span> reference
    @terms<span style=color:#719e07>.</span>find {<span style=color:#719e07>|</span>term<span style=color:#719e07>|</span> term<span style=color:#719e07>.</span>name <span style=color:#719e07>==</span> reference}
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>Grade</span>
  <span style=color:#719e07>attr_reader</span> <span style=color:#2aa198>:name</span>, <span style=color:#2aa198>:home_work</span>, <span style=color:#2aa198>:test</span>, <span style=color:#2aa198>:paper</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>(<span style=color:#b58900>name</span>)
    @name      <span style=color:#719e07>=</span> <span style=color:#b58900>name</span>
    @home_work <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>
    @test      <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>
    @paper     <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>grade</span>
    (home_work <span style=color:#719e07>+</span> <span style=color:#b58900>test</span> <span style=color:#719e07>+</span> paper) <span style=color:#719e07>/</span> <span style=color:#2aa198>3</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>You can see that now <code>Grade</code> holds the logic for calculation of the grade
and Student only stores the grades into a collection. Now this complies to the
SRP, because, every class has it&rsquo;s own responsibility.</p><p>The Open/closed principle (OCP) is a principle whose definition is:</p><blockquote><p>One software entity (class/module) must be open for extension but closed for modification.</p></blockquote><p>What does this mean? Once a class implements the current scope of requirements,
the implementation should not need to change in order to fulfil future
requirements.</p><p>It doesn&rsquo;t make sense? Let&rsquo;s take a look at a quick example.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>MyLogger</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>
    @format_string <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;%s: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>log</span>(msg)
    <span style=color:#cb4b16>STDOUT</span><span style=color:#719e07>.</span>write @format_string <span style=color:#719e07>%</span> <span style=color:#719e07>[</span><span style=color:#cb4b16>Time</span><span style=color:#719e07>.</span>now, msg<span style=color:#719e07>]</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>Simple logger class right? It has a format string and sends the current time
and the message to STDOUT. Cool, simple enough. Lets test it:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>irb&gt; MyLogger.new.log<span style=color:#719e07>(</span><span style=color:#2aa198>&#39;test!&#39;</span><span style=color:#719e07>)</span>
<span style=color:#719e07>=</span>&gt; 2014-04-25 16:16:32 +0200: test!</code></pre></div><p>Awesome. But, what would happen if someone in the future needs the logger to
prepend the string &ldquo;[LOG]&rdquo; to the log message, so the output would look like:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#719e07>[</span>LOG<span style=color:#719e07>]</span> 2014-04-25 16:16:32 +0200: MyLogger calling!</code></pre></div><p>For example, a programmer that does not know about the OCP can possibly do this
change:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>MyLogger</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>
    @format_string <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;[LOG] %s: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>And the output of the new MyLogger class would be:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>irb&gt; MyLogger.new.log<span style=color:#719e07>(</span><span style=color:#2aa198>&#39;test!&#39;</span><span style=color:#719e07>)</span>
<span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>LOG<span style=color:#719e07>]</span> 2014-04-25 16:16:32 +0200: test!</code></pre></div><p>Everything looks good, right? But, wait a second? Does it?</p><p>Think about this - if this was a core class of an app, the change we introduced
to the <code>format_string</code> would break the functionality of that classes that
rely on the <code>MyLogger</code> class. There&rsquo;s the possibility that a whole world
out there relies on the former funcionality of the class, but now, that we
changed it, a lot of things can break. This is a violation of the OCP and it is
<strong>bad</strong>!</p><p>So, what is the good way to do it? Inheritance! Or object composition!</p><p>Let&rsquo;s see an example that uses inheritance:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>NewCoolLogger</span> <span style=color:#719e07>&lt;</span> <span style=color:#cb4b16>MyLogger</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>
    @format_string <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;[LOG] %s: %s</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>irb&gt; NewCoolLogger.new.log<span style=color:#719e07>(</span><span style=color:#2aa198>&#39;test!&#39;</span><span style=color:#719e07>)</span>
<span style=color:#719e07>=</span>&gt; <span style=color:#719e07>[</span>LOG<span style=color:#719e07>]</span> 2014-04-25 16:16:32 +0200: test!</code></pre></div><p>Nice, works as expected! What about the functionality of <code>MyLogger</code>?</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>irb&gt; MyLogger.new.log<span style=color:#719e07>(</span><span style=color:#2aa198>&#39;test!&#39;</span><span style=color:#719e07>)</span>
<span style=color:#719e07>=</span>&gt; 2014-04-25 16:16:32 +0200: test!</code></pre></div><p>Great! So, what did we just do? We extended the <code>MyLogger</code> class and
created a brand new class called <code>NewCoolLogger</code> that extends the former
class. Now the code that relies on the functionality of the old logger will not
break due to the changes we introduced. The old logger will work just like it
did before and the new one will provide the new functionality that the
programmer wanted.</p><p>Also, I mentioned <em>object composition</em>. Take this refactor in cosideration:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>MyLogger</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>log</span>(msg, <span style=color:#2aa198>formatter</span>: <span style=color:#cb4b16>MyLogFormatter</span><span style=color:#719e07>.</span>new)
    <span style=color:#cb4b16>STDOUT</span><span style=color:#719e07>.</span>write formatter<span style=color:#719e07>.</span>format(msg)
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>You can notice that the log method receives an optional parameter called
<code>formatter</code>. The format of the log string is responsibility of the
<code>MyLogFormatter</code> class not the logger class itself. This is good because
now <code>MyLogger#log</code> can accept different formatter classes that will set the
format of the log message. For example, you can create <code>ErrorLogFormatter</code>
that will prepend <code>[ERROR]</code> to the log message but <code>MyLogger</code> will not
care because all it needs is a string that it will send to STDOUT.</p><h4 id=liskov-substitution-principle>Liskov substitution principle<a hidden class=anchor aria-hidden=true href=#liskov-substitution-principle>#</a></h4><p><a href=http://en.wikipedia.org/wiki/Barbara_Liskov>Barbara Liskov</a> defined the principle within these lines:</p><blockquote><p>If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).</p></blockquote><p>Honestly, I found this definition pretty hard to understand. So, after some
thinking, this is what it boils down to:</p><p>There is a class <code>Bird</code>. And there are two objects, <code>obj1</code> and
<code>obj2</code>. The class of <code>obj1</code> is <code>Duck</code> which is a child-class of
<code>Bird</code>. Let&rsquo;s say we discover that <code>obj2</code>&rsquo;s class is <code>Pigeon</code>,
which is also a child-class of <code>Bird</code>. Liskov substitution principle states
that in this situation, when <code>obj2</code> has a type of <code>Bird</code> sub-class and
<code>obj1</code> which is of class <code>Duck</code> which is also a sub-type of <code>Bird</code>,
I should be able to treat <code>obj1</code> and <code>obj2</code> in the same way - as
<code>Bird</code>s.</p><p>Still confusing? Take a look at the example below.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>Person</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>greet</span>
    <span style=color:#b58900>puts</span> <span style=color:#2aa198>&#34;Hey there!&#34;</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>Student</span> <span style=color:#719e07>&lt;</span> <span style=color:#cb4b16>Person</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>years_old</span>(age)
    <span style=color:#719e07>return</span> <span style=color:#2aa198>&#34;I&#39;m </span><span style=color:#2aa198>#{</span>age<span style=color:#2aa198>}</span><span style=color:#2aa198> years old.&#34;</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

person <span style=color:#719e07>=</span> <span style=color:#cb4b16>Person</span><span style=color:#719e07>.</span>new
student <span style=color:#719e07>=</span> <span style=color:#cb4b16>Student</span><span style=color:#719e07>.</span>new

<span style=color:#586e75># What LSP says is if I know the interface of person, I need to be able to</span>
<span style=color:#586e75># guess the interface of student because the Student class is a subtype of</span>
<span style=color:#586e75># the Person class.</span>
student<span style=color:#719e07>.</span>greet
<span style=color:#586e75># returns &#34;Hey there!&#34;</span></code></pre></div><p>Hope that explained LSP.</p><h4 id=interface-segregation-principle>Interface segregation principle<a hidden class=anchor aria-hidden=true href=#interface-segregation-principle>#</a></h4><p>The interface-segregation principle (ISP) states that:</p><blockquote><p>No client should be forced to depend on methods it does not use.</p></blockquote><p>Simple as that. Lets see some code examples and explain them.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>Computer</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>turn_on</span>
    <span style=color:#586e75># turns on the computer</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>type</span>
    <span style=color:#586e75># type on the keyboard</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>change_hard_drive</span>
    <span style=color:#586e75># opens the computer body</span>
    <span style=color:#586e75># and changes the hard drive</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>Programmer</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>use_computer</span>
    @computer<span style=color:#719e07>.</span>turn_on
    @computer<span style=color:#719e07>.</span>type
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>Technician</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>fix_computer</span>
    @computer<span style=color:#719e07>.</span>change_hard_drive
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>In this example, there are <code>Computer</code>, <code>Programmer</code> and
<code>Technician</code> classes. Both, <code>Programmer</code> and <code>Technician</code> use the
<code>Computer</code> in a different way. The programmer uses the computer for typing,
but the technician knows how to change the computer hard drive. What Interface
Segregation Principle (ISP) enforces is that one class should not depend on
methods it does not use.
In our case, <code>Programmer</code> is unnecessarily coupled to the
<code>Computer#change_hard_drive</code> method because it does not use it, but the
state changes that this method enforces can affect the <code>Programmer</code>. Let&rsquo;s
refactor the code to obey the LSP.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>Computer</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>turn_on</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>type</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>ComputerInternals</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>change_hard_drive</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>Programmer</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>use_computer</span>
    @computer<span style=color:#719e07>.</span>turn_on
    @computer<span style=color:#719e07>.</span>type
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>Technician</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>fix_computer</span>
    @computer_internals<span style=color:#719e07>.</span>change_hard_drive
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>After this refactor the <code>Technician</code> uses a different object from the type
<code>ComputerInternals</code> which is isolated from the state of the <code>Computer</code>.
The state of the <code>Computer</code> object can be influenced by the
<code>Programmer</code> but the changes wont affect the <code>Technician</code> in any way.</p><p>Dependency inversion principle refers to a specific form of decoupling software
modules. It&rsquo;s definition has two parts:</p><blockquote><ol><li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li></ol></blockquote><ol start=2><li>Abstractions should not depend upon details. Details should depend upon abstractions.</li></ol><p>I know that this might be a bit confusing. But, before we jump to a example I
want to make sure that you <strong>must not mix</strong> <em>Dependecy Inversion Principle</em>
with <em>Dependency Injection</em>. The later is a technique (or pattern) and the
former is the principle.</p><p>Having that said, lets see the example:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>Report</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>
    @body <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;whatever&#34;</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>print</span>
    <span style=color:#cb4b16>XmlFormatter</span><span style=color:#719e07>.</span>new<span style=color:#719e07>.</span>generate @body
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>XmlFormatter</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>generate</span>(body)
    <span style=color:#586e75># convert the body argument into XML</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>The <code>Report</code> class is used to generate an XML report. In it&rsquo;s initializer
we setup the report and its body. The <code>print</code> method uses the
<code>XmlFormatter</code> class to convert the body of the report to XML. Easy as
that.</p><p>Let&rsquo;s think a bit about this class. Look at it&rsquo;s name - <code>Report</code>. It&rsquo;s a
generic name and it tells us that it will return a report of some kind, but, it
doesnt say much about it&rsquo;s format. In fact, in our example, we can easily
rename our class to <code>XmlReport</code> since we know the implementation details.
But insead of making it very specific, let&rsquo;s think about abstracting this code.</p><p>Right now, our class is dependant on the <code>XmlFormatter</code> class and it&rsquo;s
interface i.e. <code>generate</code>. <code>Report</code> right now is dependent on a detail,
not on abstraction. It knows that there must be a class <code>XmlFormatter</code> so
it can work. Also, another question - what would happen if we wanted an CSV
report? Or a JSON report? We&rsquo;d have to have multiple methods like
<code>print_xml</code>, <code>print_csv</code> or <code>print_json</code>. This means that our class
right now is very tied to the details, it knows about the formatter class type
instead of knowing just how to use it (abstraction).</p><p>Let&rsquo;s refactor it:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>Report</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>
    @body <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;whatever&#34;</span>
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>def</span> <span style=color:#268bd2>print</span>(formatter)
    formatter<span style=color:#719e07>.</span>generate @body
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>

<span style=color:#719e07>class</span> <span style=color:#268bd2>XmlFormatter</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>generate</span>(body)
    <span style=color:#586e75># convert the body argument into XML</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>Look at the <code>print</code> method now. It knows that it needs a formatter, but it
only cares about it&rsquo;s interface. To be more specific, it only cares that that
formatter has a method called <code>generate</code>. How is this better? Well, if we
wanted CSV reports, all we would need is to add the following class:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#719e07>class</span> <span style=color:#268bd2>CSVFormatter</span>
  <span style=color:#719e07>def</span> <span style=color:#268bd2>generate</span>(body)
    <span style=color:#586e75># convert the body argument into CSV</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span></code></pre></div><p>The <code>Report#print</code> method would accept a <code>CSVFormatter</code> object as a
parameter which would convert the report body into a CSV string.</p><p>That pretty much sums up all of the five SOLID principles. All of our
refactoring examples are very basic and we just scratched the surface. I&rsquo;m sure
that in your carreer as a programmer you&rsquo;d come on to much more complex
problems. But, be assured that having <strong>SOLID</strong> foundations can definitely help
you to write better code that is easier to maintain.</p><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to hundreds of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/services/>services</a></li><li><a href=https://ieftimov.com/tags/provider/>provider</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/angularjs-services-part-1/><span class=title>« Prev Page</span><br><span>AngularJS Services Part 1: Provider</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share SOLID Principles in Ruby on twitter" href="https://twitter.com/intent/tweet/?text=SOLID%20Principles%20in%20Ruby&url=https%3a%2f%2fieftimov.com%2fpost%2fsolid-principles-ruby%2f&hashtags=services%2cprovider"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SOLID Principles in Ruby on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fsolid-principles-ruby%2f&title=SOLID%20Principles%20in%20Ruby&summary=SOLID%20Principles%20in%20Ruby&source=https%3a%2f%2fieftimov.com%2fpost%2fsolid-principles-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SOLID Principles in Ruby on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fsolid-principles-ruby%2f&title=SOLID%20Principles%20in%20Ruby"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SOLID Principles in Ruby on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fsolid-principles-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SOLID Principles in Ruby on whatsapp" href="https://api.whatsapp.com/send?text=SOLID%20Principles%20in%20Ruby%20-%20https%3a%2f%2fieftimov.com%2fpost%2fsolid-principles-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SOLID Principles in Ruby on telegram" href="https://telegram.me/share/url?text=SOLID%20Principles%20in%20Ruby&url=https%3a%2f%2fieftimov.com%2fpost%2fsolid-principles-ruby%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2022 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>