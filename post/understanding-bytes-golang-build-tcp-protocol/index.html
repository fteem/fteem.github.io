<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding bytes in Go by building a TCP protocol | Ilija Eftimov ⚡️</title><meta name=keywords content><meta name=description content="Learn everything you need to know to work with bytes and slices of bytes ([]byte) by building a chat TCP-based protocol."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/understanding-bytes-golang-build-tcp-protocol/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Understanding bytes in Go by building a TCP protocol"><meta property="og:description" content="Learn everything you need to know to work with bytes and slices of bytes ([]byte) by building a chat TCP-based protocol."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/understanding-bytes-golang-build-tcp-protocol/"><meta property="og:image" content="https://ieftimov.com/cards/understanding-bytes-golang-build-tcp-protocol.gif"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-02T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-02T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/understanding-bytes-golang-build-tcp-protocol.gif"><meta name=twitter:title content="Understanding bytes in Go by building a TCP protocol"><meta name=twitter:description content="Learn everything you need to know to work with bytes and slices of bytes ([]byte) by building a chat TCP-based protocol."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Understanding bytes in Go by building a TCP protocol","item":"https://ieftimov.com/post/understanding-bytes-golang-build-tcp-protocol/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding bytes in Go by building a TCP protocol","name":"Understanding bytes in Go by building a TCP protocol","description":"Learn everything you need to know to work with bytes and slices of bytes ([]byte) by building a chat TCP-based protocol.","keywords":[],"articleBody":"Some of my newsletter subscribers have asked me a few times what is the easiest way to think about byte slices, or using Go’s syntax: []byte. Folks that have experience with low-level languages, where working with bytes is widespread, usually do not have challenges comprehending what []byte means and how to use it.\nBut, if you come from a dynamic or a high-level language background, although everything we do ends up being a bunch of bytes, higher-level languages hide such details from us. Coming from a Ruby background, I sympathize with the folks that find this challenging.\nInspired by the conversations I had with these readers, I decided to try to help out. So, without beating around the bush – let’s explore how we can build a simple TCP-based application protocol. And thoroughly understand bytes in the process.\nStanding on shoulders of giants The protocol that we will be implementing will work on top of TCP, because:\n TCP is high level enough, so we don’t have to worry about too many low-level connection details Go has excellent TCP support through the net package The interfaces that the net packages provide allow us to play with bytes (and slices of bytes) TCP provides certain guarantees when it comes to data transfer, so we are left with less to worry about Standing on the shoulders of giants is more uncomplicated than reinventing the wheel  Now, because protocol design is no small feat, we will be implementing a very tiny and toyish protocol. I am by no means a protocol designer, so what we are going to be working on here is merely an example. But, if you have any experience with protocols, please do not hesitate to drop me a comment (or a message) and let me know what I got wrong.\nEnter SLCK Let us imagine that Slack, the omnipresent collaboration and communication app, wants to turn their chat design into an open internet protocol. Being an open internet protocol would allow anyone to create a Slack-compliant server by implementing the SLCK protocol and build their version of Slack.\nIn theory, having an open protocol would allow Slack to become distributed, with people hosting their Slack servers. If people would host their SLCK servers, the servers will communicate with a cluster (or inter-server) protocol. With a cluster protocol (between servers) and a client protocol (between client and server), two SLCK servers will have the ability to communicate between themselves and with clients.\nBut, a cluster protocol is not what we will explore here, as it is significantly more challenging to implement. That’s why we will focus only on the client SLCK protocol.\nNow, to make the client SLCK protocol production-ready would be a massive effort, and it is beyond what an article can cover. But, I believe that it’s a great example through which we can learn more about working with bytes.\nWithout further ado, let’s talk about SLCK.\nSLCK design SLCK is a text-based wire protocol, meaning that the data that travels on the wire is not binary, but just ASCII text. The advantage of text-based protocols is that a client can practically open a TCP connection to a server that implements the protocol and talk to it by sending ASCII characters.\nClients can connect to and communicate with a SLCK server through a TCP socket, using a set of commands and conventions that we will define next.\nProtocol conventions SLCK follows a few simple but important conventions:\n It has TLV (type-length-value) format It has a control line \u0026 a content line It uses carriage return (\\r\\n) as delimiter It contains a fixed list of subjects (tags) representing actions And as already mentioned, it uses ASCII encoded text on the wire  Or, if we put all of these conventions in combination, a SLCK message would look like:\nMSG #general 11\\r\\nHello World So, why an ASCII-encoded text-based wire protocol? Well, the advantage of such protocols is that once the specification (usually called spec) of the protocol is public, anyone can write an implementation. Thus, such a protocol can be the backbone on top of which an ecosystem can be born.\nMore practically, having a simple protocol makes it easy to work with it. We do not need fancy clients to talk to a server that implements SLCK. A connection through telnet would suffice, and the messages sent to the server can be written by anyone that understands the protocol specification, just by hand.\nProtocol commands (subjects and options) SLCK has a few different commands:\n   ID Sent by Description     REG Client Register as client   JOIN Client Join a channel   LEAVE Client Leave a channel   MSG Both Send or receive a message to/from entity (channel or user)   CHNS Client List available channels   USRS Client List users   OK Server Command acknowledgement   ERR Server Error    Let’s explore each of them:\nREG When a client connects to a server, they can register as a client using the REG command. It takes an identifier as an argument, which is the client’s username.\nSyntax:\nREG  where:\n handle: name of the user  JOIN When a client connects to a server, they can join a channel using the JOIN command. It takes an identifier as an argument, which is the channel ID.\nSyntax:\nJOIN  where:\n channel-id: ID of the channel  LEAVE Once a user has joined a channel, they can leave the channel using the LEAVE command, with the channel ID as argument.\nSyntax:\nLEAVE  where:\n channel-id: ID of the channel  Example 1: to leave the #general channel, the client can send:\nLEAVE #general MSG To send a message to a channel or a user, the client can use the MSG command, with the channel or user identifier as argument, followed with the body length and the body itself.\nSyntax:\nMSG  \\r\\n[payload] where:\n entity-id: the ID of the channel or user length: payload length payload: the message body  Example 1: send a Hello everyone! message to the #general channel:\nMSG #general 16\\r\\nHello everyone! Example 2: send a Hello! message to @jane:\nMSG @jane 4\\r\\nHey! CHNS To list all available channels, the client can send the CHNS message. The server will reply with the list of available channels.\nSyntax:\nCHNS USRS To list all users, the client can send the USRS message. The server will reply with the list of available users.\nSyntax:\nUSRS OK/ERR When the server receives a command, it can reply with OK or ERR.\nOK does not have any text after that, think of it as an HTTP 204.\nERR  is the format of the errors returned by the server to the client. No protocol errors result in the server closing the connection. That means that although an ERR has been returned, the server is still maintaining the connection with the client.\nExample 1: Protocol error due to bad username selected during registration:\nERR Username must begin with @ Example 2: Protocol error due to bad channel ID sent with JOIN:\nERR Channel ID must begin with # Implementing a server Now that we have the basics of the SLCK protocol in place, we can move on to the implementation. There are many ways to create the server, but as long as it implements the SLCK protocol correctly, the clients will not care about what happens under the hood of the server.\nIn continuation, I will explain my approach to building the SLCK TCP server, and while we are on it, we will learn lots about bytes and slices of bytes.\n(If you would like to jump ahead, the full code of the SLCK protocol server implementation can be found in this repo.)\nServer design The server design will have four different parts: a client (user), a channel (chat room), a command (from the client to the server), and a hub - the server that manages it all.\nLet’s take it from the most straightforward piece towards the most complicated.\nCommands Commands are what flows from the clients to the hub. Each received command from the user, such as REG, MSG, and the others, has to be appropriately parsed, validated, and handled.\nEach command is of type command. The type definition is as follows:\ntype command struct { id ID recipient string sender string body []byte } The four attributes of the type, including their explanation:\n id - the identification of the command, which can be one of the protocol commands. recipient - who/what is the receiver of the command. It can be a @user or a #channel. sender - the sender of the command, which is the @username of a user. body - the body of the command sent by the sender to the receiver.  The flow of commands will be: a client receives the wire-protocol message, parses it, and turns it in a command, that the client sends to the hub.\nAdditionally, the command also uses a type ID, which is an int type alias. We use ID so we can control the valid command types using a constants and an iota:\ntype ID int const ( REG ID = iota JOIN LEAVE MSG CHNS USRS ) Although the clients have to work with the raw strings that they receive from the network, internally in the server, we map the wire commands to their constant counterparts. This way, we establish strict control of all the command types, enforced by Go’s compiler. Using this approach, we assure that the id will always be a valid command type.\nChannels Channels in the SLCK protocol lingo are just chat rooms. It’s worth mentioning they have nothing in common with Go channels, except the name.\nA channel is just a type with two attributes:\ntype channel struct { name string clients map[*client]bool } The name of the channel is just a string that contains the unique name of the channel. The clients map is a set of *clients that are part of the channel at a given time. Having the list of clients available allows us to easily broadcast messages to all clients in the channel, such as:\nfunc (c *channel) broadcast(s string, m []byte) { msg := append([]byte(s), \": \"...) msg = append(msg, m...) msg = append(msg, '\\n') for cl := range c.clients { cl.conn.Write(msg) } } Which brings us to the client itself.\nClient A client is a wrapper around the TCP connection. It encapsulates all the functionality around accepting messages from the TCP connection, parsing the messages, validating their structure and content, and sending them for further processing and handling to the hub.\nLet’s look closer into the client type:\ntype client struct { conn net.Conn outbound chan command register chan *client deregister chan *client username string } The four attributes of the client type, in order:\n conn - the TCP connection itself (of type net.Conn) outbound - a send-only channel of type command. This channel will be the connection between the client and the hub, through which the client will send commands to the hub register - a send-only channel of type *client through which the client will let the hub know that it wants to register itself with the hub (a.k.a. the chat server) deregister - a send-only channel of type *client through which the client will let the hub know that the user has closed the socket, so the hub should deregister the client (by removing it from the clients map and from all channels) username - the username of the user (of type string) that is sitting behind the TCP connection  If this is a bit confusing, worry not. It will get more evident once you see the whole thing in action.\nNow, let’s move on to the client’s methods. Once we intantiate a client, it can listen for incoming messages over the TCP connection. To do that, the client has a method called read:\nfunc (c *client) read() error { for { msg, err := bufio.NewReader(c.conn).ReadBytes('\\n') if err == io.EOF { // Connection closed, deregister client \tc.deregister  c return nil } if err != nil { return err } c.handle(msg) } } read loops endlessly using a for loop, and accepts incoming messages from the conn attribute (the TCP connection). Once the message (msg) is received, it will pass it on to the handle method, which will process it.\nIn case the err returned is io.EOF, meaning the user can closed the connection, the client will send notify the hub through the deregister channel. The hub will remove the deregistered client from the clients map and from all of the channels that the client participated in.\nHandling bytes in handle using the bytes package Because of the protocol definition, we know the structure of the commands that the chat server might receive from the user. That’s what the client’s handle method does - it get the raw messages from the socket and parses the bytes to make meaning out of them.\nfunc (c *client) handle(message []byte) { cmd := bytes.ToUpper(bytes.TrimSpace(bytes.Split(message, []byte(\" \"))[0])) args := bytes.TrimSpace(bytes.TrimPrefix(message, cmd)) switch string(cmd) { case \"REG\": if err := c.reg(args); err != nil { c.err(err) } case \"JOIN\": if err := c.join(args); err != nil { c.err(err) } case \"LEAVE\": if err := c.leave(args); err != nil { c.err(err) } case \"MSG\": if err := c.msg(args); err != nil { c.err(err) } case \"CHNS\": c.chns() case \"USRS\": c.usrs() default: c.err(fmt.Errorf(\"Unknown command %s\", cmd)) } } Handling messages is where we get to see the slice of bytes ([]byte) type in action. So, what happens here? Let’s break it down.\nGiven that our SLCK protocol is a text-based wire protocol, the bytes that are flowing on the TCP connection are, in fact, plain ASCII text. Each byte (or octet, because a byte is eight bits) in the decimal number system has a value between 0 and 255 (2 to the power of 8). That means that each of the octets can contain any of the characters in the extended ASCII encoding. (Refer to this ASCII table to see all of the available characters.)\nHaving a text-based protocol allows us to easily convert each of the bytes that arrive through the TCP connection into a meaningful text. That’s why each byte in the []byte slice represents one character. Because each byte in the slice []byte is a character, converting a []byte in a string is as easy as: s := string(slice).\nAnd Go is good at handling bytes. For example, it has a bytes package which lets us work with []byte, instead of converting them into strings every time we want to work with bytes.\nGiven that all SLCK commands begin with a single word separated with space after it, we can simply take the first word from the []byte, upcase it and compare it with the valid keywords of the protocol. “But, how are we supposed to take a word from a slice of bytes?” you might ask. Since bytes are not words, we have to resort to either compare them byte-by-byte or use the built-in bytes package. To keep things simple, we will use the bytes package. (You can check this snippet to compare the two approaches.)\nIn the first line of the handle, method we take the first part of the received message, and we upcase it. Then, on the second line, we remove the first part from the rest of the message. The split allows us to have the command (cmd) and the rest of the command arguments (args) in separate variables.\ncmd := bytes.ToUpper(bytes.TrimSpace(bytes.Split(message, []byte(\" \"))[0])) args := bytes.TrimSpace(bytes.TrimPrefix(message, cmd)) After that, in the switch construct, we handle all of the different commands. For example, handling the REG command is done using the reg, and the err methods:\nfunc (c *client) reg(args []byte) error { u := bytes.TrimSpace(args) if u[0] != '@' { return fmt.Errorf(\"Username must begin with @\") } if len(u) == 0 { return fmt.Errorf(\"Username cannot be blank\") } c.username = string(u) c.register  c return nil } The reg method takes the args slice, and it removes any space bytes (using bytes.TrimSpace). Given that the second argument of the REG command is the @username of the user, it checks if the passed username begins with @ and if it’s blank. Once it does that, it converts the username to a string, and it assigns it to the client (c) itself. From then on, the client has an assigned username.\nAs a second step, it sends the client itself through the register channel. This channel is read by the hub (the chat server), which will do more validation of the username before it successfully registers the client.\nfunc (c *client) err(e error) { c.conn.Write([]byte(\"ERR \" + e.Error() + \"\\n\")) } The err func simply takes an error and sends its contents back to the user, using the underlying TCP connection of the client.\nWe will come back to the other commands and methods once we have thoroughly explored the chat server.\nThe hub The hub is the central entity that the clients connect and register with. The hub also manages the available channels (chat rooms), broadcasting messages to said channels, and relaying messages (private/direct messages) between clients.\nAll of the above functionality means that the hub is the central place of all communications, hence the name.\nFirst, let’s explore the hub type with all of its attributes:\ntype hub struct { channels map[string]*channel clients map[string]*client commands chan command deregistrations chan *client registrations chan *client } The attributes, and their explanations, in order:\n channels - a map of the channels (chat rooms), with the name of the channel as the key and the *channel as value clients - a map of the clients (connected users), with the username as the key and the *client as value commands - a channel of command that are flowing from the clients to the hub, that the hub will validate and execute deregistrations - a channel of *client through which a client deregisters itself, through which the hub will be informed that the user has closed the connection and it will clean up any references to that client registrations - a channel of *client through which new clients register themselves to the hub, through which the hub will accept the new client, validate their username and add them to the clients map  So, how does the hub function? It all begins with the run method:\nfunc (h *hub) run() { for { select { case client := h.registrations: h.register(client) case client := h.deregistrations: h.unregister(client) case cmd := h.commands: switch cmd.id { case JOIN: h.joinChannel(cmd.sender, cmd.recipient) case LEAVE: h.leaveChannel(cmd.sender, cmd.recipient) case MSG: h.message(cmd.sender, cmd.recipient, cmd.body) case USRS: h.listUsers(cmd.sender) case CHNS: h.listChannels(cmd.sender) default: // Freak out? \t} } } } When we establish a new hub instance (which we will see later), we execute the run method in a goroutine. The goroutine will run the for loop indefinitely, processing the registrations, deregistrations, and the commands channels. Messages arriving through the registrations and deregistrations channels will be handled differently from the messages that will come from the commands channel.\nrun will receive messages through the registrations channel, and it will send them to the register method for processing:\nfunc (h *hub) register(c *client) { if _, exists := h.clients[c.username]; exists { c.username = \"\" c.conn.Write([]byte(\"ERR username taken\\n\")) } else { h.clients[c.username] = c c.conn.Write([]byte(\"OK\\n\")) } } The register method will check if the hub already has a user with the given username, and it will react accordingly. If the username is taken, it will remove the username from the client and respond with an error. If the username is not taken, then it will add the client to the clients map, with the username as a key and the client reference as a value.\nrun will receive messages through the deregistrations channel, and it will send them to the deregister method for processing:\nfunc (h *hub) deregister(c *client) { if _, exists := h.clients[c.username]; exists { delete(h.clients, c.username) for _, channel := range h.channels { delete(channel.clients, c) } } } The deregister method will check if the hub already has a user with the given username. If it finds the user, it will remove it from the hub’s clients map. Also, it will go through the map of channels and it will try to remove it from each of the channel’s clients map.\nWhen it comes to handling commands, things are more different. Each of the commands, as we already established, has an id attribute. For each of the commands that we receive, we do a switch on the id attribute, which will invoke a different method. For example, to join a channel, the id must be of value JOIN, which will invoke the joinChannel function, with the command’s sender and recipient attributes.\nThe joinChannel function receives the username (u) and the channel (c) as arguments. Then, if it finds the channel, it will add the client to the channel’s clients map. Otherwise, it will first create the channel, using the newChannel constructor, and then add the client as the first client to the channel:\nfunc (h *hub) joinChannel(u string, c string) { if client, ok := h.clients[u]; ok { if channel, ok := h.channels[c]; ok { // Channel exists, join \tchannel.clients[client] = true } else { // Channel doesn't exists, create and join \th.channels[c] = newChannel(c) h.channels[c].clients[client] = true } } } Now, let’s zoom out and see how a client wraps a TCP connection. Then, we will see how bytes are flowing from the user, through the client, to the hub ending up with the receiver (another channel or user).\nSending messages The core functionality to a chat server and the purpose of our SLCK protocol is sending and receiving messages. Let’s follow the flow of the bytes and see how we can implement sending messages between clients.\nThe structure of the MSG command is as follows:\nMSG  \\r\\n[payload] For example, to send a Hello! message to the #general channel:\nMSG #general 6\\r\\nHello! Or, to send a Hey! message to @jane:\nMSG @jane 4\\r\\nHey! Once the user sends the MSG command, the client’s handle method accepts it. Then, in handle we extract the message and the command, and we invoke the msg method of the client:\nfunc (c *client) handle(message []byte) { cmd := bytes.ToUpper(bytes.TrimSpace(bytes.Split(message, []byte(\" \"))[0])) args := bytes.TrimSpace(bytes.TrimPrefix(message, cmd)) switch string(cmd) { // Some other stuff here... \tcase \"MSG\": if err := c.msg(args); err != nil { c.err(err) } // Some other stuff here... \tdefault: c.err(fmt.Errorf(\"Unknown command %s\", cmd)) } } The args are passed to the msg method, which does some heavy lifting.\nfunc (c *client) msg(args []byte) error { args = bytes.TrimSpace(args) if args[0] != '#' \u0026\u0026 args[0] != '@' { return fmt.Errorf(\"recipient must be a channel ('#name') or user ('@user')\") } recipient := bytes.Split(args, []byte(\" \"))[0] if len(recipient) == 0 { return fmt.Errorf(\"recipient must have a name\") } // More stuff here... } The msg method’s first step is to check if the first argument of the message begins with a @ or # – a user or a channel name. If that’s correct, we extract the recipient, which can be the username or the channel name.\nfunc (c *client) msg(args []byte) error { // The stuff from above here...  args = bytes.TrimSpace(bytes.TrimPrefix(args, recipient)) l := bytes.Split(args, DELIMITER)[0] length, err := strconv.Atoi(string(l)) if err != nil { return fmt.Errorf(\"body length must be present\") } if length == 0 { return fmt.Errorf(\"body length must be at least 1\") } padding := len(l) + len(DELIMITER) // Size of the body length + the delimiter \tbody := args[padding : padding+length] c.outbound  command{ recipient: string(recipient[1:]), sender: c.username, body: body, id: \"MSG\", } return nil } We extract the next argument after, which, according to the protocol specification, is the length of the body in bytes. Having the size of the body (the length of the bytes) as part of the command that is sent by the client allows the server to slice off the bytes it needs from the body efficiently.\nLet’s see an example:\nMSG #general 39\\r\\nHey folks, hope you are all doing well! In the handle method, we sliced off MSG, and we send the rest of the bytes to the msg method. In msg, we checked if the next argument is a channel or a username – which is correct. Then, we pick up the 39, and we store them in the l variable.\nHaving l being 39 is not enough – the slice of bytes that represent the ASCII 39 is [51 57]. The 51 and 57 bytes just mean that the two octets representing 3 and 9 in ASCII, have byte representation as 51 and 57. To make our Go code understand [51 57] like 39, we have to convert them into a string, so they become \"39\" and then use the strconv package to convert the string to an int:\nl := bytes.Split(args, DELIMITER)[0] length, err := strconv.Atoi(string(l)) Once we have the length of the body, we validate that it will be at least one byte. Next, we take the remaining bytes from the args, and we slice off the length amount of bytes from the args:\npadding := len(l) + len(DELIMITER) // Size of the body length + the delimiter body := args[padding : padding+length] In context of our example above:\nMSG #general 39\\r\\nHey folks, hope you are all doing well! we take the length (2) of the 39 plus the length of the \\r\\n delimiter and then take the body out of the args slice of bytes by using the “slice” operator (:). The slicing operation results in slicing all of the bytes between \\n to the end of the body, meaning the body becomes:\nHey folks, hope you are all doing well! If the length were less then 39, then the body would end up being shorter, because the user has sent the wrong body size to the server. Conversely, if we tried to slice off more than the size of the body, then the goroutine serving the hub would crash, rendering our server useless.\nGiven that body now contains the message itself, the last step of the msg method is to send the new command it received through the outbound channel to the hub:\nc.outbound  command{ recipient: string(recipient[1:]), sender: c.username, body: body, id: MSG, } The command has a recipient (channel or user ID), the sender, which is the username of the message author, the body containing the body of the message, and the id that’s the identifier of the command - MSG in this case.\nThen, the hub which infinitely loops and reads from the commands channel (which is the same channel as the outbound channel of the client), will pick up the message from the client and process it in the message method:\nfunc (h *hub) message(u string, r string, m []byte) { if sender, ok := h.clients[u]; ok { switch r[0] { case '#': if channel, ok := h.channels[r]; ok { if _, ok := channel.clients[sender]; ok { channel.broadcast(sender.username, m) } } case '@': if user, ok := h.clients[r]; ok { user.conn.Write(append(m, '\\n')) } } } } The message method will check if the sender username (u) is present in the list of active clients (h.clients). If the client is active, then it will check if the first byte of the message (m) is a # or a @. Based on the result of the switch, either it will broadcast the message (m) to the channel, or it will find the recipient (r) from the h.clients list and send the message through the recipient’s TCP connection.\nLet’s see this in action. I will start the server (using go run .) and open two telnet sessions with the server:\n$ telnet 127.0.0.1 8081 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. Given that SCLK is a ASCII wire protocol, it means we can just send some commands to the server right away. Let’s first register both clients. The first one will be @jane:\nREG @jane OK And the second client will be @john:\nREG @john OK In both cases the registration with the server went well, so the server replied with OK. Now, let’s make both of the clients join the #general channel. If any of the users listed the channels they would get an error:\nCHNS ERR no channels found Great, let’s make them both join #general, so the channel would be created. First @john:\nJOIN #general OK @jane righ after:\nCHNS #general JOIN #general OK Now that both are in the channel, we can also send a message from @jane to #general, and it should pop up on @john’s screen too.\nSending the message:\nMSG #general 5\\r\\nHello And in @john’s screen we can see:\njane: Hello Voilá! @john received the message. Let’s say @john would like to send @jane a direct message. He sends:\nMSG @jane 3\\r\\nHey And on @jane’s screen she will see:\n@john: Hey Tying it all together Now that we went through the client, hub, channel, and command, we need to see the last piece of the puzzle - the main function that ties it all together.\nIn the main func, we will initialize a TCP listener, through which we can accept a new TCP connection. Then, we will establish a new hub and invoke run in a separate goroutine.\nOnce the hub is running, we will infinitely loop using a for. Within the for loop, we will accept new TCP connections, wrap them in a new client and spin them off in a new goroutine.\npackage main import ( \"log\" \"net\" ) func main() { ln, err := net.Listen(\"tcp\", \":8081\") if err != nil { log.Printf(\"%v\", err) } hub := newHub() go hub.run() for { conn, err := ln.Accept() if err != nil { log.Printf(\"%v\", err) } c := newClient( conn, hub.commands, hub.registrations, hub.deregistrations, ) go c.read() } } As a refresher, within the read function of the client, we also infinitely loop using a for and accept new incoming TCP messages:\nfunc (c *client) read() error { for { msg, err := bufio.NewReader(c.conn).ReadBytes('\\n') if err == io.EOF { // Connection closed, deregister client \tc.deregister  c return nil } if err != nil { return err } c.handle(msg) } return nil } Having the client’s read method being run a separate goroutine allows us to spin off as many goroutines as we have connections. That leaves our main thread to accept new connections and just spin the off into goroutines. Once the goroutine is running, it will take care of itself until it crashes or the client exits.\nThe pitfall of this approach is that we have a single hub instance, which means that there’s only one goroutine that is accepting messages from what can be thousands of clients. While having a single hub instance simplifies the design, it also introduces a single point of failure. If the hub.run goroutine crashes/exits for whatever reason, the server will be rendered useless, although all of the client connections will be working fine.\nThe full code of the SLCK protocol server implementation can be found in this repo.\nNotable shortcuts Before we wrap up here, I would like to highlight a few of the shortcuts we took while building this server implementation. Cutting these corners was with a purpose - not making this long article even longer.\nFirst, we are missing resource locking when creating the channels or when a user joins/leaves a channel. If multiple people would join the same channel at the same time, it is possible to get a concurrent writes issue.\nSecond, our server does not have a graceful shutdown. A production-ready implementation would gracefully shut down all of the connections, informing the clients about the shutdown. Then, it would potentially save some state on disk before shutting down.\nAnother shortcut we took was validation of the body size in the msg method. When we are performing the slicing of the message body, we do not take into consideration if there are enough bytes in the message. If a client sends a body size larger then the body itself, we might slice off more bytes than available, which would result in a panic and a slice out of bounds error.\nIf you would like to play more with our chat server, I recommend starting with adding each of these missing functionalities to it. And drop me the link to the repo in the comments, so I can see how you pulled it off.\n Changelog:\n 2020-04-04 10:10UTC - Fixed the client type definition, which was missing the deregister channel, as pointed out by Rene C. over email.  Liked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to +1000 of other engineers.\n    ","wordCount":"5457","inLanguage":"en","datePublished":"2020-04-02T00:00:00Z","dateModified":"2020-04-02T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/understanding-bytes-golang-build-tcp-protocol/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Understanding bytes in Go by building a TCP protocol</h1><div class=post-description>Learn everything you need to know to work with bytes and slices of bytes ([]byte) by building a chat TCP-based protocol.</div><div class=post-meta>April 2, 2020&nbsp;·&nbsp;26 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#standing-on-shoulders-of-giants aria-label="Standing on shoulders of giants">Standing on shoulders of giants</a></li><li><a href=#enter-slck aria-label="Enter SLCK">Enter SLCK</a><ul><li><a href=#slck-design aria-label="SLCK design">SLCK design</a><ul><li><a href=#protocol-conventions aria-label="Protocol conventions">Protocol conventions</a></li><li><a href=#protocol-commands-subjects-and-options aria-label="Protocol commands (subjects and options)">Protocol commands (subjects and options)</a></li><li><a href=#reg aria-label=REG>REG</a></li><li><a href=#join aria-label=JOIN>JOIN</a></li><li><a href=#leave aria-label=LEAVE>LEAVE</a></li><li><a href=#msg aria-label=MSG>MSG</a></li><li><a href=#chns aria-label=CHNS>CHNS</a></li><li><a href=#usrs aria-label=USRS>USRS</a></li><li><a href=#okerr aria-label=OK/ERR>OK/ERR</a></li></ul></li></ul></li><li><a href=#implementing-a-server aria-label="Implementing a server">Implementing a server</a><ul><li><a href=#server-design aria-label="Server design">Server design</a></li><li><a href=#commands aria-label=Commands>Commands</a></li><li><a href=#channels aria-label=Channels>Channels</a></li><li><a href=#client aria-label=Client>Client</a></li><li><a href=#handling-bytes-in-handle-using-the-bytes-package aria-label="Handling bytes in handle using the bytes package">Handling bytes in <code>handle</code> using the <code>bytes</code> package</a></li><li><a href=#the-hub aria-label="The hub">The hub</a></li><li><a href=#sending-messages aria-label="Sending messages">Sending messages</a></li></ul></li><li><a href=#tying-it-all-together aria-label="Tying it all together">Tying it all together</a></li><li><a href=#notable-shortcuts aria-label="Notable shortcuts">Notable shortcuts</a></li></ul></div></details></div><div class=post-content><p>Some of <a href=/newsletter>my newsletter</a> subscribers have asked me a few times what
is the easiest way to think about <code>byte</code> slices, or using Go&rsquo;s syntax:
<code>[]byte</code>. Folks that have experience with low-level languages, where working
with bytes is widespread, usually do not have challenges comprehending what
<code>[]byte</code> means and how to use it.</p><p>But, if you come from a dynamic or a high-level language background, although
everything we do ends up being a bunch of bytes, higher-level languages hide
such details from us. Coming from a Ruby background, I sympathize with the
folks that find this challenging.</p><p>Inspired by the conversations I had with these readers, I decided to try to
help out. So, without beating around the bush – let&rsquo;s explore how we can build
a simple TCP-based application protocol. And thoroughly understand bytes in the
process.</p><h2 id=standing-on-shoulders-of-giants>Standing on shoulders of giants<a hidden class=anchor aria-hidden=true href=#standing-on-shoulders-of-giants>#</a></h2><p>The protocol that we will be implementing will work on top of TCP, because:</p><ol><li>TCP is high level enough, so we don&rsquo;t have to worry about too many low-level
connection details</li><li>Go has excellent TCP support through the <code>net</code> package</li><li>The interfaces that the <code>net</code> packages provide allow us to play with bytes
(and slices of bytes)</li><li>TCP provides <a href=https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Data_transfer>certain
guarantees</a>
when it comes to data transfer, so we are left with less to worry about</li><li>Standing on the shoulders of giants is more uncomplicated than reinventing
the wheel</li></ol><p>Now, because protocol design is no small feat, we will be implementing a very
tiny and toyish protocol. I am by no means a protocol designer, so what we are
going to be working on here is merely an example. But, if you have any
experience with protocols, please do not hesitate to drop me a comment (or a
message) and let me know what I got wrong.</p><h2 id=enter-slck>Enter SLCK<a hidden class=anchor aria-hidden=true href=#enter-slck>#</a></h2><p>Let us imagine that <a href=https://slack.com>Slack</a>, the omnipresent collaboration
and communication app, wants to turn their chat design into an open internet
protocol. Being an open internet protocol would allow anyone to create a
Slack-compliant server by implementing the SLCK protocol and build their
version of Slack.</p><p>In theory, having an open protocol would allow Slack to become distributed,
with people hosting their Slack servers. If people would host their SLCK
servers, the servers will communicate with a cluster (or inter-server)
protocol. With a cluster protocol (between servers) and a client protocol
(between client and server), two SLCK servers will have the ability to
communicate between themselves and with clients.</p><p>But, a cluster protocol is not what we will explore here, as it is
significantly more challenging to implement. That&rsquo;s why we will focus only on
the client SLCK protocol.</p><p>Now, to make the client SLCK protocol production-ready would be a massive
effort, and it is beyond what an article can cover. But, I believe that it&rsquo;s a
great example through which we can learn more about working with bytes.</p><p>Without further ado, let&rsquo;s talk about <code>SLCK</code>.</p><h3 id=slck-design>SLCK design<a hidden class=anchor aria-hidden=true href=#slck-design>#</a></h3><p>SLCK is a text-based wire protocol, meaning that the data that travels on the
wire is not binary, but just ASCII text. The advantage of text-based protocols
is that a client can practically open a TCP connection to a server that
implements the protocol and talk to it by sending ASCII characters.</p><p>Clients can connect to and communicate with a SLCK server through a TCP socket,
using a set of commands and conventions that we will define next.</p><h4 id=protocol-conventions>Protocol conventions<a hidden class=anchor aria-hidden=true href=#protocol-conventions>#</a></h4><p>SLCK follows a few simple but important conventions:</p><ul><li>It has <a href=https://en.wikipedia.org/wiki/Type-length-value>TLV (type-length-value)
format</a></li><li>It has a control line & a content line</li><li>It uses carriage return (<code>\r\n</code>) as delimiter</li><li>It contains a fixed list of subjects (tags) representing actions</li><li>And as already mentioned, it uses ASCII encoded text on the wire</li></ul><p>Or, if we put all of these conventions in combination, a SLCK message would
look like:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>MSG #general 11\r\nHello World
</code></pre></div><p>So, why an ASCII-encoded text-based wire protocol? Well, the advantage of such
protocols is that once the specification (usually called spec) of the protocol
is public, anyone can write an implementation. Thus, such a protocol can be the
backbone on top of which an ecosystem can be born.</p><p>More practically, having a simple protocol makes it easy to work with it. We do
not need fancy clients to talk to a server that implements SLCK. A connection
through <code>telnet</code> would suffice, and the messages sent to the server can be
written by anyone that understands the protocol specification, just by hand.</p><h4 id=protocol-commands-subjects-and-options>Protocol commands (subjects and options)<a hidden class=anchor aria-hidden=true href=#protocol-commands-subjects-and-options>#</a></h4><p>SLCK has a few different commands:</p><table><thead><tr><th style=text-align:left>ID</th><th style=text-align:left>Sent by</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>REG</code></td><td style=text-align:left>Client</td><td style=text-align:left>Register as client</td></tr><tr><td style=text-align:left><code>JOIN</code></td><td style=text-align:left>Client</td><td style=text-align:left>Join a channel</td></tr><tr><td style=text-align:left><code>LEAVE</code></td><td style=text-align:left>Client</td><td style=text-align:left>Leave a channel</td></tr><tr><td style=text-align:left><code>MSG</code></td><td style=text-align:left>Both</td><td style=text-align:left>Send or receive a message to/from entity (channel or user)</td></tr><tr><td style=text-align:left><code>CHNS</code></td><td style=text-align:left>Client</td><td style=text-align:left>List available channels</td></tr><tr><td style=text-align:left><code>USRS</code></td><td style=text-align:left>Client</td><td style=text-align:left>List users</td></tr><tr><td style=text-align:left><code>OK</code></td><td style=text-align:left>Server</td><td style=text-align:left>Command acknowledgement</td></tr><tr><td style=text-align:left><code>ERR</code></td><td style=text-align:left>Server</td><td style=text-align:left>Error</td></tr></tbody></table><p>Let&rsquo;s explore each of them:</p><h4 id=reg>REG<a hidden class=anchor aria-hidden=true href=#reg>#</a></h4><p>When a client connects to a server, they can register as a client using the
<code>REG</code> command. It takes an identifier as an argument, which is the client&rsquo;s
username.</p><p>Syntax:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>REG &lt;handle&gt;
</code></pre></div><p>where:</p><ul><li><code>handle</code>: name of the user</li></ul><h4 id=join>JOIN<a hidden class=anchor aria-hidden=true href=#join>#</a></h4><p>When a client connects to a server, they can join a channel using the <code>JOIN</code>
command. It takes an identifier as an argument, which is the channel ID.</p><p>Syntax:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>JOIN &lt;channel-id&gt;
</code></pre></div><p>where:</p><ul><li><code>channel-id</code>: ID of the channel</li></ul><h4 id=leave>LEAVE<a hidden class=anchor aria-hidden=true href=#leave>#</a></h4><p>Once a user has joined a channel, they can leave the channel using the <code>LEAVE</code>
command, with the channel ID as argument.</p><p>Syntax:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>LEAVE &lt;channel-id&gt;
</code></pre></div><p>where:</p><ul><li><code>channel-id</code>: ID of the channel</li></ul><p><strong>Example 1:</strong> to leave the <code>#general</code> channel, the client can send:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>LEAVE #general
</code></pre></div><h4 id=msg>MSG<a hidden class=anchor aria-hidden=true href=#msg>#</a></h4><p>To send a message to a channel or a user, the client can use the <code>MSG</code> command,
with the channel or user identifier as argument, followed with the body length
and the body itself.</p><p>Syntax:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>MSG &lt;entity-id&gt; &lt;length&gt;\r\n[payload]
</code></pre></div><p>where:</p><ul><li><code>entity-id</code>: the ID of the channel or user</li><li><code>length</code>: payload length</li><li><code>payload</code>: the message body</li></ul><p><strong>Example 1:</strong> send a <code>Hello everyone!</code> message to the <code>#general</code> channel:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>MSG #general 16\r\nHello everyone!
</code></pre></div><p><strong>Example 2:</strong> send a <code>Hello!</code> message to <code>@jane</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>MSG @jane 4\r\nHey!
</code></pre></div><h4 id=chns>CHNS<a hidden class=anchor aria-hidden=true href=#chns>#</a></h4><p>To list all available channels, the client can send the <code>CHNS</code> message. The
server will reply with the list of available channels.</p><p>Syntax:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>CHNS
</code></pre></div><h4 id=usrs>USRS<a hidden class=anchor aria-hidden=true href=#usrs>#</a></h4><p>To list all users, the client can send the <code>USRS</code> message. The server will
reply with the list of available users.</p><p>Syntax:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>USRS
</code></pre></div><h4 id=okerr>OK/ERR<a hidden class=anchor aria-hidden=true href=#okerr>#</a></h4><p>When the server receives a command, it can reply with <code>OK</code> or <code>ERR</code>.</p><p><code>OK</code> does not have any text after that, think of it as an <code>HTTP 204</code>.</p><p><code>ERR &lt;error-message></code> is the format of the errors returned by the server to the
client. No protocol errors result in the server closing the connection. That
means that although an <code>ERR</code> has been returned, the server is still maintaining
the connection with the client.</p><p><strong>Example 1:</strong> Protocol error due to bad username selected during registration:</p><pre><code>ERR Username must begin with @
</code></pre><p><strong>Example 2:</strong> Protocol error due to bad channel ID sent with <code>JOIN</code>:</p><pre><code>ERR Channel ID must begin with #
</code></pre><h2 id=implementing-a-server>Implementing a server<a hidden class=anchor aria-hidden=true href=#implementing-a-server>#</a></h2><p>Now that we have the basics of the SLCK protocol in place, we can move on to
the implementation. There are many ways to create the server, but as long as it
implements the SLCK protocol correctly, the clients will not care about what
happens under the hood of the server.</p><p>In continuation, I will explain my approach to building the SLCK TCP server,
and while we are on it, we will learn lots about bytes and slices of bytes.</p><p>(If you would like to jump ahead, the full code of the SLCK protocol server
implementation can be found in <a href=https://github.com/fteem/go-playground/tree/master/slck-protocol>this
repo</a>.)</p><h3 id=server-design>Server design<a hidden class=anchor aria-hidden=true href=#server-design>#</a></h3><p>The server design will have four different parts: a client (user), a channel
(chat room), a command (from the client to the server), and a hub - the server
that manages it all.</p><p>Let&rsquo;s take it from the most straightforward piece towards the most complicated.</p><h3 id=commands>Commands<a hidden class=anchor aria-hidden=true href=#commands>#</a></h3><p>Commands are what flows from the clients to the hub. Each received command from
the user, such as <code>REG</code>, <code>MSG</code>, and the others, has to be appropriately parsed,
validated, and handled.</p><p>Each command is of type <code>command</code>. The type definition is as follows:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> command <span style=color:#268bd2>struct</span> {
	id        ID
	recipient <span style=color:#dc322f>string</span>
	sender    <span style=color:#dc322f>string</span>
	body      []<span style=color:#dc322f>byte</span>
}
</code></pre></div><p>The four attributes of the type, including their explanation:</p><ul><li><code>id</code> - the identification of the <code>command</code>, which can be one of the protocol
commands.</li><li><code>recipient</code> - who/what is the receiver of the command. It can be a <code>@user</code> or
a <code>#channel</code>.</li><li><code>sender</code> - the sender of the command, which is the <code>@username</code> of a user.</li><li><code>body</code> - the body of the command sent by the sender to the receiver.</li></ul><p>The flow of <code>command</code>s will be: a <code>client</code> receives the wire-protocol message,
parses it, and turns it in a <code>command</code>, that the <code>client</code> sends to the <code>hub</code>.</p><p>Additionally, the <code>command</code> also uses a type <code>ID</code>, which is an <code>int</code> type
alias. We use <code>ID</code> so we can control the valid command types using a constants
and an <code>iota</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> ID <span style=color:#dc322f>int</span>

<span style=color:#268bd2>const</span> (
	REG ID = <span style=color:#cb4b16>iota</span>
	JOIN
	LEAVE
	MSG
	CHNS
	USRS
)
</code></pre></div><p>Although the <code>client</code>s have to work with the raw strings that they receive from
the network, internally in the server, we map the wire commands to their
constant counterparts. This way, we establish strict control of all the command
types, enforced by Go&rsquo;s compiler. Using this approach, we assure that the <code>id</code>
will always be a valid command type.</p><h3 id=channels>Channels<a hidden class=anchor aria-hidden=true href=#channels>#</a></h3><p>Channels in the <code>SLCK</code> protocol lingo are just chat rooms. It&rsquo;s worth
mentioning they have nothing in common with Go channels, except the name.</p><p>A <code>channel</code> is just a <code>type</code> with two attributes:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> channel <span style=color:#268bd2>struct</span> {
	name    <span style=color:#dc322f>string</span>
	clients <span style=color:#268bd2>map</span>[<span style=color:#719e07>*</span>client]<span style=color:#dc322f>bool</span>
}
</code></pre></div><p>The <code>name</code> of the channel is just a <code>string</code> that contains the unique name of
the channel. The <code>clients</code> map is a set of <code>*client</code>s that are part of the
channel at a given time. Having the list of clients available allows us to
easily broadcast messages to all clients in the channel, such as:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>channel) <span style=color:#268bd2>broadcast</span>(s <span style=color:#dc322f>string</span>, m []<span style=color:#dc322f>byte</span>) {
	msg <span style=color:#719e07>:=</span> <span style=color:#b58900>append</span>([]<span style=color:#b58900>byte</span>(s), <span style=color:#2aa198>&#34;: &#34;</span><span style=color:#719e07>...</span>)
	msg = <span style=color:#b58900>append</span>(msg, m<span style=color:#719e07>...</span>)
	msg = <span style=color:#b58900>append</span>(msg, <span style=color:#2aa198>&#39;\n&#39;</span>)

	<span style=color:#719e07>for</span> cl <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> c.clients {
		cl.conn.<span style=color:#268bd2>Write</span>(msg)
	}
}
</code></pre></div><p>Which brings us to the <code>client</code> itself.</p><h3 id=client>Client<a hidden class=anchor aria-hidden=true href=#client>#</a></h3><p>A <code>client</code> is a wrapper around the TCP connection. It encapsulates all the
functionality around accepting messages from the TCP connection, parsing the
messages, validating their structure and content, and sending them for further
processing and handling to the <code>hub</code>.</p><p>Let&rsquo;s look closer into the <code>client</code> type:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> client <span style=color:#268bd2>struct</span> {
	conn       net.Conn
	outbound   <span style=color:#268bd2>chan</span><span style=color:#719e07>&lt;-</span> command
	register   <span style=color:#268bd2>chan</span><span style=color:#719e07>&lt;-</span> <span style=color:#719e07>*</span>client
	deregister <span style=color:#268bd2>chan</span><span style=color:#719e07>&lt;-</span> <span style=color:#719e07>*</span>client
	username   <span style=color:#dc322f>string</span>
}
</code></pre></div><p>The four attributes of the <code>client</code> type, in order:</p><ul><li><code>conn</code> - the TCP connection itself (of type
<a href=https://golang.org/pkg/net/#Conn><code>net.Conn</code></a>)</li><li><code>outbound</code> - a send-only channel of type <code>command</code>. This channel will be the
connection between the <code>client</code> and the <code>hub</code>, through which the <code>client</code>
will send <code>command</code>s to the <code>hub</code></li><li><code>register</code> - a send-only channel of type <code>*client</code> through which the client
will let the <code>hub</code> know that it wants to register itself with the <code>hub</code>
(a.k.a. the chat server)</li><li><code>deregister</code> - a send-only channel of type <code>*client</code> through which the client
will let the <code>hub</code> know that the user has closed the socket, so the <code>hub</code>
should deregister the client (by removing it from the clients <code>map</code> and from
all channels)</li><li><code>username</code> - the username of the user (of type <code>string</code>) that is sitting
behind the TCP connection</li></ul><p>If this is a bit confusing, worry not. It will get more evident once you see
the whole thing in action.</p><p>Now, let&rsquo;s move on to the <code>client</code>&rsquo;s methods. Once we intantiate a <code>client</code>, it
can listen for incoming messages over the TCP connection. To do that, the
<code>client</code> has a method called <code>read</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>read</span>() <span style=color:#dc322f>error</span> {
	<span style=color:#719e07>for</span> {
		msg, err <span style=color:#719e07>:=</span> bufio.<span style=color:#268bd2>NewReader</span>(c.conn).<span style=color:#268bd2>ReadBytes</span>(<span style=color:#2aa198>&#39;\n&#39;</span>)
		<span style=color:#719e07>if</span> err <span style=color:#719e07>==</span> io.EOF {
			<span style=color:#586e75>// Connection closed, deregister client
</span><span style=color:#586e75></span>			c.deregister <span style=color:#719e07>&lt;-</span> c
			<span style=color:#719e07>return</span> <span style=color:#cb4b16>nil</span>
		}
		<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			<span style=color:#719e07>return</span> err
		}

		c.<span style=color:#268bd2>handle</span>(msg)
	}
}
</code></pre></div><p><code>read</code> loops endlessly using a <code>for</code> loop, and accepts incoming messages from
the <code>conn</code> attribute (the TCP connection). Once the message (<code>msg</code>) is
received, it will pass it on to the <code>handle</code> method, which will process it.</p><p>In case the <code>err</code> returned is <code>io.EOF</code>, meaning the user can closed the
connection, the <code>client</code> will send notify the <code>hub</code> through the <code>deregister</code>
channel. The <code>hub</code> will remove the deregistered client from the <code>clients</code> map
and from all of the channels that the <code>client</code> participated in.</p><h3 id=handling-bytes-in-handle-using-the-bytes-package>Handling bytes in <code>handle</code> using the <code>bytes</code> package<a hidden class=anchor aria-hidden=true href=#handling-bytes-in-handle-using-the-bytes-package>#</a></h3><p>Because of the protocol definition, we know the structure of the commands that
the chat server might receive from the user. That&rsquo;s what the <code>client</code>&rsquo;s
<code>handle</code> method does - it get the raw messages from the socket and parses the
bytes to make meaning out of them.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>handle</span>(message []<span style=color:#dc322f>byte</span>) {
	cmd <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>ToUpper</span>(bytes.<span style=color:#268bd2>TrimSpace</span>(bytes.<span style=color:#268bd2>Split</span>(message, []<span style=color:#b58900>byte</span>(<span style=color:#2aa198>&#34; &#34;</span>))[<span style=color:#2aa198>0</span>]))
	args <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>TrimSpace</span>(bytes.<span style=color:#268bd2>TrimPrefix</span>(message, cmd))

	<span style=color:#719e07>switch</span> <span style=color:#b58900>string</span>(cmd) {
	<span style=color:#719e07>case</span> <span style=color:#2aa198>&#34;REG&#34;</span>:
		<span style=color:#719e07>if</span> err <span style=color:#719e07>:=</span> c.<span style=color:#268bd2>reg</span>(args); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			c.<span style=color:#268bd2>err</span>(err)
		}
	<span style=color:#719e07>case</span> <span style=color:#2aa198>&#34;JOIN&#34;</span>:
		<span style=color:#719e07>if</span> err <span style=color:#719e07>:=</span> c.<span style=color:#268bd2>join</span>(args); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			c.<span style=color:#268bd2>err</span>(err)
		}
	<span style=color:#719e07>case</span> <span style=color:#2aa198>&#34;LEAVE&#34;</span>:
		<span style=color:#719e07>if</span> err <span style=color:#719e07>:=</span> c.<span style=color:#268bd2>leave</span>(args); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			c.<span style=color:#268bd2>err</span>(err)
		}
	<span style=color:#719e07>case</span> <span style=color:#2aa198>&#34;MSG&#34;</span>:
		<span style=color:#719e07>if</span> err <span style=color:#719e07>:=</span> c.<span style=color:#268bd2>msg</span>(args); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			c.<span style=color:#268bd2>err</span>(err)
		}
	<span style=color:#719e07>case</span> <span style=color:#2aa198>&#34;CHNS&#34;</span>:
		c.<span style=color:#268bd2>chns</span>()
	<span style=color:#719e07>case</span> <span style=color:#2aa198>&#34;USRS&#34;</span>:
		c.<span style=color:#268bd2>usrs</span>()
	<span style=color:#719e07>default</span>:
		c.<span style=color:#268bd2>err</span>(fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Unknown command %s&#34;</span>, cmd))
	}
}
</code></pre></div><p>Handling messages is where we get to see the slice of bytes (<code>[]byte</code>) type in
action. So, what happens here? Let&rsquo;s break it down.</p><p>Given that our SLCK protocol is a text-based wire protocol, the bytes that are
flowing on the TCP connection are, in fact, plain ASCII text. Each byte (or
octet, because a byte is eight bits) in the decimal number system has a value
between 0 and 255 (2 to the power of 8). That means that each of the octets can
contain any of the characters in the extended ASCII encoding. (Refer to <a href=https://www.asciitable.com/>this
ASCII table</a> to see all of the available
characters.)</p><p>Having a text-based protocol allows us to easily convert each of the bytes that
arrive through the TCP connection into a meaningful text. That&rsquo;s why each
<code>byte</code> in the <code>[]byte</code> slice represents one character. Because each byte in the
slice <code>[]byte</code> is a character, converting a <code>[]byte</code> in a string is as easy as:
<code>s := string(slice)</code>.</p><p>And Go is good at handling bytes. For example, it has a
<a href=https://golang.org/pkg/bytes/>bytes</a> package which lets us work with
<code>[]byte</code>, instead of converting them into <code>string</code>s every time we want to work
with bytes.</p><p>Given that all SLCK commands begin with a single word separated with space
after it, we can simply take the first word from the <code>[]byte</code>, upcase it and
compare it with the valid keywords of the protocol. &ldquo;But, how are we supposed
to take a word from a slice of bytes?&rdquo; you might ask. Since bytes are not
words, we have to resort to either compare them byte-by-byte or use the
built-in <code>bytes</code> package. To keep things simple, we will use the <code>bytes</code>
package. (You can check <a href=https://play.golang.org/p/DSxiMiiDwta>this snippet</a>
to compare the two approaches.)</p><p>In the first line of the <code>handle</code>, method we take the first part of the
received message, and we upcase it. Then, on the second line, we remove the
first part from the rest of the message. The split allows us to have the
command (<code>cmd</code>) and the rest of the command arguments (<code>args</code>) in separate
variables.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>cmd <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>ToUpper</span>(bytes.<span style=color:#268bd2>TrimSpace</span>(bytes.<span style=color:#268bd2>Split</span>(message, []<span style=color:#b58900>byte</span>(<span style=color:#2aa198>&#34; &#34;</span>))[<span style=color:#2aa198>0</span>]))
args <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>TrimSpace</span>(bytes.<span style=color:#268bd2>TrimPrefix</span>(message, cmd))
</code></pre></div><p>After that, in the <code>switch</code> construct, we handle all of the different commands.
For example, handling the <code>REG</code> command is done using the <code>reg</code>, and the <code>err</code>
methods:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>reg</span>(args []<span style=color:#dc322f>byte</span>) <span style=color:#dc322f>error</span> {
	u <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>TrimSpace</span>(args)
	<span style=color:#719e07>if</span> u[<span style=color:#2aa198>0</span>] <span style=color:#719e07>!=</span> <span style=color:#2aa198>&#39;@&#39;</span> {
       		<span style=color:#719e07>return</span> fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Username must begin with @&#34;</span>)
	}
   	<span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(u) <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> {
	     	<span style=color:#719e07>return</span> fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Username cannot be blank&#34;</span>)
   	}

	c.username = <span style=color:#b58900>string</span>(u) c.register <span style=color:#719e07>&lt;-</span> c

	<span style=color:#719e07>return</span> <span style=color:#cb4b16>nil</span>
}
</code></pre></div><p>The <code>reg</code> method takes the <code>args</code> slice, and it removes any space bytes (using
<code>bytes.TrimSpace</code>). Given that the second argument of the <code>REG</code> command is the
<code>@username</code> of the user, it checks if the passed username begins with <code>@</code> and
if it&rsquo;s blank. Once it does that, it converts the username to a string, and it
assigns it to the client (<code>c</code>) itself. From then on, the client has an assigned
username.</p><p>As a second step, it sends the client itself through the <code>register</code> channel.
This channel is read by the <code>hub</code> (the chat server), which will do more
validation of the username before it successfully registers the client.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>err</span>(e <span style=color:#dc322f>error</span>) {
	c.conn.<span style=color:#268bd2>Write</span>([]<span style=color:#b58900>byte</span>(<span style=color:#2aa198>&#34;ERR &#34;</span> <span style=color:#719e07>+</span> e.<span style=color:#268bd2>Error</span>() <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;\n&#34;</span>))
}
</code></pre></div><p>The <code>err</code> func simply takes an error and sends its contents back to the user,
using the underlying TCP connection of the client.</p><p>We will come back to the other commands and methods once we have thoroughly
explored the chat server.</p><h3 id=the-hub>The hub<a hidden class=anchor aria-hidden=true href=#the-hub>#</a></h3><p>The <code>hub</code> is the central entity that the clients connect and register with.
The <code>hub</code> also manages the available channels (chat rooms), broadcasting
messages to said channels, and relaying messages (private/direct messages)
between clients.</p><p>All of the above functionality means that the <code>hub</code> is the central place of all
communications, hence the name.</p><p>First, let&rsquo;s explore the <code>hub</code> type with all of its attributes:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> hub <span style=color:#268bd2>struct</span> {
	channels        <span style=color:#268bd2>map</span>[<span style=color:#dc322f>string</span>]<span style=color:#719e07>*</span>channel
	clients         <span style=color:#268bd2>map</span>[<span style=color:#dc322f>string</span>]<span style=color:#719e07>*</span>client
	commands        <span style=color:#268bd2>chan</span> command
	deregistrations <span style=color:#268bd2>chan</span> <span style=color:#719e07>*</span>client
	registrations   <span style=color:#268bd2>chan</span> <span style=color:#719e07>*</span>client
}
</code></pre></div><p>The attributes, and their explanations, in order:</p><ul><li><code>channels</code> - a <code>map</code> of the channels (chat rooms), with the name of the
channel as the key and the <code>*channel</code> as value</li><li><code>clients</code> - a <code>map</code> of the clients (connected users), with the username as
the key and the <code>*client</code> as value</li><li><code>commands</code> - a channel of <code>command</code> that are flowing from the clients to the
<code>hub</code>, that the <code>hub</code> will validate and execute</li><li><code>deregistrations</code> - a channel of <code>*client</code> through which a client deregisters
itself, through which the <code>hub</code> will be informed that the user has closed the
connection and it will clean up any references to that <code>client</code></li><li><code>registrations</code> - a channel of <code>*client</code> through which new clients register
themselves to the <code>hub</code>, through which the <code>hub</code> will accept the new client,
validate their <code>username</code> and add them to the <code>clients</code> map</li></ul><p>So, how does the <code>hub</code> function? It all begins with the <code>run</code> method:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (h <span style=color:#719e07>*</span>hub) <span style=color:#268bd2>run</span>() {
	<span style=color:#719e07>for</span> {
		<span style=color:#719e07>select</span> {
		<span style=color:#719e07>case</span> client <span style=color:#719e07>:=</span> <span style=color:#719e07>&lt;-</span>h.registrations:
			h.<span style=color:#268bd2>register</span>(client)
		<span style=color:#719e07>case</span> client <span style=color:#719e07>:=</span> <span style=color:#719e07>&lt;-</span>h.deregistrations:
			h.<span style=color:#268bd2>unregister</span>(client)
		<span style=color:#719e07>case</span> cmd <span style=color:#719e07>:=</span> <span style=color:#719e07>&lt;-</span>h.commands:
			<span style=color:#719e07>switch</span> cmd.id {
			<span style=color:#719e07>case</span> JOIN:
				h.<span style=color:#268bd2>joinChannel</span>(cmd.sender, cmd.recipient)
			<span style=color:#719e07>case</span> LEAVE:
				h.<span style=color:#268bd2>leaveChannel</span>(cmd.sender, cmd.recipient)
			<span style=color:#719e07>case</span> MSG:
				h.<span style=color:#268bd2>message</span>(cmd.sender, cmd.recipient, cmd.body)
			<span style=color:#719e07>case</span> USRS:
				h.<span style=color:#268bd2>listUsers</span>(cmd.sender)
			<span style=color:#719e07>case</span> CHNS:
				h.<span style=color:#268bd2>listChannels</span>(cmd.sender)
			<span style=color:#719e07>default</span>:
				<span style=color:#586e75>// Freak out?
</span><span style=color:#586e75></span>			}
		}
	}
}
</code></pre></div><p>When we establish a new <code>hub</code> instance (which we will see later), we execute
the <code>run</code> method in a goroutine. The goroutine will run the <code>for</code> loop
indefinitely, processing the <code>registrations</code>, <code>deregistrations</code>, and the
<code>commands</code> channels. Messages arriving through the <code>registrations</code> and
<code>deregistrations</code> channels will be handled differently from the messages that
will come from the <code>commands</code> channel.</p><p><code>run</code> will receive messages through the <code>registrations</code> channel, and it will
send them to the <code>register</code> method for processing:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (h <span style=color:#719e07>*</span>hub) <span style=color:#268bd2>register</span>(c <span style=color:#719e07>*</span>client) {
	<span style=color:#719e07>if</span> _, exists <span style=color:#719e07>:=</span> h.clients[c.username]; exists {
		c.username = <span style=color:#2aa198>&#34;&#34;</span>
		c.conn.<span style=color:#268bd2>Write</span>([]<span style=color:#b58900>byte</span>(<span style=color:#2aa198>&#34;ERR username taken\n&#34;</span>))
	} <span style=color:#719e07>else</span> {
		h.clients[c.username] = c
		c.conn.<span style=color:#268bd2>Write</span>([]<span style=color:#b58900>byte</span>(<span style=color:#2aa198>&#34;OK\n&#34;</span>))
	}
}
</code></pre></div><p>The <code>register</code> method will check if the <code>hub</code> already has a user with the given
username, and it will react accordingly. If the username is taken, it will
remove the username from the <code>client</code> and respond with an error. If the
username is not taken, then it will add the <code>client</code> to the <code>clients</code> map, with
the username as a key and the <code>client</code> reference as a value.</p><p><code>run</code> will receive messages through the <code>deregistrations</code> channel, and it will
send them to the <code>deregister</code> method for processing:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (h <span style=color:#719e07>*</span>hub) <span style=color:#268bd2>deregister</span>(c <span style=color:#719e07>*</span>client) {
	<span style=color:#719e07>if</span> _, exists <span style=color:#719e07>:=</span> h.clients[c.username]; exists {
                <span style=color:#b58900>delete</span>(h.clients, c.username)

		<span style=color:#719e07>for</span> _, channel <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> h.channels {
			<span style=color:#b58900>delete</span>(channel.clients, c)
		}
	}
}
</code></pre></div><p>The <code>deregister</code> method will check if the <code>hub</code> already has a user with the
given username. If it finds the user, it will remove it from the <code>hub</code>&rsquo;s
<code>clients</code> map. Also, it will go through the map of <code>channels</code> and it will try
to remove it from each of the <code>channel</code>&rsquo;s <code>clients</code> map.</p><p>When it comes to handling commands, things are more different. Each of the
<code>command</code>s, as we already established, has an <code>id</code> attribute. For each of the
<code>command</code>s that we receive, we do a switch on the <code>id</code> attribute, which will
invoke a different method. For example, to join a channel, the <code>id</code> must be of
value <code>JOIN</code>, which will invoke the <code>joinChannel</code> function, with the
<code>command</code>&rsquo;s <code>sender</code> and <code>recipient</code> attributes.</p><p>The <code>joinChannel</code> function receives the username (<code>u</code>) and the channel (<code>c</code>) as
arguments. Then, if it finds the channel, it will add the <code>client</code> to the
channel&rsquo;s <code>clients</code> map. Otherwise, it will first create the channel, using the
<code>newChannel</code> constructor, and then add the <code>client</code> as the first client to the
<code>channel</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (h <span style=color:#719e07>*</span>hub) <span style=color:#268bd2>joinChannel</span>(u <span style=color:#dc322f>string</span>, c <span style=color:#dc322f>string</span>) {
	<span style=color:#719e07>if</span> client, ok <span style=color:#719e07>:=</span> h.clients[u]; ok {
		<span style=color:#719e07>if</span> channel, ok <span style=color:#719e07>:=</span> h.channels[c]; ok {
			<span style=color:#586e75>// Channel exists, join
</span><span style=color:#586e75></span>			channel.clients[client] = <span style=color:#cb4b16>true</span>
		} <span style=color:#719e07>else</span> {
			<span style=color:#586e75>// Channel doesn&#39;t exists, create and join
</span><span style=color:#586e75></span>			h.channels[c] = <span style=color:#268bd2>newChannel</span>(c)
			h.channels[c].clients[client] = <span style=color:#cb4b16>true</span>
		}
	}
}
</code></pre></div><p>Now, let&rsquo;s zoom out and see how a <code>client</code> wraps a TCP connection. Then, we
will see how bytes are flowing from the user, through the <code>client</code>, to the
<code>hub</code> ending up with the receiver (another channel or user).</p><h3 id=sending-messages>Sending messages<a hidden class=anchor aria-hidden=true href=#sending-messages>#</a></h3><p>The core functionality to a chat server and the purpose of our SLCK protocol
is sending and receiving messages. Let&rsquo;s follow the flow of the bytes and see
how we can implement sending messages between clients.</p><p>The structure of the <code>MSG</code> command is as follows:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>MSG &lt;entity-id&gt; &lt;length&gt;\r\n[payload]
</code></pre></div><p>For example, to send a <code>Hello!</code> message to the <code>#general</code> channel:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>MSG #general 6\r\nHello!
</code></pre></div><p>Or, to send a <code>Hey!</code> message to <code>@jane</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>MSG @jane 4\r\nHey!
</code></pre></div><p>Once the user sends the <code>MSG</code> command, the <code>client</code>&rsquo;s <code>handle</code> method accepts
it. Then, in <code>handle</code> we extract the message and the command, and we invoke the
<code>msg</code> method of the <code>client</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>handle</span>(message []<span style=color:#dc322f>byte</span>) {
	cmd <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>ToUpper</span>(bytes.<span style=color:#268bd2>TrimSpace</span>(bytes.<span style=color:#268bd2>Split</span>(message, []<span style=color:#b58900>byte</span>(<span style=color:#2aa198>&#34; &#34;</span>))[<span style=color:#2aa198>0</span>]))
	args <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>TrimSpace</span>(bytes.<span style=color:#268bd2>TrimPrefix</span>(message, cmd))

	<span style=color:#719e07>switch</span> <span style=color:#b58900>string</span>(cmd) {
	<span style=color:#586e75>// Some other stuff here...
</span><span style=color:#586e75></span>	<span style=color:#719e07>case</span> <span style=color:#2aa198>&#34;MSG&#34;</span>:
		<span style=color:#719e07>if</span> err <span style=color:#719e07>:=</span> c.<span style=color:#268bd2>msg</span>(args); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			c.<span style=color:#268bd2>err</span>(err)
		}
	<span style=color:#586e75>// Some other stuff here...
</span><span style=color:#586e75></span>	<span style=color:#719e07>default</span>:
		c.<span style=color:#268bd2>err</span>(fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Unknown command %s&#34;</span>, cmd))
	}
}
</code></pre></div><p>The <code>args</code> are passed to the <code>msg</code> method, which does some heavy lifting.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>msg</span>(args []<span style=color:#dc322f>byte</span>) <span style=color:#dc322f>error</span> {
	args = bytes.<span style=color:#268bd2>TrimSpace</span>(args)
	<span style=color:#719e07>if</span> args[<span style=color:#2aa198>0</span>] <span style=color:#719e07>!=</span> <span style=color:#2aa198>&#39;#&#39;</span> <span style=color:#719e07>&amp;&amp;</span> args[<span style=color:#2aa198>0</span>] <span style=color:#719e07>!=</span> <span style=color:#2aa198>&#39;@&#39;</span> {
		<span style=color:#719e07>return</span> fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;recipient must be a channel (&#39;#name&#39;) or user (&#39;@user&#39;)&#34;</span>)
	}

	recipient <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>Split</span>(args, []<span style=color:#b58900>byte</span>(<span style=color:#2aa198>&#34; &#34;</span>))[<span style=color:#2aa198>0</span>]
	<span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(recipient) <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> {
		<span style=color:#719e07>return</span> fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;recipient must have a name&#34;</span>)
	}

	<span style=color:#586e75>// More stuff here...
</span><span style=color:#586e75></span>}
</code></pre></div><p>The <code>msg</code> method&rsquo;s first step is to check if the first argument of the message
begins with a <code>@</code> or <code>#</code> – a user or a channel name. If that&rsquo;s correct, we
extract the <code>recipient</code>, which can be the username or the channel name.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>msg</span>(args []<span style=color:#dc322f>byte</span>) <span style=color:#dc322f>error</span> {
	<span style=color:#586e75>// The stuff from above here...
</span><span style=color:#586e75></span>
	args = bytes.<span style=color:#268bd2>TrimSpace</span>(bytes.<span style=color:#268bd2>TrimPrefix</span>(args, recipient))
	l <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>Split</span>(args, DELIMITER)[<span style=color:#2aa198>0</span>]
	length, err <span style=color:#719e07>:=</span> strconv.<span style=color:#268bd2>Atoi</span>(<span style=color:#b58900>string</span>(l))
	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
		<span style=color:#719e07>return</span> fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;body length must be present&#34;</span>)
	}
	<span style=color:#719e07>if</span> length <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> {
		<span style=color:#719e07>return</span> fmt.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;body length must be at least 1&#34;</span>)
	}

	padding <span style=color:#719e07>:=</span> <span style=color:#b58900>len</span>(l) <span style=color:#719e07>+</span> <span style=color:#b58900>len</span>(DELIMITER) <span style=color:#586e75>// Size of the body length + the delimiter
</span><span style=color:#586e75></span>	body <span style=color:#719e07>:=</span> args[padding : padding<span style=color:#719e07>+</span>length]

	c.outbound <span style=color:#719e07>&lt;-</span> command{
		recipient: <span style=color:#b58900>string</span>(recipient[<span style=color:#2aa198>1</span>:]),
		sender:    c.username,
		body:      body,
		id:        <span style=color:#2aa198>&#34;MSG&#34;</span>,
	}

	<span style=color:#719e07>return</span> <span style=color:#cb4b16>nil</span>
}
</code></pre></div><p>We extract the next argument after, which, according to the protocol
specification, is the length of the body in bytes. Having the size of the body
(the length of the bytes) as part of the command that is sent by the client
allows the server to slice off the bytes it needs from the body efficiently.</p><p>Let&rsquo;s see an example:</p><pre><code>MSG #general 39\r\nHey folks, hope you are all doing well!
</code></pre><p>In the <code>handle</code> method, we sliced off <code>MSG</code>, and we send the rest of the bytes
to the <code>msg</code> method. In <code>msg</code>, we checked if the next argument is a channel or
a username – which is correct. Then, we pick up the <code>39</code>, and we store them in
the <code>l</code> variable.</p><p>Having <code>l</code> being <code>39</code> is not enough – the slice of bytes that represent the
ASCII <code>39</code> is <code>[51 57]</code>. The <code>51</code> and <code>57</code> bytes just mean that the two octets
representing <code>3</code> and <code>9</code> in ASCII, have byte representation as <code>51</code> and <code>57</code>.
To make our Go code understand <code>[51 57]</code> like <code>39</code>, we have to convert them
into a <code>string</code>, so they become <code>"39"</code> and then use the <code>strconv</code> package to
convert the <code>string</code> to an <code>int</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>l <span style=color:#719e07>:=</span> bytes.<span style=color:#268bd2>Split</span>(args, DELIMITER)[<span style=color:#2aa198>0</span>]
length, err <span style=color:#719e07>:=</span> strconv.<span style=color:#268bd2>Atoi</span>(<span style=color:#b58900>string</span>(l))
</code></pre></div><p>Once we have the <code>length</code> of the body, we validate that it will be at least one
byte. Next, we take the remaining bytes from the <code>args</code>, and we slice off the
<code>length</code> amount of bytes from the <code>args</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>padding <span style=color:#719e07>:=</span> <span style=color:#b58900>len</span>(l) <span style=color:#719e07>+</span> <span style=color:#b58900>len</span>(DELIMITER) <span style=color:#586e75>// Size of the body length + the delimiter
</span><span style=color:#586e75></span>body <span style=color:#719e07>:=</span> args[padding : padding<span style=color:#719e07>+</span>length]
</code></pre></div><p>In context of our example above:</p><pre><code>MSG #general 39\r\nHey folks, hope you are all doing well!
</code></pre><p>we take the length (2) of the <code>39</code> plus the length of the <code>\r\n</code> delimiter and
then take the body out of the <code>args</code> slice of bytes by using the &ldquo;slice&rdquo;
operator (<code>:</code>). The slicing operation results in slicing all of the bytes
between <code>\n</code> to the end of the body, meaning the <code>body</code> becomes:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Hey folks, hope you are all doing well!
</code></pre></div><p>If the <code>length</code> were less then <code>39</code>, then the <code>body</code> would end up being
shorter, because the user has sent the wrong body size to the server.
Conversely, if we tried to slice off more than the size of the <code>body</code>, then the
goroutine serving the <code>hub</code> would crash, rendering our server useless.</p><p>Given that <code>body</code> now contains the message itself, the last step of the <code>msg</code>
method is to send the new command it received through the <code>outbound</code> channel to
the <code>hub</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>c.outbound <span style=color:#719e07>&lt;-</span> command{
        recipient: <span style=color:#b58900>string</span>(recipient[<span style=color:#2aa198>1</span>:]),
        sender:    c.username,
        body:      body,
        id:        MSG,
}
</code></pre></div><p>The <code>command</code> has a <code>recipient</code> (channel or user ID), the <code>sender</code>, which is
the username of the message author, the <code>body</code> containing the <code>body</code> of the
message, and the <code>id</code> that&rsquo;s the identifier of the <code>command</code> - <code>MSG</code> in this
case.</p><p>Then, the <code>hub</code> which infinitely loops and reads from the <code>commands</code> channel
(which is the same channel as the <code>outbound</code> channel of the <code>client</code>), will
pick up the message from the <code>client</code> and process it in the <code>message</code> method:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (h <span style=color:#719e07>*</span>hub) <span style=color:#268bd2>message</span>(u <span style=color:#dc322f>string</span>, r <span style=color:#dc322f>string</span>, m []<span style=color:#dc322f>byte</span>) {
	<span style=color:#719e07>if</span> sender, ok <span style=color:#719e07>:=</span> h.clients[u]; ok {
		<span style=color:#719e07>switch</span> r[<span style=color:#2aa198>0</span>] {
		<span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;#&#39;</span>:
			<span style=color:#719e07>if</span> channel, ok <span style=color:#719e07>:=</span> h.channels[r]; ok {
				<span style=color:#719e07>if</span> _, ok <span style=color:#719e07>:=</span> channel.clients[sender]; ok {
					channel.<span style=color:#268bd2>broadcast</span>(sender.username, m)
				}
			}
		<span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;@&#39;</span>:
			<span style=color:#719e07>if</span> user, ok <span style=color:#719e07>:=</span> h.clients[r]; ok {
				user.conn.<span style=color:#268bd2>Write</span>(<span style=color:#b58900>append</span>(m, <span style=color:#2aa198>&#39;\n&#39;</span>))
			}
		}
	}
}
</code></pre></div><p>The <code>message</code> method will check if the sender username (<code>u</code>) is present in the
list of active clients (<code>h.clients</code>). If the client is active, then it will
check if the first byte of the message (<code>m</code>) is a <code>#</code> or a <code>@</code>. Based on the
result of the <code>switch</code>, either it will broadcast the message (<code>m</code>) to the
channel, or it will find the recipient (<code>r</code>) from the <code>h.clients</code> list and send
the message through the recipient&rsquo;s TCP connection.</p><p>Let&rsquo;s see this in action. I will start the server (using <code>go run .</code>) and open
two <code>telnet</code> sessions with the server:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ telnet 127.0.0.1 <span style=color:#2aa198>8081</span>
Trying 127.0.0.1...
Connected to localhost.
Escape character is <span style=color:#2aa198>&#39;^]&#39;</span>.
</code></pre></div><p>Given that SCLK is a ASCII wire protocol, it means we can just send some
commands to the server right away. Let&rsquo;s first register both clients. The first
one will be <code>@jane</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>REG @jane
OK
</code></pre></div><p>And the second client will be <code>@john</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>REG @john
OK
</code></pre></div><p>In both cases the registration with the server went well, so the server replied
with <code>OK</code>. Now, let&rsquo;s make both of the clients join the <code>#general</code> channel. If
any of the users listed the channels they would get an error:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>CHNS
ERR no channels found
</code></pre></div><p>Great, let&rsquo;s make them both join <code>#general</code>, so the channel would be created.
First <code>@john</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>JOIN <span style=color:#586e75>#general</span>
OK
</code></pre></div><p><code>@jane</code> righ after:</p><pre><code>CHNS
#general

JOIN #general
OK
</code></pre><p>Now that both are in the channel, we can also send a message from <code>@jane</code> to
<code>#general</code>, and it should pop up on <code>@john</code>&rsquo;s screen too.</p><p>Sending the message:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>MSG <span style=color:#586e75>#general 5\r\nHello</span>
</code></pre></div><p>And in <code>@john</code>&rsquo;s screen we can see:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>jane: Hello
</code></pre></div><p>Voilá! <code>@john</code> received the message. Let&rsquo;s say <code>@john</code> would like to send
<code>@jane</code> a direct message. He sends:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>MSG @jane 3<span style=color:#cb4b16>\r\n</span>Hey
</code></pre></div><p>And on <code>@jane</code>&rsquo;s screen she will see:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>@john: Hey
</code></pre></div><h2 id=tying-it-all-together>Tying it all together<a hidden class=anchor aria-hidden=true href=#tying-it-all-together>#</a></h2><p>Now that we went through the <code>client</code>, <code>hub</code>, <code>channel</code>, and <code>command</code>, we need
to see the last piece of the puzzle - the <code>main</code> function that ties it all
together.</p><p>In the <code>main</code> func, we will initialize a TCP listener, through which we can
accept a new TCP connection. Then, we will establish a new <code>hub</code> and invoke
<code>run</code> in a separate goroutine.</p><p>Once the <code>hub</code> is running, we will infinitely loop using a <code>for</code>. Within the
<code>for</code> loop, we will accept new TCP connections, wrap them in a new <code>client</code> and
spin them off in a new goroutine.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;log&#34;</span>
	<span style=color:#2aa198>&#34;net&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() { ln, err <span style=color:#719e07>:=</span> net.<span style=color:#268bd2>Listen</span>(<span style=color:#2aa198>&#34;tcp&#34;</span>, <span style=color:#2aa198>&#34;:8081&#34;</span>)
	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
		log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;%v&#34;</span>, err)
	}

	hub <span style=color:#719e07>:=</span> <span style=color:#268bd2>newHub</span>()
	<span style=color:#719e07>go</span> hub.<span style=color:#268bd2>run</span>()

	<span style=color:#719e07>for</span> {
		conn, err <span style=color:#719e07>:=</span> ln.<span style=color:#268bd2>Accept</span>()
		<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;%v&#34;</span>, err)
		}

		c <span style=color:#719e07>:=</span> <span style=color:#268bd2>newClient</span>(
			conn,
			hub.commands,
			hub.registrations,
			hub.deregistrations,
		)
		<span style=color:#719e07>go</span> c.<span style=color:#268bd2>read</span>()
	}
}
</code></pre></div><p>As a refresher, within the <code>read</code> function of the <code>client</code>, we also infinitely
loop using a <code>for</code> and accept new incoming TCP messages:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>client) <span style=color:#268bd2>read</span>() <span style=color:#dc322f>error</span> {
	<span style=color:#719e07>for</span> {
		msg, err <span style=color:#719e07>:=</span> bufio.<span style=color:#268bd2>NewReader</span>(c.conn).<span style=color:#268bd2>ReadBytes</span>(<span style=color:#2aa198>&#39;\n&#39;</span>)
		<span style=color:#719e07>if</span> err <span style=color:#719e07>==</span> io.EOF {
			<span style=color:#586e75>// Connection closed, deregister client
</span><span style=color:#586e75></span>			c.deregister <span style=color:#719e07>&lt;-</span> c
			<span style=color:#719e07>return</span> <span style=color:#cb4b16>nil</span>
		}

		<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
			<span style=color:#719e07>return</span> err
		}

		c.<span style=color:#268bd2>handle</span>(msg)
	}
	<span style=color:#719e07>return</span> <span style=color:#cb4b16>nil</span>
}
</code></pre></div><p>Having the <code>client</code>&rsquo;s <code>read</code> method being run a separate goroutine allows us to
spin off as many goroutines as we have connections. That leaves our main thread
to accept new connections and just spin the off into goroutines. Once the
goroutine is running, it will take care of itself until it crashes or the
client exits.</p><p>The pitfall of this approach is that we have a single <code>hub</code> instance, which
means that there&rsquo;s only one goroutine that is accepting messages from what can
be thousands of clients. While having a single <code>hub</code> instance simplifies the
design, it also introduces a single point of failure. If the <code>hub.run</code>
goroutine crashes/exits for whatever reason, the server will be rendered
useless, although all of the client connections will be working fine.</p><p>The full code of the SLCK protocol server implementation can be found in <a href=https://github.com/fteem/go-playground/tree/master/slck-protocol>this
repo</a>.</p><h2 id=notable-shortcuts>Notable shortcuts<a hidden class=anchor aria-hidden=true href=#notable-shortcuts>#</a></h2><p>Before we wrap up here, I would like to highlight a few of the shortcuts we
took while building this server implementation. Cutting these corners was with
a purpose - not making this long article even longer.</p><p>First, we are missing resource locking when creating the channels or when a
user joins/leaves a channel. If multiple people would join the same channel at
the same time, it is possible to get a concurrent writes issue.</p><p>Second, our server does not have a graceful shutdown. A production-ready
implementation would gracefully shut down all of the connections, informing the
clients about the shutdown. Then, it would potentially save some state on disk
before shutting down.</p><p>Another shortcut we took was validation of the body size in the <code>msg</code> method.
When we are performing the slicing of the message body, we do not take into
consideration if there are enough bytes in the message. If a client sends a
body size larger then the body itself, we might slice off more bytes than
available, which would result in a <code>panic</code> and a slice out of bounds error.</p><p>If you would like to play more with our chat server, I recommend starting with
adding each of these missing functionalities to it. And drop me the link to the
repo in the comments, so I can see how you pulled it off.</p><hr><p>Changelog:</p><ul><li>2020-04-04 10:10UTC - Fixed the <code>client</code> type definition, which was
missing the <code>deregister</code> channel, as pointed out by Rene C. over email.</li></ul><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to +1000 of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://ieftimov.com/post/four-steps-daemonize-your-golang-programs/><span class=title>« Prev Page</span><br><span>Four Steps to Daemonize Your Go Programs</span></a>
<a class=next href=https://ieftimov.com/post/testing-in-go-websockets/><span class=title>Next Page »</span><br><span>Testing in Go: WebSockets</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Understanding bytes in Go by building a TCP protocol on twitter" href="https://twitter.com/intent/tweet/?text=Understanding%20bytes%20in%20Go%20by%20building%20a%20TCP%20protocol&url=https%3a%2f%2fieftimov.com%2fpost%2funderstanding-bytes-golang-build-tcp-protocol%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Understanding bytes in Go by building a TCP protocol on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2funderstanding-bytes-golang-build-tcp-protocol%2f&title=Understanding%20bytes%20in%20Go%20by%20building%20a%20TCP%20protocol&summary=Understanding%20bytes%20in%20Go%20by%20building%20a%20TCP%20protocol&source=https%3a%2f%2fieftimov.com%2fpost%2funderstanding-bytes-golang-build-tcp-protocol%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Understanding bytes in Go by building a TCP protocol on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2funderstanding-bytes-golang-build-tcp-protocol%2f&title=Understanding%20bytes%20in%20Go%20by%20building%20a%20TCP%20protocol"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Understanding bytes in Go by building a TCP protocol on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2funderstanding-bytes-golang-build-tcp-protocol%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Understanding bytes in Go by building a TCP protocol on whatsapp" href="https://api.whatsapp.com/send?text=Understanding%20bytes%20in%20Go%20by%20building%20a%20TCP%20protocol%20-%20https%3a%2f%2fieftimov.com%2fpost%2funderstanding-bytes-golang-build-tcp-protocol%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Understanding bytes in Go by building a TCP protocol on telegram" href="https://telegram.me/share/url?text=Understanding%20bytes%20in%20Go%20by%20building%20a%20TCP%20protocol&url=https%3a%2f%2fieftimov.com%2fpost%2funderstanding-bytes-golang-build-tcp-protocol%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>