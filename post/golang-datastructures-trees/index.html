<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Golang Datastructures: Trees - Ilija Eftimov</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Golang Datastructures: Trees" />
<meta property="og:description" content="You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you donâ€™t understand them (which is what I had been doing for a while).
Now, don&#39;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ieftimov.com/post/golang-datastructures-trees/" />
<meta property="og:image" content="https://ieftimov.com/cards/golang-datastructures-trees.png" />
<meta property="article:published_time" content="2019-02-13T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ieftimov.com/cards/golang-datastructures-trees.png"/>

<meta name="twitter:title" content="Golang Datastructures: Trees"/>
<meta name="twitter:description" content="You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you donâ€™t understand them (which is what I had been doing for a while).
Now, don&#39;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.comcss/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.comcss/main.css" />
		<link rel="stylesheet" type="text/css" href="https://ieftimov.comcss/overrides.css" />
	

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://ieftimov.comjs/main.js"></script><script src="https://ieftimov.comjs/tooltip.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://ieftimov.com">
				<img src="https://pbs.twimg.com/profile_images/1194757753585225728/JbET17PZ_400x400.jpg" alt="Ilija Eftimov" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://ieftimov.com">Ilija Eftimov</a></h1>
	<div class="site-description"><p>Software engineer, author and open source contributor</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/fteem" title="Github"><i data-feather="github"></i></a></li><li><a href="https://twitter.com/fteem" title="Twitter"><i data-feather="twitter"></i></a></li><li><a href="https://www.linkedin.com/in/ieftimov" title="Linkedin"><i data-feather="linkedin"></i></a></li><li><a href="mailto:blog@ieftimov.com" title="Email"><i data-feather="mail"></i></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">Archive</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="https://forms.gle/orfXK5jh1LRaiFzo8">Suggest a topic</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">13</span>
							<span class="rest">Feb 2019</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Golang Datastructures: Trees</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p><img src="/golang-datastructures-trees/tree_swing.png" alt=""></p>
<p>You can spend quite a bit of your programming career without working with trees,
or just by simply avoiding them if you donâ€™t understand them (which is what I
had been doing for a while).</p>
<p>Now, don't get me wrong - arrays, lists, stacks and queues are quite powerful
data structures and can take you pretty far, but there is a limit to their
capabilities, how you can use them and how efficient that usage can be. When you
throw in hash tables to that mix, you can solve quite some problems, but for
many of the problems out there trees are a powerful (and maybe the only) tool
if you have them under your belt.</p>
<p>So, let's look at trees and then we can try to use them in a small exercise.</p>
<h2 id="a-touch-of-theory">A touch of theory</h2>
<p>Arrays, lists, queues, stacks store data in a collection that has a start and an
end, hence they are called &ldquo;linear&rdquo;. But when it comes to trees and graphs,
things can get confusing since the data is not stored in a linear fashion.</p>
<p>Trees are called nonlinear data structures. In fact, you can also say that trees
are hierarchical data structures since the data is stored in a hierarchical way.</p>
<p>For your reading pleasure, Wikipediaâ€™s definition of trees:</p>
<blockquote>
<p>A tree is a data structure made up of nodes or vertices and edges without
having any cycle. The tree with no nodes is called the null or empty tree. A
tree that is not empty consists of a root node and potentially many levels of
additional nodes that form a hierarchy.</p>
</blockquote>
<p>What the definition states are that a tree is just a combination of nodes (or
vertices) and edges (or links between the nodes) without having a cycle.</p>
<p><img src="/golang-datastructures-trees/invalid-tree.png" alt=""></p>
<p>For example, the data structure represented on the diagram is a combination of
nodes, named from A to F, with six edges. Although all of its elements look like
they construct a tree, the nodes A, D, E and F have a cycle, therefore this
structure is not a tree.</p>
<p>If we would break the edge between nodes F and E and add a new node called G with
an edge between F and G, we would end up with something like this:</p>
<p><img src="/golang-datastructures-trees/valid-tree.png" alt=""></p>
<p>Now, since we eliminated the cycle in this graph, we can say that we have a valid
tree. It has a <strong>root</strong> with the name A, with a total of 7 <strong>nodes</strong>. Node A has
3 <strong>children</strong> (B, D &amp; F) and those have 3 children (C, E &amp; G respectively).
Therefore, node A has 6 <strong>descendants</strong>. Also, this tree has 3 leaf nodes (C, E
&amp; G) or nodes that have no children.</p>
<p>What do B, D &amp; F have in common? They are <strong>siblings</strong> because they have the
same parent (node A). They all reside on <strong>level</strong> 1 because to get from each
of them to the root we need to take only one step. For example, node G has level
2, because the <strong>path</strong> from G to A is: G -&gt; F -&gt; A, hence we need to follow two
edges to get to A.</p>
<p>Now that we know a bit of theory about trees, letâ€™s see how we can solve some
problems.</p>
<p><img src="/golang-datastructures-trees/web_development.png" alt=""></p>
<h2 id="modelling-an-html-document">Modelling an HTML document</h2>
<p>If you are a software developer that has never written any HTML, I will just
assume that you have seen (or have an idea) what HTML looks like. If you have
not, then I encourage you to right click on the page that you are reading this
and click on &lsquo;View Source&rsquo;.</p>
<p>Seriously, go for it, I'll wait&hellip;</p>
<p>Browsers have this thing baked in, called the DOM - a cross-platform and
language-independent application programming interface, which treats internet
documents as a tree structure wherein each node is an object representing a part
of the document. This means that when the browser reads your document's HTML
code it will load it and create a DOM out of it.</p>
<p>So, letâ€™s imagine for a second we are developers working on a browser, like
Chrome or Firefox and we need to model the DOM. Well, to make this exercise
easier, letâ€™s see a tiny HTML document:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#000080">html</span>&gt;
  &lt;<span style="color:#000080">h1</span>&gt;Hello, World!&lt;/<span style="color:#000080">h1</span>&gt;
  &lt;<span style="color:#000080">p</span>&gt;This is a simple HTML document.&lt;/<span style="color:#000080">p</span>&gt;
&lt;/<span style="color:#000080">html</span>&gt;</code></pre></div>
<p>So, if we would model this document as a tree, it would look something like
this:</p>
<p><img src="/golang-datastructures-trees/html-document-tree.png" alt=""></p>
<p>Now, we could treat the text nodes as separate <code>Node</code>s, but we can make our
lives simpler by assuming that any HTML element can have text in it.</p>
<p>The <code>html</code> node will have two children, <code>h1</code> and <code>p</code>, which will have <code>tag</code>,
<code>text</code> and <code>children</code> as fields. Letâ€™s put this into code:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> Node <span style="font-weight:bold">struct</span> {
    tag      <span style="color:#458;font-weight:bold">string</span>
    text     <span style="color:#458;font-weight:bold">string</span>
    children []<span style="font-weight:bold">*</span>Node
}</code></pre></div>
<p>A <code>Node</code> will have only the tag name and children optionally. Letâ€™s try to
create the HTML document we saw above as a tree of <code>Node</code>s by hand:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
        p <span style="font-weight:bold">:=</span> Node{
                tag:  <span style="color:#b84">&#34;p&#34;</span>,
                text: <span style="color:#b84">&#34;This is a simple HTML document.&#34;</span>,
                id:   <span style="color:#b84">&#34;foo&#34;</span>,
        }

        h1 <span style="font-weight:bold">:=</span> Node{
                tag:  <span style="color:#b84">&#34;h1&#34;</span>,
                text: <span style="color:#b84">&#34;Hello, World!&#34;</span>,
        }

        html <span style="font-weight:bold">:=</span> Node{
                tag:      <span style="color:#b84">&#34;html&#34;</span>,
                children: []<span style="font-weight:bold">*</span>Node{<span style="font-weight:bold">&amp;</span>p, <span style="font-weight:bold">&amp;</span>h1},
        }
}</code></pre></div>
<p>That looks okay, we have a basic tree up and running now.</p>







<div id="mc_embed_signup">
<form action="https://pm.us20.list-manage.com/subscribe/post?u=d9a6471309140dcd520d05346&amp;id=2aac491644" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
        <div class="heading">Join The Newsletter</div>
        <p>
            I write about backend technologies, programming and cloud architectures. Join hundreds of other developers that get my content, twice a month. Unsubscribe whenever. Never spam.
        </p>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
        <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">

      
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d9a6471309140dcd520d05346_2aac491644" tabindex="-1" value=""></div>

    <p>You can also subscribe <a href="/index.xml">via RSS</a>.</p>
    </div>
</form>
</div>


<h2 id="building-mydom---a-drop-in-replacement-for-the-dom-">Building MyDOM - a drop-in replacement for the DOM ðŸ˜‚</h2>
<p>Now that we have some tree structure in place, let's take a step back and see
what kind of functionality would a DOM have. For example, if MyDOM
<!-- raw HTML omitted -->(TM)<!-- raw HTML omitted --> would be a drop-in replacement of a real DOM, then with
JavaScript we should be able to access nodes and modify them.</p>
<p>The simplest way to do this with JavaScript would be to use</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#999">document</span>.getElementById(<span style="color:#b84">&#39;foo&#39;</span>)
</code></pre></div>
<p>This function would lookup in the <code>document</code> tree to find the node whose ID is
<code>foo</code>. Let's update our <code>Node</code> struct to have more attributes and then work on
writing a lookup function for our tree:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> Node <span style="font-weight:bold">struct</span> {
  tag      <span style="color:#458;font-weight:bold">string</span>
  id       <span style="color:#458;font-weight:bold">string</span>
  class    <span style="color:#458;font-weight:bold">string</span>
  children []<span style="font-weight:bold">*</span>Node
}</code></pre></div>
<p>Now, each of our <code>Node</code> structs will have a <code>tag</code>, <code>children</code> which is a slice
of pointers to the children of that <code>Node</code>, <code>id</code> which is the ID of that DOM
node and <code>class</code> which is the classes that can be applied to this DOM node.</p>
<p>Now, back to our <code>getElementById</code> lookup function. Let's see how we could
implement it. First, let's build an example tree that we can use for our lookup
algorithm:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#000080">html</span>&gt;
  &lt;<span style="color:#000080">body</span>&gt;
    &lt;<span style="color:#000080">h1</span>&gt;This is a H1&lt;/<span style="color:#000080">h1</span>&gt;
    &lt;<span style="color:#000080">p</span>&gt;
      And this is some text in a paragraph. And next to it there&#39;s an image.
      &lt;<span style="color:#000080">img</span> <span style="color:#008080">src</span><span style="font-weight:bold">=</span><span style="color:#b84">&#34;http://example.com/logo.svg&#34;</span> <span style="color:#008080">alt</span><span style="font-weight:bold">=</span><span style="color:#b84">&#34;Example&#39;s Logo&#34;</span>/&gt;
    &lt;/<span style="color:#000080">p</span>&gt;
    &lt;<span style="color:#000080">div</span> <span style="color:#008080">class</span><span style="font-weight:bold">=</span><span style="color:#b84">&#39;footer&#39;</span>&gt;
      This is the footer of the page.
      &lt;<span style="color:#000080">span</span> <span style="color:#008080">id</span><span style="font-weight:bold">=</span><span style="color:#b84">&#39;copyright&#39;</span>&gt;2019 <span style="color:#800080">&amp;copy;</span> Ilija Eftimov&lt;/<span style="color:#000080">span</span>&gt;
    &lt;/<span style="color:#000080">div</span>&gt;
  &lt;/<span style="color:#000080">body</span>&gt;
&lt;/<span style="color:#000080">html</span>&gt;</code></pre></div>
<p>This is a quite complicated HTML document. Let's sketch out its structure in Go
using the <code>Node</code> struct as a building block:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">image <span style="font-weight:bold">:=</span> Node{
        tag: <span style="color:#b84">&#34;img&#34;</span>,
        src: <span style="color:#b84">&#34;http://example.com/logo.svg&#34;</span>,
        alt: <span style="color:#b84">&#34;Example&#39;s Logo&#34;</span>,
}

p <span style="font-weight:bold">:=</span> Node{
        tag:      <span style="color:#b84">&#34;p&#34;</span>,
        text:     <span style="color:#b84">&#34;And this is some text in a paragraph. And next to it there&#39;s an image.&#34;</span>,
        children: []<span style="font-weight:bold">*</span>Node{<span style="font-weight:bold">&amp;</span>image},
}

span <span style="font-weight:bold">:=</span> Node{
        tag:  <span style="color:#b84">&#34;span&#34;</span>,
        id:   <span style="color:#b84">&#34;copyright&#34;</span>,
        text: <span style="color:#b84">&#34;2019 &amp;copy; Ilija Eftimov&#34;</span>,
}

div <span style="font-weight:bold">:=</span> Node{
        tag:      <span style="color:#b84">&#34;div&#34;</span>,
        class:    <span style="color:#b84">&#34;footer&#34;</span>,
        text:     <span style="color:#b84">&#34;This is the footer of the page.&#34;</span>,
        children: []<span style="font-weight:bold">*</span>Node{<span style="font-weight:bold">&amp;</span>span},
}

h1 <span style="font-weight:bold">:=</span> Node{
        tag:  <span style="color:#b84">&#34;h1&#34;</span>,
        text: <span style="color:#b84">&#34;This is a H1&#34;</span>,
}

body <span style="font-weight:bold">:=</span> Node{
        tag:      <span style="color:#b84">&#34;body&#34;</span>,
        children: []<span style="font-weight:bold">*</span>Node{<span style="font-weight:bold">&amp;</span>h1, <span style="font-weight:bold">&amp;</span>p, <span style="font-weight:bold">&amp;</span>div},
}

html <span style="font-weight:bold">:=</span> Node{
        tag:      <span style="color:#b84">&#34;html&#34;</span>,
        children: []<span style="font-weight:bold">*</span>Node{<span style="font-weight:bold">&amp;</span>body},
}</code></pre></div>
<p>We start building this tree bottom - up. That means we create structs from the
most deeply nested structs and working up towards <code>body</code> and <code>html</code>. Let's look
at a graphic of our tree:</p>
<p><img src="/golang-datastructures-trees/mydom-tree.png" alt=""></p>
<h2 id="implementing-node-lookup-">Implementing Node Lookup ðŸ”Ž</h2>
<p>So, let's continue with what we were up to - allow JavaScript to call
<code>getElementById</code> on our <code>document</code> and find the <code>Node</code> that it's looking for.</p>
<p>To do this, we have to implement a tree searching algorithm. The most popular
approaches to searching (or traversal) of graphs and trees are Breadth First
Search (BFS) and Depth First Search (DFS).</p>
<h3 id="breadth-first-search-">Breadth-first search â¬…âž¡</h3>
<p>BFS, as its name suggests, takes an approach to traversal where it explores
nodes in &ldquo;width&rdquo; first before it goes in &ldquo;depth&rdquo;. Here's a visualisation of the
steps a BFS algorithm would take to traverse the whole tree:</p>
<p><img src="/golang-datastructures-trees/mydom-tree-bfs-steps.png" alt=""></p>
<p>As you can see, the algorithm will take two steps in depth (over <code>html</code> and
<code>body</code>), but then it will visit all of the <code>body</code>'s children nodes before it
proceeds to explore in depth and visit the <code>span</code> and <code>img</code> nodes.</p>
<p>If you would like to have a step-by-step playbook, it would be:</p>
<ol>
<li>We start at the root, the <code>html</code> node</li>
<li>We push it on the <code>queue</code></li>
<li>We kick off a loop where we loop while the <code>queue</code> is not empty</li>
<li>We check the next element in the <code>queue</code> for a match. If a match is found, we
return the match and we're done.</li>
<li>When a match is not found, we take all of the children of the
node-under-inspection and we add them to the queue, so they can be inspected</li>
<li><code>GOTO</code> 4</li>
</ol>
<p>Let's see a simple implementation of the algorithm in Go and I'll share some
tips on how you can remember the algorithm easily.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">findById</span>(root <span style="font-weight:bold">*</span>Node, id <span style="color:#458;font-weight:bold">string</span>) <span style="font-weight:bold">*</span>Node {
        queue <span style="font-weight:bold">:=</span> <span style="color:#999">make</span>([]<span style="font-weight:bold">*</span>Node, <span style="color:#099">0</span>)
        queue = <span style="color:#999">append</span>(queue, root)
        <span style="font-weight:bold">for</span> <span style="color:#999">len</span>(queue) &gt; <span style="color:#099">0</span> {
                nextUp <span style="font-weight:bold">:=</span> queue[<span style="color:#099">0</span>]
                queue = queue[<span style="color:#099">1</span>:]
                <span style="font-weight:bold">if</span> nextUp.id <span style="font-weight:bold">==</span> id {
                        <span style="font-weight:bold">return</span> nextUp
                }
                <span style="font-weight:bold">if</span> <span style="color:#999">len</span>(nextUp.children) &gt; <span style="color:#099">0</span> {
                        <span style="font-weight:bold">for</span> _, child <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> nextUp.children {
                                queue = <span style="color:#999">append</span>(queue, child)
                        }
                }
        }
        <span style="font-weight:bold">return</span> <span style="font-weight:bold">nil</span>
}</code></pre></div>
<p>The algorithm has three key points:</p>
<ol>
<li>The <code>queue</code> - it will contain all of the nodes that the algorithm visits</li>
<li>Taking the first element of the <code>queue</code>, checking it for a match, and
proceeding with the next nodes if no match is found</li>
<li><code>Queue</code>ing up all of the children nodes for a node before moving on in the
<code>queue</code></li>
</ol>
<p>Essentially, the whole algorithm revolves around pushing children nodes on a
queue and inspecting the nodes that are queued up. Of course, if a match is not
found at the end we return <code>nil</code> instead of a pointer to a <code>Node</code>.</p>
<h3 id="depth-first-search-">Depth-first search â¬‡</h3>
<p>For completeness sake, let's also see how DFS would work.</p>
<p>As we stated earlier, the depth-first search will go first in depth by visiting
as many nodes as possible until it reaches a leaf. When then happens, it will
backtrack and find another branch on the tree to drill down on.</p>
<p>Let's see what that means visually:</p>
<p><img src="/golang-datastructures-trees/mydom-tree-dfs-steps.png" alt=""></p>
<p>If this is confusing to you, worry not - I've added a bit more granularity in the
steps to aid my explanation.</p>
<p>The algorithm starts off just like BFS - it walks down from <code>html</code> to <code>body</code>
and to <code>div</code>. Then, instead of continuing to <code>h1</code>, it takes another step to
the leaf <code>span</code>. Once it figures out that <code>span</code> is a leaf, it will move back
up to <code>div</code> to find other branches to explore. Since it won't find any, it will
move back to <code>body</code> to find new branches proceeding to visit <code>h1</code>. Then, it
will do the same exercise again - go back to <code>body</code> and find that there's another
branch to explore - ultimately visiting <code>p</code> and the <code>img</code> nodes.</p>
<p>If you're wondering something along the lines of &ldquo;how can we go back up to the
parent without having a pointer to it&rdquo;, then you're forgetting one of the oldest
tricks in the book - recursion. Let's see a simple recursive Go implementation
of the algorithm:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">findByIdDFS</span>(node <span style="font-weight:bold">*</span>Node, id <span style="color:#458;font-weight:bold">string</span>) <span style="font-weight:bold">*</span>Node {
        <span style="font-weight:bold">if</span> node.id <span style="font-weight:bold">==</span> id {
                <span style="font-weight:bold">return</span> node
        }

        <span style="font-weight:bold">if</span> <span style="color:#999">len</span>(node.children) &gt; <span style="color:#099">0</span> {
                <span style="font-weight:bold">for</span> _, child <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> node.children {
                        <span style="color:#900;font-weight:bold">findByIdDFS</span>(child, id)
                }
        }
        <span style="font-weight:bold">return</span> <span style="font-weight:bold">nil</span>
}</code></pre></div>
<p><img src="/golang-datastructures-trees/people_search.png" alt=""></p>
<h2 id="finding-by-class-name-">Finding by class name ðŸ”Ž</h2>
<p>Another functionality MyDOM <!-- raw HTML omitted -->(TM)<!-- raw HTML omitted --> should have is the ability to find
nodes by a class name. Essentially, when a JavaScript script executes
<code>getElementsByClassName</code>, MyDOM should know how to collect all nodes with a
certain class.</p>
<p>As you can imagine, this is also an algorithm that would have to explore the
whole MyDOM <!-- raw HTML omitted -->(TM)<!-- raw HTML omitted --> tree and pick up the nodes that satisfy certain
conditions.</p>
<p>To make our lives easier, let's first implement a function that a <code>Node</code> can
receive, called <code>hasClass</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> (n <span style="font-weight:bold">*</span>Node) <span style="color:#900;font-weight:bold">hasClass</span>(className <span style="color:#458;font-weight:bold">string</span>) <span style="color:#458;font-weight:bold">bool</span> {
        classes <span style="font-weight:bold">:=</span> strings.<span style="color:#900;font-weight:bold">Fields</span>(n.classes)
        <span style="font-weight:bold">for</span> _, class <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> classes {
                <span style="font-weight:bold">if</span> class <span style="font-weight:bold">==</span> className {
                        <span style="font-weight:bold">return</span> <span style="font-weight:bold">true</span>
                }
        }
        <span style="font-weight:bold">return</span> <span style="font-weight:bold">false</span>
}</code></pre></div>
<p><code>hasClass</code> takes a <code>Node</code>'s classes field, splits them on each space character
and then loops the slice of classes and tries to find the class name that we are
interested in. Let's write a couple of tests that will test this function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> testcase <span style="font-weight:bold">struct</span> {
        className      <span style="color:#458;font-weight:bold">string</span>
        node           Node
        expectedResult <span style="color:#458;font-weight:bold">bool</span>
}

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestHasClass</span>(t <span style="font-weight:bold">*</span>testing.T) {
        cases <span style="font-weight:bold">:=</span> []testcase{
                testcase{
                        className:      <span style="color:#b84">&#34;foo&#34;</span>,
                        node:           Node{classes: <span style="color:#b84">&#34;foo bar&#34;</span>},
                        expectedResult: <span style="font-weight:bold">true</span>,
                },
                testcase{
                        className:      <span style="color:#b84">&#34;foo&#34;</span>,
                        node:           Node{classes: <span style="color:#b84">&#34;bar baz qux&#34;</span>},
                        expectedResult: <span style="font-weight:bold">false</span>,
                },
                testcase{
                        className:      <span style="color:#b84">&#34;bar&#34;</span>,
                        node:           Node{classes: <span style="color:#b84">&#34;&#34;</span>},
                        expectedResult: <span style="font-weight:bold">false</span>,
                },
        }

        <span style="font-weight:bold">for</span> _, <span style="font-weight:bold">case</span> <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> cases {
                result <span style="font-weight:bold">:=</span> <span style="font-weight:bold">case</span>.node.<span style="color:#900;font-weight:bold">hasClass</span>(test.className)
                <span style="font-weight:bold">if</span> result <span style="font-weight:bold">!=</span> <span style="font-weight:bold">case</span>.expectedResult {
                        t.<span style="color:#900;font-weight:bold">Error</span>(
                                <span style="color:#b84">&#34;For node&#34;</span>, <span style="font-weight:bold">case</span>.node,
                                <span style="color:#b84">&#34;and class&#34;</span>, <span style="font-weight:bold">case</span>.className,
                                <span style="color:#b84">&#34;expected&#34;</span>, <span style="font-weight:bold">case</span>.expectedResult,
                                <span style="color:#b84">&#34;got&#34;</span>, result,
                        )
                }
        }
}</code></pre></div>
<p>As you can see, the <code>hasClass</code> function will detect if a class name is in the
list of classes on a <code>Node</code>. Now, let's move on to implementing MyDOM's
implementation of finding all <code>Node</code>s by class name:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">findAllByClassName</span>(root <span style="font-weight:bold">*</span>Node, className <span style="color:#458;font-weight:bold">string</span>) []<span style="font-weight:bold">*</span>Node {
        result <span style="font-weight:bold">:=</span> <span style="color:#999">make</span>([]<span style="font-weight:bold">*</span>Node, <span style="color:#099">0</span>)
        queue <span style="font-weight:bold">:=</span> <span style="color:#999">make</span>([]<span style="font-weight:bold">*</span>Node, <span style="color:#099">0</span>)
        queue = <span style="color:#999">append</span>(queue, root)
        <span style="font-weight:bold">for</span> <span style="color:#999">len</span>(queue) &gt; <span style="color:#099">0</span> {
                nextUp <span style="font-weight:bold">:=</span> queue[<span style="color:#099">0</span>]
                queue = queue[<span style="color:#099">1</span>:]
                <span style="font-weight:bold">if</span> nextUp.<span style="color:#900;font-weight:bold">hasClass</span>(className) {
                        result = <span style="color:#999">append</span>(result, nextUp)
                }
                <span style="font-weight:bold">if</span> <span style="color:#999">len</span>(nextUp.children) &gt; <span style="color:#099">0</span> {
                        <span style="font-weight:bold">for</span> _, child <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> nextUp.children {
                                queue = <span style="color:#999">append</span>(queue, child)
                        }
                }
        }
        <span style="font-weight:bold">return</span> result
}</code></pre></div>
<p>If the algorithm seems familiar, that's because you're looking at a modified
<code>findById</code> function. <code>findAllByClassName</code> works just like <code>findById</code>, but instead
of <code>return</code>ing the moment it finds a match, it will just append the matched
<code>Node</code> to the <code>result</code> slice. It will continue doing that until all of the
<code>Node</code>s have been visited.</p>
<p>If there are no matches, the <code>result</code> slice will be empty. If there are any
matches, they will be returned as part of the <code>result</code> slice.</p>
<p>Last thing worth mentioning is that to traverse the tree we used a Breadth-first
approach here - the algorithm uses a queue for each of the <code>Node</code>s and loops
over them while appending to the <code>result</code> slice if a match is found.</p>
<p><img src="/golang-datastructures-trees/cancel.png" alt=""></p>
<h2 id="deleting-nodes-">Deleting nodes ðŸ—‘</h2>
<p>Another functionality that is often used in the DOM is the ability to remove
nodes. Just like the DOM can do it, also our MyDOM <!-- raw HTML omitted -->(TM)<!-- raw HTML omitted --> should be
able to handle such operations.</p>
<p>The simplest way to do this operation in JavaScript is:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="font-weight:bold">var</span> el <span style="font-weight:bold">=</span> <span style="color:#999">document</span>.getElementById(<span style="color:#b84">&#39;foo&#39;</span>);
el.remove();
</code></pre></div>
<p>While our <code>document</code> knows how to handle <code>getElementById</code> (by calling <code>findById</code>
under the hood), our <code>Node</code>s do not know how to handle a <code>remove</code> function.
Removing a <code>Node</code> from the MyDOM <!-- raw HTML omitted -->(TM)<!-- raw HTML omitted --> tree would be a two-step
process:</p>
<ol>
<li>We have to look up to the <code>parent</code> of the <code>Node</code> and remove it from its
parent's <code>children</code> collection;</li>
<li>If the to-be-removed <code>Node</code> has any children, we have to remove those from
the DOM. This means we have to remove all pointers to each of the children and
its parent (the node to-be-removed) so Go's garbage collector can free up that
memory.</li>
</ol>
<p>And here's a simple way to achieve that:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> (node <span style="font-weight:bold">*</span>Node) <span style="color:#900;font-weight:bold">remove</span>() {
        <span style="color:#998;font-style:italic">// Remove the node from it&#39;s parents children collection
</span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">for</span> idx, sibling <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> n.parent.children {
                <span style="font-weight:bold">if</span> sibling <span style="font-weight:bold">==</span> node {
                        node.parent.children = <span style="color:#999">append</span>(
                                node.parent.children[:idx],
                                node.parent.children[idx<span style="font-weight:bold">+</span><span style="color:#099">1</span>:]<span style="font-weight:bold">...</span>,
                        )
                }
        }

        <span style="color:#998;font-style:italic">// If the node has any children, set their parent to nil and set the node&#39;s children collection to nil
</span><span style="color:#998;font-style:italic"></span>        <span style="font-weight:bold">if</span> <span style="color:#999">len</span>(node.children) <span style="font-weight:bold">!=</span> <span style="color:#099">0</span> {
                <span style="font-weight:bold">for</span> _, child <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> node.children {
                        child.parent = <span style="font-weight:bold">nil</span>
                }
                node.children = <span style="font-weight:bold">nil</span>
        }
}</code></pre></div>
<p>A <code>*Node</code> would have a <code>remove</code> function, which does the two-step process of
the <code>Node</code>'s removal.</p>
<p>In the first step, we take the node out of the <code>parent</code>'s children list, by
looping over them and removing the node by appending the elements before the
node in the list, and the elements after the node.</p>
<p>In the second step, after checking for the presence of any children on the node,
we remove the reference to the <code>parent</code> from all the children and then we set
the <code>Node</code>'s children to <code>nil</code>.</p>
<h2 id="where-to-next">Where to next?</h2>
<p>Obviously, our MyDOM <!-- raw HTML omitted -->(TM)<!-- raw HTML omitted --> implementation is never going to become
a replacement for the DOM. But, I believe that it's an interesting example that
can help you learn and it's pretty interesting problem to think about. We
interact with browsers every day, so thinking how they could function under the
hood is an interesting exercise.</p>
<p>If you would like to play with our tree structure and write more functionality,
you can head over to WC3's JavaScript HTML DOM Document
<a href="https://www.w3schools.com/js/js_htmldom_document.asp">documentation</a> and think
about adding more functionality to MyDOM.</p>
<p>Obviously, the idea behind this article was to learn more about trees (graphs)
and learn about the popular searching/traversal algorithms that are used out
there. But, by all means, please keep on exploring and experimenting and drop me
a comment about what improvements you did to your MyDOM implementation.</p>







<div id="mc_embed_signup">
<form action="https://pm.us20.list-manage.com/subscribe/post?u=d9a6471309140dcd520d05346&amp;id=2aac491644" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
        <div class="heading">Join The Newsletter</div>
        <p>
            I write about backend technologies, programming and cloud architectures. Join hundreds of other developers that get my content, twice a month. Unsubscribe whenever. Never spam.
        </p>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
        <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">

      
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d9a6471309140dcd520d05346_2aac491644" tabindex="-1" value=""></div>

    <p>You can also subscribe <a href="/index.xml">via RSS</a>.</p>
    </div>
</form>
</div>



			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/golang">golang</a></li>
							
							<li><a href="/tags/data-structures">data structures</a></li>
							
							<li><a href="/tags/trees">trees</a></li>
							
						</ul>
					
				
			</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'eftimov';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> Copyright Â© 2014 - 2019 Ilija Eftimov |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-11264459-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
