<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang Datastructures: Trees | Ilija Eftimov ‚ö°Ô∏è</title><meta name=keywords content="trees"><meta name=description content="You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don‚Äôt understand them (which is what I had been doing for a while).
  Now, don&rsquo;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be."><meta name=author content="Ilija Eftimov"><link rel=canonical href=https://ieftimov.com/post/golang-datastructures-trees/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Golang Datastructures: Trees"><meta property="og:description" content="You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don‚Äôt understand them (which is what I had been doing for a while).
  Now, don&rsquo;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/golang-datastructures-trees/"><meta property="og:image" content="https://ieftimov.com/cards/golang-datastructures-trees.png"><meta property="article:section" content="posts"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/golang-datastructures-trees.png"><meta name=twitter:title content="Golang Datastructures: Trees"><meta name=twitter:description content="You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don‚Äôt understand them (which is what I had been doing for a while).
  Now, don&rsquo;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Golang Datastructures: Trees","item":"https://ieftimov.com/post/golang-datastructures-trees/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang Datastructures: Trees","name":"Golang Datastructures: Trees","description":"You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don‚Äôt understand them (which is what I had been doing for a while).\n  Now, don\u0026rsquo;t get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be.","keywords":["trees"],"articleBody":"You can spend quite a bit of your programming career without working with trees, or just by simply avoiding them if you don‚Äôt understand them (which is what I had been doing for a while).\n  Now, don‚Äôt get me wrong - arrays, lists, stacks and queues are quite powerful data structures and can take you pretty far, but there is a limit to their capabilities, how you can use them and how efficient that usage can be. When you throw in hash tables to that mix, you can solve quite some problems, but for many of the problems out there trees are a powerful (and maybe the only) tool if you have them under your belt.\nSo, let‚Äôs look at trees and then we can try to use them in a small exercise.\nA touch of theory Arrays, lists, queues, stacks store data in a collection that has a start and an end, hence they are called ‚Äúlinear‚Äù. But when it comes to trees and graphs, things can get confusing since the data is not stored in a linear fashion.\nTrees are called nonlinear data structures. In fact, you can also say that trees are hierarchical data structures since the data is stored in a hierarchical way.\nFor your reading pleasure, Wikipedia‚Äôs definition of trees:\n A tree is a data structure made up of nodes or vertices and edges without having any cycle. The tree with no nodes is called the null or empty tree. A tree that is not empty consists of a root node and potentially many levels of additional nodes that form a hierarchy.\n What the definition states are that a tree is just a combination of nodes (or vertices) and edges (or links between the nodes) without having a cycle.\n  For example, the data structure represented on the diagram is a combination of nodes, named from A to F, with six edges. Although all of its elements look like they construct a tree, the nodes A, D, E and F have a cycle, therefore this structure is not a tree.\nIf we would break the edge between nodes F and E and add a new node called G with an edge between F and G, we would end up with something like this:\n  Now, since we eliminated the cycle in this graph, we can say that we have a valid tree. It has a root with the name A, with a total of 7 nodes. Node A has 3 children (B, D \u0026 F) and those have 3 children (C, E \u0026 G respectively). Therefore, node A has 6 descendants. Also, this tree has 3 leaf nodes (C, E \u0026 G) or nodes that have no children.\nWhat do B, D \u0026 F have in common? They are siblings because they have the same parent (node A). They all reside on level 1 because to get from each of them to the root we need to take only one step. For example, node G has level 2, because the path from G to A is: G - F - A, hence we need to follow two edges to get to A.\nNow that we know a bit of theory about trees, let‚Äôs see how we can solve some problems.\n  Modelling an HTML document If you are a software developer that has never written any HTML, I will just assume that you have seen (or have an idea) what HTML looks like. If you have not, then I encourage you to right click on the page that you are reading this and click on ‚ÄòView Source‚Äô.\nSeriously, go for it, I‚Äôll wait‚Ä¶\nBrowsers have this thing baked in, called the DOM - a cross-platform and language-independent application programming interface, which treats internet documents as a tree structure wherein each node is an object representing a part of the document. This means that when the browser reads your document‚Äôs HTML code it will load it and create a DOM out of it.\nSo, let‚Äôs imagine for a second we are developers working on a browser, like Chrome or Firefox and we need to model the DOM. Well, to make this exercise easier, let‚Äôs see a tiny HTML document:\nhtml h1Hello, World!h1 pThis is a simple HTML document.p html So, if we would model this document as a tree, it would look something like this:\n  Now, we could treat the text nodes as separate Nodes, but we can make our lives simpler by assuming that any HTML element can have text in it.\nThe html node will have two children, h1 and p, which will have tag, text and children as fields. Let‚Äôs put this into code:\ntype Node struct { tag string text string children []*Node } A Node will have only the tag name and children optionally. Let‚Äôs try to create the HTML document we saw above as a tree of Nodes by hand:\nfunc main() { p := Node{ tag: \"p\", text: \"This is a simple HTML document.\", id: \"foo\", } h1 := Node{ tag: \"h1\", text: \"Hello, World!\", } html := Node{ tag: \"html\", children: []*Node{\u0026p, \u0026h1}, } } That looks okay, we have a basic tree up and running now.\nBuilding MyDOM - a drop-in replacement for the DOM üòÇ Now that we have some tree structure in place, let‚Äôs take a step back and see what kind of functionality would a DOM have. For example, if MyDOM (TM)would be a drop-in replacement of a real DOM, then with JavaScript we should be able to access nodes and modify them.\nThe simplest way to do this with JavaScript would be to use\ndocument.getElementById('foo') This function would lookup in the document tree to find the node whose ID is foo. Let‚Äôs update our Node struct to have more attributes and then work on writing a lookup function for our tree:\ntype Node struct { tag string id string class string children []*Node } Now, each of our Node structs will have a tag, children which is a slice of pointers to the children of that Node, id which is the ID of that DOM node and class which is the classes that can be applied to this DOM node.\nNow, back to our getElementById lookup function. Let‚Äôs see how we could implement it. First, let‚Äôs build an example tree that we can use for our lookup algorithm:\nhtml body h1This is a H1h1 p And this is some text in a paragraph. And next to it there's an image. img src=\"http://example.com/logo.svg\" alt=\"Example's Logo\"/ p div class='footer' This is the footer of the page. span id='copyright'2019 \u0026copy; Ilija Eftimovspan div body html This is a quite complicated HTML document. Let‚Äôs sketch out its structure in Go using the Node struct as a building block:\nimage := Node{ tag: \"img\", src: \"http://example.com/logo.svg\", alt: \"Example's Logo\", } p := Node{ tag: \"p\", text: \"And this is some text in a paragraph. And next to it there's an image.\", children: []*Node{\u0026image}, } span := Node{ tag: \"span\", id: \"copyright\", text: \"2019 \u0026copy; Ilija Eftimov\", } div := Node{ tag: \"div\", class: \"footer\", text: \"This is the footer of the page.\", children: []*Node{\u0026span}, } h1 := Node{ tag: \"h1\", text: \"This is a H1\", } body := Node{ tag: \"body\", children: []*Node{\u0026h1, \u0026p, \u0026div}, } html := Node{ tag: \"html\", children: []*Node{\u0026body}, } We start building this tree bottom - up. That means we create structs from the most deeply nested structs and working up towards body and html. Let‚Äôs look at a graphic of our tree:\n  Implementing Node Lookup üîé So, let‚Äôs continue with what we were up to - allow JavaScript to call getElementById on our document and find the Node that it‚Äôs looking for.\nTo do this, we have to implement a tree searching algorithm. The most popular approaches to searching (or traversal) of graphs and trees are Breadth First Search (BFS) and Depth First Search (DFS).\nBreadth-first search ‚¨Ö‚û° BFS, as its name suggests, takes an approach to traversal where it explores nodes in ‚Äúwidth‚Äù first before it goes in ‚Äúdepth‚Äù. Here‚Äôs a visualisation of the steps a BFS algorithm would take to traverse the whole tree:\nAs you can see, the algorithm will take two steps in depth (over html and body), but then it will visit all of the body‚Äôs children nodes before it proceeds to explore in depth and visit the span and img nodes.\nIf you would like to have a step-by-step playbook, it would be:\n We start at the root, the html node We push it on the queue We kick off a loop where we loop while the queue is not empty We check the next element in the queue for a match. If a match is found, we return the match and we‚Äôre done. When a match is not found, we take all of the children of the node-under-inspection and we add them to the queue, so they can be inspected GOTO 4  Let‚Äôs see a simple implementation of the algorithm in Go and I‚Äôll share some tips on how you can remember the algorithm easily.\nfunc findById(root *Node, id string) *Node { queue := make([]*Node, 0) queue = append(queue, root) for len(queue)  0 { nextUp := queue[0] queue = queue[1:] if nextUp.id == id { return nextUp } if len(nextUp.children)  0 { for _, child := range nextUp.children { queue = append(queue, child) } } } return nil } The algorithm has three key points:\n The queue - it will contain all of the nodes that the algorithm visits Taking the first element of the queue, checking it for a match, and proceeding with the next nodes if no match is found Queueing up all of the children nodes for a node before moving on in the queue  Essentially, the whole algorithm revolves around pushing children nodes on a queue and inspecting the nodes that are queued up. Of course, if a match is not found at the end we return nil instead of a pointer to a Node.\nDepth-first search ‚¨á For completeness sake, let‚Äôs also see how DFS would work.\nAs we stated earlier, the depth-first search will go first in depth by visiting as many nodes as possible until it reaches a leaf. When then happens, it will backtrack and find another branch on the tree to drill down on.\nLet‚Äôs see what that means visually:\nIf this is confusing to you, worry not - I‚Äôve added a bit more granularity in the steps to aid my explanation.\nThe algorithm starts off just like BFS - it walks down from html to body and to div. Then, instead of continuing to h1, it takes another step to the leaf span. Once it figures out that span is a leaf, it will move back up to div to find other branches to explore. Since it won‚Äôt find any, it will move back to body to find new branches proceeding to visit h1. Then, it will do the same exercise again - go back to body and find that there‚Äôs another branch to explore - ultimately visiting p and the img nodes.\nIf you‚Äôre wondering something along the lines of ‚Äúhow can we go back up to the parent without having a pointer to it‚Äù, then you‚Äôre forgetting one of the oldest tricks in the book - recursion. Let‚Äôs see a simple recursive Go implementation of the algorithm:\nfunc findByIdDFS(node *Node, id string) *Node { if node.id == id { return node } if len(node.children)  0 { for _, child := range node.children { findByIdDFS(child, id) } } return nil }   Finding by class name üîé Another functionality MyDOM (TM)should have is the ability to find nodes by a class name. Essentially, when a JavaScript script executes getElementsByClassName, MyDOM should know how to collect all nodes with a certain class.\nAs you can imagine, this is also an algorithm that would have to explore the whole MyDOM (TM)tree and pick up the nodes that satisfy certain conditions.\nTo make our lives easier, let‚Äôs first implement a function that a Node can receive, called hasClass:\nfunc (n *Node) hasClass(className string) bool { classes := strings.Fields(n.classes) for _, class := range classes { if class == className { return true } } return false } hasClass takes a Node‚Äôs classes field, splits them on each space character and then loops the slice of classes and tries to find the class name that we are interested in. Let‚Äôs write a couple of tests that will test this function:\ntype testcase struct { className string node Node expectedResult bool } func TestHasClass(t *testing.T) { cases := []testcase{ testcase{ className: \"foo\", node: Node{classes: \"foo bar\"}, expectedResult: true, }, testcase{ className: \"foo\", node: Node{classes: \"bar baz qux\"}, expectedResult: false, }, testcase{ className: \"bar\", node: Node{classes: \"\"}, expectedResult: false, }, } for _, case := range cases { result := case.node.hasClass(test.className) if result != case.expectedResult { t.Error( \"For node\", case.node, \"and class\", case.className, \"expected\", case.expectedResult, \"got\", result, ) } } } As you can see, the hasClass function will detect if a class name is in the list of classes on a Node. Now, let‚Äôs move on to implementing MyDOM‚Äôs implementation of finding all Nodes by class name:\nfunc findAllByClassName(root *Node, className string) []*Node { result := make([]*Node, 0) queue := make([]*Node, 0) queue = append(queue, root) for len(queue)  0 { nextUp := queue[0] queue = queue[1:] if nextUp.hasClass(className) { result = append(result, nextUp) } if len(nextUp.children)  0 { for _, child := range nextUp.children { queue = append(queue, child) } } } return result } If the algorithm seems familiar, that‚Äôs because you‚Äôre looking at a modified findById function. findAllByClassName works just like findById, but instead of returning the moment it finds a match, it will just append the matched Node to the result slice. It will continue doing that until all of the Nodes have been visited.\nIf there are no matches, the result slice will be empty. If there are any matches, they will be returned as part of the result slice.\nLast thing worth mentioning is that to traverse the tree we used a Breadth-first approach here - the algorithm uses a queue for each of the Nodes and loops over them while appending to the result slice if a match is found.\n  Deleting nodes üóë Another functionality that is often used in the DOM is the ability to remove nodes. Just like the DOM can do it, also our MyDOM (TM)should be able to handle such operations.\nThe simplest way to do this operation in JavaScript is:\nvar el = document.getElementById('foo'); el.remove(); While our document knows how to handle getElementById (by calling findById under the hood), our Nodes do not know how to handle a remove function. Removing a Node from the MyDOM (TM)tree would be a two-step process:\n We have to look up to the parent of the Node and remove it from its parent‚Äôs children collection; If the to-be-removed Node has any children, we have to remove those from the DOM. This means we have to remove all pointers to each of the children and its parent (the node to-be-removed) so Go‚Äôs garbage collector can free up that memory.  And here‚Äôs a simple way to achieve that:\nfunc (node *Node) remove() { // Remove the node from it's parents children collection  for idx, sibling := range n.parent.children { if sibling == node { node.parent.children = append( node.parent.children[:idx], node.parent.children[idx+1:]..., ) } } // If the node has any children, set their parent to nil and set the node's children collection to nil  if len(node.children) != 0 { for _, child := range node.children { child.parent = nil } node.children = nil } } A *Node would have a remove function, which does the two-step process of the Node‚Äôs removal.\nIn the first step, we take the node out of the parent‚Äôs children list, by looping over them and removing the node by appending the elements before the node in the list, and the elements after the node.\nIn the second step, after checking for the presence of any children on the node, we remove the reference to the parent from all the children and then we set the Node‚Äôs children to nil.\nWhere to next? Obviously, our MyDOM (TM)implementation is never going to become a replacement for the DOM. But, I believe that it‚Äôs an interesting example that can help you learn and it‚Äôs pretty interesting problem to think about. We interact with browsers every day, so thinking how they could function under the hood is an interesting exercise.\nIf you would like to play with our tree structure and write more functionality, you can head over to WC3‚Äôs JavaScript HTML DOM Document documentation and think about adding more functionality to MyDOM.\nObviously, the idea behind this article was to learn more about trees (graphs) and learn about the popular searching/traversal algorithms that are used out there. But, by all means, please keep on exploring and experimenting and drop me a comment about what improvements you did to your MyDOM implementation.\nLiked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to hundreds of other engineers.\n    ","wordCount":"2875","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija Eftimov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/golang-datastructures-trees/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ‚ö°Ô∏è","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ‚ö°Ô∏è (Alt + H)">Ilija Eftimov ‚ö°Ô∏è</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ‚òï"><span>Buy me a ‚òï</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Golang Datastructures: Trees</h1><div class=post-meta>February 13, 2019&nbsp;¬∑&nbsp;14 min&nbsp;¬∑&nbsp;Ilija Eftimov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#a-touch-of-theory aria-label="A touch of theory">A touch of theory</a></li><li><a href=#modelling-an-html-document aria-label="Modelling an HTML document">Modelling an HTML document</a></li><li><a href=#building-mydom---a-drop-in-replacement-for-the-dom- aria-label="Building MyDOM - a drop-in replacement for the DOM üòÇ">Building MyDOM - a drop-in replacement for the DOM üòÇ</a></li><li><a href=#implementing-node-lookup- aria-label="Implementing Node Lookup üîé">Implementing Node Lookup üîé</a><ul><li><a href=#breadth-first-search- aria-label="Breadth-first search ‚¨Ö‚û°">Breadth-first search ‚¨Ö‚û°</a></li><li><a href=#depth-first-search- aria-label="Depth-first search ‚¨á">Depth-first search ‚¨á</a></li></ul></li><li><a href=#finding-by-class-name- aria-label="Finding by class name üîé">Finding by class name üîé</a></li><li><a href=#deleting-nodes- aria-label="Deleting nodes üóë">Deleting nodes üóë</a></li><li><a href=#where-to-next aria-label="Where to next?">Where to next?</a></li></ul></div></details></div><div class=post-content><p>You can spend quite a bit of your programming career without working with trees,
or just by simply avoiding them if you don‚Äôt understand them (which is what I
had been doing for a while).</p><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/tree_swing.png caption alt="Person sitting on a swing on a tree">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Now, don&rsquo;t get me wrong - arrays, lists, stacks and queues are quite powerful
data structures and can take you pretty far, but there is a limit to their
capabilities, how you can use them and how efficient that usage can be. When you
throw in hash tables to that mix, you can solve quite some problems, but for
many of the problems out there trees are a powerful (and maybe the only) tool
if you have them under your belt.</p><p>So, let&rsquo;s look at trees and then we can try to use them in a small exercise.</p><h2 id=a-touch-of-theory>A touch of theory<a hidden class=anchor aria-hidden=true href=#a-touch-of-theory>#</a></h2><p>Arrays, lists, queues, stacks store data in a collection that has a start and an
end, hence they are called &ldquo;linear&rdquo;. But when it comes to trees and graphs,
things can get confusing since the data is not stored in a linear fashion.</p><p>Trees are called nonlinear data structures. In fact, you can also say that trees
are hierarchical data structures since the data is stored in a hierarchical way.</p><p>For your reading pleasure, Wikipedia‚Äôs definition of trees:</p><blockquote><p>A tree is a data structure made up of nodes or vertices and edges without
having any cycle. The tree with no nodes is called the null or empty tree. A
tree that is not empty consists of a root node and potentially many levels of
additional nodes that form a hierarchy.</p></blockquote><p>What the definition states are that a tree is just a combination of nodes (or
vertices) and edges (or links between the nodes) without having a cycle.</p><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/invalid-tree.png caption alt="Graph data structure graphic">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>For example, the data structure represented on the diagram is a combination of
nodes, named from A to F, with six edges. Although all of its elements look
like they construct a tree, the nodes A, D, E and F have a cycle, therefore
this structure is not a tree.</p><p>If we would break the edge between nodes F and E and add a new node called G
with an edge between F and G, we would end up with something like this:</p><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/valid-tree.png caption alt="Tree data structure graphic">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Now, since we eliminated the cycle in this graph, we can say that we have a
valid tree. It has a <strong>root</strong> with the name A, with a total of 7 <strong>nodes</strong>.
Node A has 3 <strong>children</strong> (B, D & F) and those have 3 children (C, E & G
respectively). Therefore, node A has 6 <strong>descendants</strong>. Also, this tree has 3
leaf nodes (C, E & G) or nodes that have no children.</p><p>What do B, D & F have in common? They are <strong>siblings</strong> because they have the
same parent (node A). They all reside on <strong>level</strong> 1 because to get from each
of them to the root we need to take only one step. For example, node G has
level 2, because the <strong>path</strong> from G to A is: G -> F -> A, hence we need to
follow two edges to get to A.</p><p>Now that we know a bit of theory about trees, let‚Äôs see how we can solve some
problems.</p><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/web_development.png caption alt="Web developer">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=modelling-an-html-document>Modelling an HTML document<a hidden class=anchor aria-hidden=true href=#modelling-an-html-document>#</a></h2><p>If you are a software developer that has never written any HTML, I will just
assume that you have seen (or have an idea) what HTML looks like. If you have
not, then I encourage you to right click on the page that you are reading this
and click on &lsquo;View Source&rsquo;.</p><p>Seriously, go for it, I&rsquo;ll wait&mldr;</p><p>Browsers have this thing baked in, called the DOM - a cross-platform and
language-independent application programming interface, which treats internet
documents as a tree structure wherein each node is an object representing a part
of the document. This means that when the browser reads your document&rsquo;s HTML
code it will load it and create a DOM out of it.</p><p>So, let‚Äôs imagine for a second we are developers working on a browser, like
Chrome or Firefox and we need to model the DOM. Well, to make this exercise
easier, let‚Äôs see a tiny HTML document:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#268bd2>html</span>&gt;
  &lt;<span style=color:#268bd2>h1</span>&gt;Hello, World!&lt;/<span style=color:#268bd2>h1</span>&gt;
  &lt;<span style=color:#268bd2>p</span>&gt;This is a simple HTML document.&lt;/<span style=color:#268bd2>p</span>&gt;
&lt;/<span style=color:#268bd2>html</span>&gt;</code></pre></div><p>So, if we would model this document as a tree, it would look something like
this:</p><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/html-document-tree.png caption alt="DOM node tree">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Now, we could treat the text nodes as separate <code>Node</code>s, but we can make our
lives simpler by assuming that any HTML element can have text in it.</p><p>The <code>html</code> node will have two children, <code>h1</code> and <code>p</code>, which will have <code>tag</code>,
<code>text</code> and <code>children</code> as fields. Let‚Äôs put this into code:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> Node <span style=color:#268bd2>struct</span> {
    tag      <span style=color:#dc322f>string</span>
    text     <span style=color:#dc322f>string</span>
    children []<span style=color:#719e07>*</span>Node
}</code></pre></div><p>A <code>Node</code> will have only the tag name and children optionally. Let‚Äôs try to
create the HTML document we saw above as a tree of <code>Node</code>s by hand:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
        p <span style=color:#719e07>:=</span> Node{
                tag:  <span style=color:#2aa198>&#34;p&#34;</span>,
                text: <span style=color:#2aa198>&#34;This is a simple HTML document.&#34;</span>,
                id:   <span style=color:#2aa198>&#34;foo&#34;</span>,
        }

        h1 <span style=color:#719e07>:=</span> Node{
                tag:  <span style=color:#2aa198>&#34;h1&#34;</span>,
                text: <span style=color:#2aa198>&#34;Hello, World!&#34;</span>,
        }

        html <span style=color:#719e07>:=</span> Node{
                tag:      <span style=color:#2aa198>&#34;html&#34;</span>,
                children: []<span style=color:#719e07>*</span>Node{<span style=color:#719e07>&amp;</span>p, <span style=color:#719e07>&amp;</span>h1},
        }
}</code></pre></div><p>That looks okay, we have a basic tree up and running now.</p><h2 id=building-mydom---a-drop-in-replacement-for-the-dom->Building MyDOM - a drop-in replacement for the DOM üòÇ<a hidden class=anchor aria-hidden=true href=#building-mydom---a-drop-in-replacement-for-the-dom->#</a></h2><p>Now that we have some tree structure in place, let&rsquo;s take a step back and see
what kind of functionality would a DOM have. For example, if MyDOM
(TM) would be a drop-in replacement of a real DOM, then with
JavaScript we should be able to access nodes and modify them.</p><p>The simplest way to do this with JavaScript would be to use</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#b58900>document</span>.getElementById(<span style=color:#2aa198>&#39;foo&#39;</span>)</code></pre></div><p>This function would lookup in the <code>document</code> tree to find the node whose ID is
<code>foo</code>. Let&rsquo;s update our <code>Node</code> struct to have more attributes and then work on
writing a lookup function for our tree:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> Node <span style=color:#268bd2>struct</span> {
  tag      <span style=color:#dc322f>string</span>
  id       <span style=color:#dc322f>string</span>
  class    <span style=color:#dc322f>string</span>
  children []<span style=color:#719e07>*</span>Node
}</code></pre></div><p>Now, each of our <code>Node</code> structs will have a <code>tag</code>, <code>children</code> which is a slice
of pointers to the children of that <code>Node</code>, <code>id</code> which is the ID of that DOM
node and <code>class</code> which is the classes that can be applied to this DOM node.</p><p>Now, back to our <code>getElementById</code> lookup function. Let&rsquo;s see how we could
implement it. First, let&rsquo;s build an example tree that we can use for our lookup
algorithm:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#268bd2>html</span>&gt;
  &lt;<span style=color:#268bd2>body</span>&gt;
    &lt;<span style=color:#268bd2>h1</span>&gt;This is a H1&lt;/<span style=color:#268bd2>h1</span>&gt;
    &lt;<span style=color:#268bd2>p</span>&gt;
      And this is some text in a paragraph. And next to it there&#39;s an image.
      &lt;<span style=color:#268bd2>img</span> src<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;http://example.com/logo.svg&#34;</span> alt<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;Example&#39;s Logo&#34;</span>/&gt;
    &lt;/<span style=color:#268bd2>p</span>&gt;
    &lt;<span style=color:#268bd2>div</span> class<span style=color:#719e07>=</span><span style=color:#2aa198>&#39;footer&#39;</span>&gt;
      This is the footer of the page.
      &lt;<span style=color:#268bd2>span</span> id<span style=color:#719e07>=</span><span style=color:#2aa198>&#39;copyright&#39;</span>&gt;2019 <span style=color:#cb4b16>&amp;copy;</span> Ilija Eftimov&lt;/<span style=color:#268bd2>span</span>&gt;
    &lt;/<span style=color:#268bd2>div</span>&gt;
  &lt;/<span style=color:#268bd2>body</span>&gt;
&lt;/<span style=color:#268bd2>html</span>&gt;</code></pre></div><p>This is a quite complicated HTML document. Let&rsquo;s sketch out its structure in Go
using the <code>Node</code> struct as a building block:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>image <span style=color:#719e07>:=</span> Node{
        tag: <span style=color:#2aa198>&#34;img&#34;</span>,
        src: <span style=color:#2aa198>&#34;http://example.com/logo.svg&#34;</span>,
        alt: <span style=color:#2aa198>&#34;Example&#39;s Logo&#34;</span>,
}

p <span style=color:#719e07>:=</span> Node{
        tag:      <span style=color:#2aa198>&#34;p&#34;</span>,
        text:     <span style=color:#2aa198>&#34;And this is some text in a paragraph. And next to it there&#39;s an image.&#34;</span>,
        children: []<span style=color:#719e07>*</span>Node{<span style=color:#719e07>&amp;</span>image},
}

span <span style=color:#719e07>:=</span> Node{
        tag:  <span style=color:#2aa198>&#34;span&#34;</span>,
        id:   <span style=color:#2aa198>&#34;copyright&#34;</span>,
        text: <span style=color:#2aa198>&#34;2019 &amp;copy; Ilija Eftimov&#34;</span>,
}

div <span style=color:#719e07>:=</span> Node{
        tag:      <span style=color:#2aa198>&#34;div&#34;</span>,
        class:    <span style=color:#2aa198>&#34;footer&#34;</span>,
        text:     <span style=color:#2aa198>&#34;This is the footer of the page.&#34;</span>,
        children: []<span style=color:#719e07>*</span>Node{<span style=color:#719e07>&amp;</span>span},
}

h1 <span style=color:#719e07>:=</span> Node{
        tag:  <span style=color:#2aa198>&#34;h1&#34;</span>,
        text: <span style=color:#2aa198>&#34;This is a H1&#34;</span>,
}

body <span style=color:#719e07>:=</span> Node{
        tag:      <span style=color:#2aa198>&#34;body&#34;</span>,
        children: []<span style=color:#719e07>*</span>Node{<span style=color:#719e07>&amp;</span>h1, <span style=color:#719e07>&amp;</span>p, <span style=color:#719e07>&amp;</span>div},
}

html <span style=color:#719e07>:=</span> Node{
        tag:      <span style=color:#2aa198>&#34;html&#34;</span>,
        children: []<span style=color:#719e07>*</span>Node{<span style=color:#719e07>&amp;</span>body},
}</code></pre></div><p>We start building this tree bottom - up. That means we create structs from the
most deeply nested structs and working up towards <code>body</code> and <code>html</code>. Let&rsquo;s look
at a graphic of our tree:</p><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/mydom-tree.png caption alt="DOM node tree">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=implementing-node-lookup->Implementing Node Lookup üîé<a hidden class=anchor aria-hidden=true href=#implementing-node-lookup->#</a></h2><p>So, let&rsquo;s continue with what we were up to - allow JavaScript to call
<code>getElementById</code> on our <code>document</code> and find the <code>Node</code> that it&rsquo;s looking for.</p><p>To do this, we have to implement a tree searching algorithm. The most popular
approaches to searching (or traversal) of graphs and trees are Breadth First
Search (BFS) and Depth First Search (DFS).</p><h3 id=breadth-first-search->Breadth-first search ‚¨Ö‚û°<a hidden class=anchor aria-hidden=true href=#breadth-first-search->#</a></h3><p>BFS, as its name suggests, takes an approach to traversal where it explores
nodes in &ldquo;width&rdquo; first before it goes in &ldquo;depth&rdquo;. Here&rsquo;s a visualisation of the
steps a BFS algorithm would take to traverse the whole tree:</p><p><img src=/golang-datastructures-trees/mydom-tree-bfs-steps.png alt></p><p>As you can see, the algorithm will take two steps in depth (over <code>html</code> and
<code>body</code>), but then it will visit all of the <code>body</code>&rsquo;s children nodes before it
proceeds to explore in depth and visit the <code>span</code> and <code>img</code> nodes.</p><p>If you would like to have a step-by-step playbook, it would be:</p><ol><li>We start at the root, the <code>html</code> node</li><li>We push it on the <code>queue</code></li><li>We kick off a loop where we loop while the <code>queue</code> is not empty</li><li>We check the next element in the <code>queue</code> for a match. If a match is found,
we return the match and we&rsquo;re done.</li><li>When a match is not found, we take all of the children of the
node-under-inspection and we add them to the queue, so they can be inspected</li><li><code>GOTO</code> 4</li></ol><p>Let&rsquo;s see a simple implementation of the algorithm in Go and I&rsquo;ll share some
tips on how you can remember the algorithm easily.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>findById</span>(root <span style=color:#719e07>*</span>Node, id <span style=color:#dc322f>string</span>) <span style=color:#719e07>*</span>Node {
        queue <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#719e07>*</span>Node, <span style=color:#2aa198>0</span>)
        queue = <span style=color:#b58900>append</span>(queue, root)
        <span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(queue) &gt; <span style=color:#2aa198>0</span> {
                nextUp <span style=color:#719e07>:=</span> queue[<span style=color:#2aa198>0</span>]
                queue = queue[<span style=color:#2aa198>1</span>:]
                <span style=color:#719e07>if</span> nextUp.id <span style=color:#719e07>==</span> id {
                        <span style=color:#719e07>return</span> nextUp
                }
                <span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(nextUp.children) &gt; <span style=color:#2aa198>0</span> {
                        <span style=color:#719e07>for</span> _, child <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> nextUp.children {
                                queue = <span style=color:#b58900>append</span>(queue, child)
                        }
                }
        }
        <span style=color:#719e07>return</span> <span style=color:#cb4b16>nil</span>
}</code></pre></div><p>The algorithm has three key points:</p><ol><li>The <code>queue</code> - it will contain all of the nodes that the algorithm visits</li><li>Taking the first element of the <code>queue</code>, checking it for a match, and
proceeding with the next nodes if no match is found</li><li><code>Queue</code>ing up all of the children nodes for a node before moving on in the
<code>queue</code></li></ol><p>Essentially, the whole algorithm revolves around pushing children nodes on a
queue and inspecting the nodes that are queued up. Of course, if a match is not
found at the end we return <code>nil</code> instead of a pointer to a <code>Node</code>.</p><h3 id=depth-first-search->Depth-first search ‚¨á<a hidden class=anchor aria-hidden=true href=#depth-first-search->#</a></h3><p>For completeness sake, let&rsquo;s also see how DFS would work.</p><p>As we stated earlier, the depth-first search will go first in depth by visiting
as many nodes as possible until it reaches a leaf. When then happens, it will
backtrack and find another branch on the tree to drill down on.</p><p>Let&rsquo;s see what that means visually:</p><p><img src=/golang-datastructures-trees/mydom-tree-dfs-steps.png alt></p><p>If this is confusing to you, worry not - I&rsquo;ve added a bit more granularity in
the steps to aid my explanation.</p><p>The algorithm starts off just like BFS - it walks down from <code>html</code> to <code>body</code>
and to <code>div</code>. Then, instead of continuing to <code>h1</code>, it takes another step to the
leaf <code>span</code>. Once it figures out that <code>span</code> is a leaf, it will move back up to
<code>div</code> to find other branches to explore. Since it won&rsquo;t find any, it will move
back to <code>body</code> to find new branches proceeding to visit <code>h1</code>. Then, it will do
the same exercise again - go back to <code>body</code> and find that there&rsquo;s another
branch to explore - ultimately visiting <code>p</code> and the <code>img</code> nodes.</p><p>If you&rsquo;re wondering something along the lines of &ldquo;how can we go back up to the
parent without having a pointer to it&rdquo;, then you&rsquo;re forgetting one of the
oldest tricks in the book - recursion. Let&rsquo;s see a simple recursive Go
implementation of the algorithm:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>findByIdDFS</span>(node <span style=color:#719e07>*</span>Node, id <span style=color:#dc322f>string</span>) <span style=color:#719e07>*</span>Node {
        <span style=color:#719e07>if</span> node.id <span style=color:#719e07>==</span> id {
                <span style=color:#719e07>return</span> node
        }

        <span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(node.children) &gt; <span style=color:#2aa198>0</span> {
                <span style=color:#719e07>for</span> _, child <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> node.children {
                        <span style=color:#268bd2>findByIdDFS</span>(child, id)
                }
        }
        <span style=color:#719e07>return</span> <span style=color:#cb4b16>nil</span>
}</code></pre></div><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/people_search.png caption alt="People search graphic">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=finding-by-class-name->Finding by class name üîé<a hidden class=anchor aria-hidden=true href=#finding-by-class-name->#</a></h2><p>Another functionality MyDOM (TM) should have is the ability to find
nodes by a class name. Essentially, when a JavaScript script executes
<code>getElementsByClassName</code>, MyDOM should know how to collect all nodes with a
certain class.</p><p>As you can imagine, this is also an algorithm that would have to explore the
whole MyDOM (TM) tree and pick up the nodes that satisfy certain
conditions.</p><p>To make our lives easier, let&rsquo;s first implement a function that a <code>Node</code> can
receive, called <code>hasClass</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (n <span style=color:#719e07>*</span>Node) <span style=color:#268bd2>hasClass</span>(className <span style=color:#dc322f>string</span>) <span style=color:#dc322f>bool</span> {
        classes <span style=color:#719e07>:=</span> strings.<span style=color:#268bd2>Fields</span>(n.classes)
        <span style=color:#719e07>for</span> _, class <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> classes {
                <span style=color:#719e07>if</span> class <span style=color:#719e07>==</span> className {
                        <span style=color:#719e07>return</span> <span style=color:#cb4b16>true</span>
                }
        }
        <span style=color:#719e07>return</span> <span style=color:#cb4b16>false</span>
}</code></pre></div><p><code>hasClass</code> takes a <code>Node</code>&rsquo;s classes field, splits them on each space character
and then loops the slice of classes and tries to find the class name that we are
interested in. Let&rsquo;s write a couple of tests that will test this function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> testcase <span style=color:#268bd2>struct</span> {
        className      <span style=color:#dc322f>string</span>
        node           Node
        expectedResult <span style=color:#dc322f>bool</span>
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestHasClass</span>(t <span style=color:#719e07>*</span>testing.T) {
        cases <span style=color:#719e07>:=</span> []testcase{
                testcase{
                        className:      <span style=color:#2aa198>&#34;foo&#34;</span>,
                        node:           Node{classes: <span style=color:#2aa198>&#34;foo bar&#34;</span>},
                        expectedResult: <span style=color:#cb4b16>true</span>,
                },
                testcase{
                        className:      <span style=color:#2aa198>&#34;foo&#34;</span>,
                        node:           Node{classes: <span style=color:#2aa198>&#34;bar baz qux&#34;</span>},
                        expectedResult: <span style=color:#cb4b16>false</span>,
                },
                testcase{
                        className:      <span style=color:#2aa198>&#34;bar&#34;</span>,
                        node:           Node{classes: <span style=color:#2aa198>&#34;&#34;</span>},
                        expectedResult: <span style=color:#cb4b16>false</span>,
                },
        }

        <span style=color:#719e07>for</span> _, <span style=color:#719e07>case</span> <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> cases {
                result <span style=color:#719e07>:=</span> <span style=color:#719e07>case</span>.node.<span style=color:#268bd2>hasClass</span>(test.className)
                <span style=color:#719e07>if</span> result <span style=color:#719e07>!=</span> <span style=color:#719e07>case</span>.expectedResult {
                        t.<span style=color:#268bd2>Error</span>(
                                <span style=color:#2aa198>&#34;For node&#34;</span>, <span style=color:#719e07>case</span>.node,
                                <span style=color:#2aa198>&#34;and class&#34;</span>, <span style=color:#719e07>case</span>.className,
                                <span style=color:#2aa198>&#34;expected&#34;</span>, <span style=color:#719e07>case</span>.expectedResult,
                                <span style=color:#2aa198>&#34;got&#34;</span>, result,
                        )
                }
        }
}</code></pre></div><p>As you can see, the <code>hasClass</code> function will detect if a class name is in the
list of classes on a <code>Node</code>. Now, let&rsquo;s move on to implementing MyDOM&rsquo;s
implementation of finding all <code>Node</code>s by class name:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>findAllByClassName</span>(root <span style=color:#719e07>*</span>Node, className <span style=color:#dc322f>string</span>) []<span style=color:#719e07>*</span>Node {
        result <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#719e07>*</span>Node, <span style=color:#2aa198>0</span>)
        queue <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#719e07>*</span>Node, <span style=color:#2aa198>0</span>)
        queue = <span style=color:#b58900>append</span>(queue, root)
        <span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(queue) &gt; <span style=color:#2aa198>0</span> {
                nextUp <span style=color:#719e07>:=</span> queue[<span style=color:#2aa198>0</span>]
                queue = queue[<span style=color:#2aa198>1</span>:]
                <span style=color:#719e07>if</span> nextUp.<span style=color:#268bd2>hasClass</span>(className) {
                        result = <span style=color:#b58900>append</span>(result, nextUp)
                }
                <span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(nextUp.children) &gt; <span style=color:#2aa198>0</span> {
                        <span style=color:#719e07>for</span> _, child <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> nextUp.children {
                                queue = <span style=color:#b58900>append</span>(queue, child)
                        }
                }
        }
        <span style=color:#719e07>return</span> result
}</code></pre></div><p>If the algorithm seems familiar, that&rsquo;s because you&rsquo;re looking at a modified
<code>findById</code> function. <code>findAllByClassName</code> works just like <code>findById</code>, but
instead of <code>return</code>ing the moment it finds a match, it will just append the
matched <code>Node</code> to the <code>result</code> slice. It will continue doing that until all of
the <code>Node</code>s have been visited.</p><p>If there are no matches, the <code>result</code> slice will be empty. If there are any
matches, they will be returned as part of the <code>result</code> slice.</p><p>Last thing worth mentioning is that to traverse the tree we used a
Breadth-first approach here - the algorithm uses a queue for each of the
<code>Node</code>s and loops over them while appending to the <code>result</code> slice if a match is
found.</p><figure class=imagecaption><img class=caption src=/golang-datastructures-trees/cancel.png caption alt="Delete graphic">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=deleting-nodes->Deleting nodes üóë<a hidden class=anchor aria-hidden=true href=#deleting-nodes->#</a></h2><p>Another functionality that is often used in the DOM is the ability to remove
nodes. Just like the DOM can do it, also our MyDOM (TM) should be
able to handle such operations.</p><p>The simplest way to do this operation in JavaScript is:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#268bd2>var</span> el <span style=color:#719e07>=</span> <span style=color:#b58900>document</span>.getElementById(<span style=color:#2aa198>&#39;foo&#39;</span>);
el.remove();</code></pre></div><p>While our <code>document</code> knows how to handle <code>getElementById</code> (by calling
<code>findById</code> under the hood), our <code>Node</code>s do not know how to handle a <code>remove</code>
function. Removing a <code>Node</code> from the MyDOM (TM) tree would be a
two-step process:</p><ol><li>We have to look up to the <code>parent</code> of the <code>Node</code> and remove it from its
parent&rsquo;s <code>children</code> collection;</li><li>If the to-be-removed <code>Node</code> has any children, we have to remove those from
the DOM. This means we have to remove all pointers to each of the children
and its parent (the node to-be-removed) so Go&rsquo;s garbage collector can free
up that memory.</li></ol><p>And here&rsquo;s a simple way to achieve that:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> (node <span style=color:#719e07>*</span>Node) <span style=color:#268bd2>remove</span>() {
        <span style=color:#586e75>// Remove the node from it&#39;s parents children collection
</span><span style=color:#586e75></span>        <span style=color:#719e07>for</span> idx, sibling <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> n.parent.children {
                <span style=color:#719e07>if</span> sibling <span style=color:#719e07>==</span> node {
                        node.parent.children = <span style=color:#b58900>append</span>(
                                node.parent.children[:idx],
                                node.parent.children[idx<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>:]<span style=color:#719e07>...</span>,
                        )
                }
        }

        <span style=color:#586e75>// If the node has any children, set their parent to nil and set the node&#39;s children collection to nil
</span><span style=color:#586e75></span>        <span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(node.children) <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span> {
                <span style=color:#719e07>for</span> _, child <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> node.children {
                        child.parent = <span style=color:#cb4b16>nil</span>
                }
                node.children = <span style=color:#cb4b16>nil</span>
        }
}</code></pre></div><p>A <code>*Node</code> would have a <code>remove</code> function, which does the two-step process of
the <code>Node</code>&rsquo;s removal.</p><p>In the first step, we take the node out of the <code>parent</code>&rsquo;s children list, by
looping over them and removing the node by appending the elements before the
node in the list, and the elements after the node.</p><p>In the second step, after checking for the presence of any children on the
node, we remove the reference to the <code>parent</code> from all the children and then we
set the <code>Node</code>&rsquo;s children to <code>nil</code>.</p><h2 id=where-to-next>Where to next?<a hidden class=anchor aria-hidden=true href=#where-to-next>#</a></h2><p>Obviously, our MyDOM (TM) implementation is never going to become a
replacement for the DOM. But, I believe that it&rsquo;s an interesting example that
can help you learn and it&rsquo;s pretty interesting problem to think about. We
interact with browsers every day, so thinking how they could function under the
hood is an interesting exercise.</p><p>If you would like to play with our tree structure and write more functionality,
you can head over to WC3&rsquo;s JavaScript HTML DOM Document
<a href=https://www.w3schools.com/js/js_htmldom_document.asp>documentation</a> and think
about adding more functionality to MyDOM.</p><p>Obviously, the idea behind this article was to learn more about trees (graphs)
and learn about the popular searching/traversal algorithms that are used out
there. But, by all means, please keep on exploring and experimenting and drop
me a comment about what improvements you did to your MyDOM implementation.</p><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to hundreds of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/trees/>trees</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/><span class=title>¬´ Prev Page</span><br><span>When and Why to use a Least Frequently Used (LFU) cache with an implementation in Golang</span></a>
<a class=next href=https://ieftimov.com/post/otp-elixir-genserver-build-own-url-shortener/><span class=title>Next Page ¬ª</span><br><span>OTP in Elixir: Learn GenServer by Building Your Own URL Shortener</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Golang Datastructures: Trees on twitter" href="https://twitter.com/intent/tweet/?text=Golang%20Datastructures%3a%20Trees&url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-trees%2f&hashtags=trees"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang Datastructures: Trees on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-trees%2f&title=Golang%20Datastructures%3a%20Trees&summary=Golang%20Datastructures%3a%20Trees&source=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-trees%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang Datastructures: Trees on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-trees%2f&title=Golang%20Datastructures%3a%20Trees"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang Datastructures: Trees on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-trees%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang Datastructures: Trees on whatsapp" href="https://api.whatsapp.com/send?text=Golang%20Datastructures%3a%20Trees%20-%20https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-trees%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang Datastructures: Trees on telegram" href="https://telegram.me/share/url?text=Golang%20Datastructures%3a%20Trees&url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-trees%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 ¬© Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>