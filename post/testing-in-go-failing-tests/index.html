<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing in Go: Failing Tests | Ilija Eftimov ⚡️</title><meta name=keywords content><meta name=description content="A short overview of the testing package The testing package from Golang&rsquo;s standard library provides support for automated testing of Go packages. It is intended to be used in combination with the go test command. In combination with go test, this package expects certain naming conventions that we will cover in another article.
Still, for this article, we have to know that:
 Every test file ends with *_test.go Every test function has the format TestXxx, where Xxx must not start with a lowercase letter  The testing package exposes two different modes: testing and benchmarking."><meta name=author content="Ilija Eftimov"><link rel=canonical href=https://ieftimov.com/post/testing-in-go-failing-tests/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Testing in Go: Failing Tests"><meta property="og:description" content="A short overview of the testing package The testing package from Golang&rsquo;s standard library provides support for automated testing of Go packages. It is intended to be used in combination with the go test command. In combination with go test, this package expects certain naming conventions that we will cover in another article.
Still, for this article, we have to know that:
 Every test file ends with *_test.go Every test function has the format TestXxx, where Xxx must not start with a lowercase letter  The testing package exposes two different modes: testing and benchmarking."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/testing-in-go-failing-tests/"><meta property="og:image" content="https://ieftimov.com/cards/testing-in-go-failing-tests.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-30T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-12T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/testing-in-go-failing-tests.png"><meta name=twitter:title content="Testing in Go: Failing Tests"><meta name=twitter:description content="A short overview of the testing package The testing package from Golang&rsquo;s standard library provides support for automated testing of Go packages. It is intended to be used in combination with the go test command. In combination with go test, this package expects certain naming conventions that we will cover in another article.
Still, for this article, we have to know that:
 Every test file ends with *_test.go Every test function has the format TestXxx, where Xxx must not start with a lowercase letter  The testing package exposes two different modes: testing and benchmarking."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Testing in Go: Failing Tests","item":"https://ieftimov.com/post/testing-in-go-failing-tests/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing in Go: Failing Tests","name":"Testing in Go: Failing Tests","description":"A short overview of the testing package The testing package from Golang\u0026rsquo;s standard library provides support for automated testing of Go packages. It is intended to be used in combination with the go test command. In combination with go test, this package expects certain naming conventions that we will cover in another article.\nStill, for this article, we have to know that:\n Every test file ends with *_test.go Every test function has the format TestXxx, where Xxx must not start with a lowercase letter  The testing package exposes two different modes: testing and benchmarking.","keywords":[],"articleBody":"A short overview of the testing package The testing package from Golang’s standard library provides support for automated testing of Go packages. It is intended to be used in combination with the go test command. In combination with go test, this package expects certain naming conventions that we will cover in another article.\nStill, for this article, we have to know that:\n Every test file ends with *_test.go Every test function has the format TestXxx, where Xxx must not start with a lowercase letter  The testing package exposes two different modes: testing and benchmarking. While what we will be discussing here is transferable to benchmarking as well, we will focus on how to fail our tests in a good way and how to provide meaningful error messages.\nLogging with Log and Logf If we look at the index of T type in the testing package, there’s a list of functions that represent errors or failures:\nQuite some options, right? But before we dive into these different functions, let’s look at another one: Logf (docs).\nYou might be thinking: “I came here to read about signaling test failures, and for some reason, you’re forcing me to read about logging”. Trust me, there’s a connection here.\nLog formats its arguments using default formatting, analogous to Println, while Logf takes one or more arguments: a format string and additional arguments. It formats its arguments according to the format (analogous to Printf). Both these functions save the text in the error log. Compared to Println and Printf, the difference is that Log and Logf save the output to the error log (instead of os.Stdout), and they also add a final newline.\nWhen tests fail or when the -test.v flag is present, the text is printed out. Basically, Log \u0026 Logf are the Println and Printf of the testing package, but with a twist - they print only in verbose mode or when a test fails. An example:\npackage main import \"testing\" func TestFoo(t *testing.T) { t.Logf(\"Testing Foo\") } If we would run this using go test, there won’t be any output. But, if we run it using the -test.v flag, we’ll see something like this:\n$ go test -test.v === RUN TestFoo --- PASS: TestFoo (0.00s) foo_test.go:6: Testing Foo PASS ok github.com/fteem/testing_in_go\t0.006s As you can see above, the test returns PASS because there was no test that got marked as failed. If we would like to mark a test as failed, we would have to invoke t.Fail() inside the test. Let’s do that:\npackage main import \"testing\" func TestMax(t *testing.T) { t.Logf(\"Testing Foo\") t.Fail() } Now, when we run go test, we should see the test marked as a failure:\n$ go test --- FAIL: TestMax (0.00s) max_test.go:6: Testing Foo FAIL exit status 1 FAIL\tgithub.com/fteem/testing_in_go\t0.006s What’s great about this type of logging is that although the test is marked as a failure on line 7, the t.Logf call is on line 6, and the output clearly shows that. If we added any other logging below, we would see a separate line for each of the t.Logf calls:\npackage main import \"testing\" func TestMax(t *testing.T) { t.Logf(\"Testing Foo\") t.Fail() t.Logf(\"Another log from Foo\") } And the output of the go test invocation:\n$ go test --- FAIL: TestMax (0.00s) max_test.go:6: Testing Foo max_test.go:8: Another log from Foo FAIL exit status 1 FAIL\tgithub.com/fteem/testing_in_go\t0.006s This behavior is due to the way t.Logf functions. With every invocation, it adds the log lines to the error log. Still, it dumps the whole log to STDOUT only when the tests fail by running all of them and seeing if any were marked as failed. That’s why in the above example, we see that the failure is marked on line 7, yet all the logs are present (from line 6 and line 8).\nSo why are Log and Logf` important? Because all of the following functions that we will explore rely on them to write their outputs to the error log. And log output is essential to showing the failures of the failing tests.\nSignaling test Failure To illustrate the different types of failing a test in Golang, we will first need to write a small function that we can test. Let’s use a simple function Max that takes a slice of `int’s and returns the largest integer of them all:\n// max.go package main func Max(numbers []int) int { var max int for _, number := range numbers { if number  max { max = number } } return max } Let’s write a small test function:\npackage main import \"testing\" func TestMax(t *testing.T) { input := []int{1, 2, 3, 4, 5} actual := Max(input) expected := 6 if actual != expected { t.Logf(\"Expected %d, got %d\", expected, actual) } } The TestMax function defines an input slice of int’s, the result of the invocation of Max with the input as argument (called actual) and the expected value of the invocation.\nSuppose the expected value does not match the actual result. In that case, we want to tell the person (or program) running this test that we received something that we weren’t expecting. We do this by invoking t.Logf by providing a nice explanation for the human.\nThe expected value here is wrong. It expects 6 while the maximum element of the input slice is 5. That means that this test should fail when we run it:\n$ go test PASS ok github.com/fteem/testing_in_go\t0.006s Huh? Here’s the first thing we have to understand about signaling failures in tests: we have to tell the testing package that this is a failed test. And we are the ones to define what failure means. Usually, it’s actual != expected, but other times it can be something else. What testing only cares about is recording if there was a test failure or not. There are multiple ways to do this, t.Fail being the easiest one.\nLet’s add a call to t.Fail after the t.Logf call:\npackage main import \"testing\" func TestMax(t *testing.T) { input := []int{1, 2, 3, 4, 5} actual := Max(input) expected := 6 if actual != expected { t.Fail() t.Logf(\"Expected %d, got %d\", expected, actual) } } Let’s run it:\n$ go test -v --- FAIL: TestMax (0.00s) max_test.go:11: Expected 6, got 5 FAIL exit status 1 FAIL\tgithub.com/fteem/testing_in_go\t0.006s Boom! Our test failed, as expected. You can notice that the log is now visible, including our call to Logf with our informative error message Expected 6, got 5.\nNow that we have our first test failure signaled let’s look at different ways we can signal test failures.\nDelayed vs. immediate failure Golang’s testing package promotes two types of failures. The first failure type immediately stops the tests from running. And the second failure type registers the failure but reports it only after all tests finish running. These functions are aptly named Fail and FailNow to reflect the two different behaviors.\nLet’s explore their behaviour and usage by continuing testing the Max function we already built.\nWe could write one other test case checking that the slice passed as an argument is not empty. If it is, we will return -1. Otherwise, we will return the maximum item we find. Let’s write the new test first:\npackage main import \"testing\" func TestMax(t *testing.T) { input := []int{1, 2, 3, 4, 5} actual := Max(input) expected := 5 if actual != expected { t.Fail() t.Logf(\"Expected %d, got %d\", expected, actual) } } func TestMaxEmptySlice(t *testing.T) { input := []int{} actual := Max(input) expected := -1 if actual != expected { t.Fail() t.Logf(\"Expected %d, got %d\", expected, actual) } } If we run it, without adding any new functionality to the Max function, it will fail:\n$ go test --- FAIL: TestMaxEmptySlice (0.00s) max_test.go:22: Expected -1, got 0 FAIL exit status 1 FAIL\t_/users/Ilija/Documents/testing\t0.005s We can see here that the TestMax function is run and passes, while the TestMaxEmptySlice fails. We achieve that by marking the test as failed using t.Fail(). Let’s add the new functionality to Max, which would make the test pass:\nfunc Max(numbers []int) int { if len(numbers) == 0 { return -1 } var max int for _, number := range numbers { if number  max { max = number } } return max } While the change does not make much sense, for our purpose, it will do the trick. Let’s run the test:\n$ go test PASS ok _/Users/Ilija/Documents/testing\t0.004s Now, let’s look into the two things that the Max function does. We could theoretically attach an importance level to both of them. For example, the guard clause which returns -1 when the slice argument is empty has lower importance than the actual algorithm that detects the maximum element of the slice. If someone is expanding that algorithm and it goes south, we want to be very loud and “stop the world”. That’s because none of the other functionalities of the function are more relevant than that one.\nIn cases like these, we can use the FailNow() function to mark the failed test and immediately stop any further execution of the particular test that tests the max detection. Let’s use it in our tests:\npackage main import \"testing\" func TestMax(t *testing.T) { input := []int{1, 2, 3, 4, 5} actual := Max(input) expected := 5 if actual != expected { t.Logf(\"Expected %d, got %d\", expected, actual) t.FailNow() } } func TestMaxEmptySlice(t *testing.T) { input := []int{} actual := Max(input) expected := -1 if actual != expected { t.Logf(\"Expected %d, got %d\", expected, actual) t.Fail() } } Also, we need to make the Max function misbehave. To short-circuit this quickly, let’s make the Max function return -100 so we can see the difference.\nIf we run this now, there would not be a difference in how the tests will run, although we use FailNow:\n$ go test -v === RUN TestMax --- FAIL: TestMax (0.00s) max_test.go:11: Expected 5, got -100 === RUN TestMaxEmptSlice --- FAIL: TestMaxEmptySlice (0.00s) max_test.go:22: Expected -1, got -100 FAIL exit status 1 FAIL\t_/Users/Ilija/Documents/testing\t0.005s That is because the TestMax function only does one assertion. Let’s rework our tests a bit to use table-driven tests:\ntype TestCase struct { input []int expected int } func TestMax(t *testing.T) { cases := []TestCase{ TestCase{ input: []int{1, 2, 3, 4, 5}, expected: 5, }, TestCase{ input: []int{-1, -2, -3, -4, -5}, expected: -1, }, TestCase{ input: []int{0}, expected: 0, }, } for _, c := range cases { actual := Max(c.input) expected := c.expected if actual != expected { t.Logf(\"Expected %d, got %d\", expected, actual) t.Fail() } } } What the table-driven tests do is they loop over multiple test cases (often structs with the expected input and output), and they set assertions on them. If we would run the tests now, with using t.Fail() instead of t.FailNow() we should see the following output:\n$ go test --- FAIL: TestMax (0.00s) max_test.go:31: Expected 5, got -100 max_test.go:31: Expected -1, got -100 max_test.go:31: Expected 0, got -100 --- FAIL: TestMaxEmptySlice (0.00s) max_test.go:43: Expected -1, got -100 FAIL exit status 1 FAIL\t_/Users/Ilija/Documents/testing\t0.005s We actually get all failing cases for both tests. Let’s replace the t.Fail() invocation to t.FailNow() in the TestMax function and run the test:\n$ go test -v === RUN TestMax --- FAIL: TestMax (0.00s) max_test.go:31: Expected 5, got -100 === RUN TestMaxEmptSlice --- FAIL: TestMaxEmptySlice (0.00s) max_test.go:43: Expected -1, got -100 FAIL exit status 1 FAIL\t_/Users/Ilija/Documents/testing\t0.004s You can see that instead of running each of the test cases and marking them as failures, the test function stopped right after hitting the first failing case.\nReporting the failure is the critical difference between the two, t.Fail() and t.FailNow(). Using the latter, we can stop the tests and communicate with the developer that something is wrong quickly. In comparison, imagine if we had to wait for all test cases to complete before we have some sort of output. The long feedback loop would slow down development speed and waste time running all tests.\nHaving a clear difference and use cases for Fail and FailNow in mind, let’s look into how we can combine failure reporting (Log and Logf) with failure marking (Fail and FailNow) in a more structured approach.\nSignal \u0026 report failures in one go Understanding the basics and variations of logging and signaling errors is crucial to understand what we will talk about now. If you look at all the tests we wrote so far, although we switched up the approaches by using table-driven tests, two steps were constant:\n In all tests, we had to check for a mismatch between the expected and the actual values, and We had to call report (Log) and signal failure (Fail) if there was a mismatch  Luckily, the testing package makes our life a bit easier by implementing functions that combine both the logging and the test failure. And because there are two ways to signal test failures, there are two functions to do this:Error and Fatal, with their variants.\nLet’s reuse the tests that we wrote above, namely the TestMax and TestMaxEmptySlice functions. If we would like to quickly collapse the invocation of t.FailNow() and t.Log() we can simply use t.Fatal(). We use t.Logf() instead of t.Log() in our test functions but conveniently for us, the testing package also implements a t.Fatalf() function, which is a combination of t.FailNow() + t.Logf().\nLet’s see how we can use it in our TestMax test function:\nfunc TestMax(t *testing.T) { cases := []TestCase{ TestCase{ input: []int{1, 2, 3, 4, 5}, expected: 5, }, TestCase{ input: []int{-1, -2, -3, -4, -5}, expected: -1, }, TestCase{ input: []int{0}, expected: 0, }, } for _, c := range cases { actual := Max(c.input) expected := c.expected if actual != expected { t.Fatalf(\"Expected %d, got %d\", expected, actual) } } } The change is small. We keep the log format and content. Still, instead of passing it to t.Logf(), we pass it to t.Fatalf() as an argument, while t.FailNow() can be removed entirely. If we rerun our specs we will not see any difference in the behavior or the output in comparison to the previous implementation:\n$ go test --- FAIL: TestMax (0.00s) max_test.go:31: Expected 5, got -100 --- FAIL: TestMaxEmptySlice (0.00s) max_test.go:42: Expected -1, got -100 FAIL exit status 1 FAIL\t_/users/Ilija/Documents/testing\t0.005s The style of invocation of t.Fatalf() we see here also applies to t.Error() and t.Errorf(). We can make a small change to our TestMaxEmptySlice function and use t.Errorf() instead of a combination of t.Logf() and t.Fail():\nfunc TestMaxEmptySlice t *testing.T) { input := []int{} actual := Max(input) expected := -1 if actual != expected { t.Errorf(\"Expected %d, got %d\", expected, actual) } } The usage of t.Errorf() is the same as t.Fatalf() in the previous example. As expected, the output and the behavior of the test function also will not change:\n$ go test --- FAIL: TestMax (0.00s) max_test.go:31: Expected 5, got -100 --- FAIL: TestMaxEmptySlice (0.00s) max_test.go:42: Expected -1, got -100 FAIL exit status 1 FAIL\t_/users/Ilija/Documents/testing\t0.005s When to use Error(f) or Fatal(f) So, we took a look at all the variations of signaling test failures and logging such failures and the behavior of the respective functions. For those wondering when we should use Error or Fatal, I think that’s an essential question that we should explore and come up with a good answer.\nNow, there’s no hard and fast answer here. In cases like these, we need to look at guidelines on when to use these functions. If we look at the composition of these two functions, it will look something like this:\n* Error() = Fail() + Log() * Errorf() = Fail() + Logf() * Fatal() = FailNow() + Log() * Fatalf() = FailNow() + Logf() By looking at the composition of these functions, getting a clearer indication of the intended usage is easier:\nIf marking the test function as failed, but continuing its execution can/will provide the user (the programmer) with more information that can aid them in fixing the failure – it’s better to use Error(f) instead of Fatal(f). If unsure, start with Error(f) and work your way towards a definitive approach. There are multiple examples of this scenario. For instance, if your test function executes queries against a test database, not failing on the error from the first query might give you more debugging information.\nSuppose a test function cannot recover from a failure, and its execution doesn’t make sense. In that case, it’s better to use Fatal(f) and stop the further execution. Such cases are errors while loading fixtures or filesystem permission errors.\nThese are two guidelines you can use to choose what functions to use. Of course, there are exceptions to this, so it’s up to us to use good judgment when writing our test functions.\nIn closing In this article, we explored a lot of the details around failing tests. We went deep in to understand how failure logging is done using Go’s testing package - although it was unclear at that moment how it is related to failing tests. Then we went on to explore signaling test failures and the different approaches we can take when marking our tests as failed.\nWe looked in-depth about the difference between Fail and FailNow, and how to apply them better in our tests. In the end, we looked at some neat functions that the testing package has that make our lives a bit simpler. We discussed two different strategies of using the Error and the Fatal functions in our tests.\nIf you would like to learn more about marking tests as failed in Go, you can check the documentation of the testing package.\nLiked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to +1000 of other engineers.\n    ","wordCount":"2978","inLanguage":"en","datePublished":"2019-05-30T00:00:00Z","dateModified":"2021-06-12T00:00:00Z","author":{"@type":"Person","name":"Ilija Eftimov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/testing-in-go-failing-tests/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testing in Go: Failing Tests</h1><div class=post-meta>May 30, 2019&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Ilija Eftimov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#a-short-overview-of-the-testing-package aria-label="A short overview of the testing package">A short overview of the <code>testing</code> package</a></li><li><a href=#logging-with-log-and-logf aria-label="Logging with Log and Logf">Logging with <code>Log</code> and <code>Logf</code></a></li><li><a href=#signaling-test-failure aria-label="Signaling test Failure">Signaling test <code>Fail</code>ure</a></li><li><a href=#delayed-vs-immediate-failure aria-label="Delayed vs. immediate failure">Delayed vs. immediate failure</a></li><li><a href=#signal--report-failures-in-one-go aria-label="Signal &amp;amp; report failures in one go">Signal & report failures in one go</a></li><li><a href=#when-to-use-errorf-or-fatalf aria-label="When to use Error(f) or Fatal(f)">When to use <code>Error(f)</code> or <code>Fatal(f)</code></a></li><li><a href=#in-closing aria-label="In closing">In closing</a></li></ul></div></details></div><div class=post-content><h2 id=a-short-overview-of-the-testing-package>A short overview of the <code>testing</code> package<a hidden class=anchor aria-hidden=true href=#a-short-overview-of-the-testing-package>#</a></h2><p>The <code>testing</code> package from Golang&rsquo;s standard library provides support for
automated testing of Go packages. It is intended to be used in combination with
the <code>go test</code> command. In combination with <code>go test</code>, this package expects
certain naming conventions that we will cover in another article.</p><p>Still, for this article, we have to know that:</p><ol><li>Every test file ends with <code>*_test.go</code></li><li>Every test function has the format <code>TestXxx</code>, where <code>Xxx</code> must not start
with a lowercase letter</li></ol><p>The <code>testing</code> package exposes two different modes: testing and benchmarking.
While what we will be discussing here is transferable to benchmarking as well,
we will focus on how to fail our tests in a good way and how to provide
meaningful error messages.</p><h2 id=logging-with-log-and-logf>Logging with <code>Log</code> and <code>Logf</code><a hidden class=anchor aria-hidden=true href=#logging-with-log-and-logf>#</a></h2><p>If we look at the <a href=https://golang.org/pkg/testing/#T>index</a> of <code>T</code> type in the
<code>testing</code> package, there&rsquo;s a list of functions that represent errors or failures:</p><p><img src=/testing-in-go-failing-tests/type-t-index.png alt></p><p>Quite some options, right? But before we dive into these different functions,
let&rsquo;s look at another one: <code>Logf</code> (<a href=https://golang.org/pkg/testing/#T.Logf>docs</a>).</p><p>You might be thinking: &ldquo;I came here to read about signaling test failures, and
for some reason, you&rsquo;re forcing me to read about logging&rdquo;. Trust me, there&rsquo;s a
connection here.</p><p><code>Log</code> formats its arguments using default formatting, analogous to <code>Println</code>,
while <code>Logf</code> takes one or more arguments: a <code>format</code> string and additional
arguments. It formats its arguments according to the format (analogous to
<code>Printf</code>). Both these functions save the text in the error log. Compared to
<code>Println</code> and <code>Printf</code>, the difference is that <code>Log</code> and <code>Logf</code> save the output
to the error log (instead of <code>os.Stdout</code>), and they also add a final newline.</p><p>When tests fail or when the <code>-test.v</code> flag is present, the text is printed out.
Basically, <code>Log</code> & <code>Logf</code> are the <code>Println</code> and <code>Printf</code> of the <code>testing</code>
package, but with a twist - they print only in verbose mode or when a test
fails. An example:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> <span style=color:#2aa198>&#34;testing&#34;</span>

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestFoo</span>(t <span style=color:#719e07>*</span>testing.T) {
	t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Testing Foo&#34;</span>)
}
</code></pre></div><p>If we would run this using <code>go test</code>, there won&rsquo;t be any output. But, if we run
it using the <code>-test.v</code> flag, we&rsquo;ll see something like this:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span> -test.v
<span style=color:#719e07>===</span> RUN   TestFoo
--- PASS: TestFoo <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    foo_test.go:6: Testing Foo
PASS
ok  	github.com/fteem/testing_in_go	0.006s
</code></pre></div><p>As you can see above, the test returns <code>PASS</code> because there was no test that
got marked as failed. If we would like to mark a test as failed, we would have
to invoke <code>t.Fail()</code> inside the test. Let&rsquo;s do that:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> <span style=color:#2aa198>&#34;testing&#34;</span>

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Testing Foo&#34;</span>)
	t.<span style=color:#268bd2>Fail</span>()
}
</code></pre></div><p>Now, when we run <code>go test</code>, we should see the test marked as a failure:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:6: Testing Foo
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	github.com/fteem/testing_in_go	0.006s
</code></pre></div><p>What&rsquo;s great about this type of logging is that although the test is marked as
a failure on line 7, the <code>t.Logf</code> call is on line 6, and the output clearly
shows that. If we added any other logging below, we would see a separate line
for each of the <code>t.Logf</code> calls:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> <span style=color:#2aa198>&#34;testing&#34;</span>

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Testing Foo&#34;</span>)
	t.<span style=color:#268bd2>Fail</span>()
	t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Another log from Foo&#34;</span>)
}
</code></pre></div><p>And the output of the <code>go test</code> invocation:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:6: Testing Foo
    max_test.go:8: Another log from Foo
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	github.com/fteem/testing_in_go	0.006s
</code></pre></div><p>This behavior is due to the way <code>t.Logf</code> functions. With every invocation, it
adds the log lines to the error log. Still, it dumps the whole log to <code>STDOUT</code>
only when the tests fail by running all of them and seeing if any were marked
as failed. That&rsquo;s why in the above example, we see that the failure is marked
on line 7, yet all the logs are present (from line 6 and line 8).</p><p>So why are <code>Log and </code>Logf` important? Because all of the following functions
that we will explore rely on them to write their outputs to the error log. And
log output is essential to showing the failures of the failing tests.</p><h2 id=signaling-test-failure>Signaling test <code>Fail</code>ure<a hidden class=anchor aria-hidden=true href=#signaling-test-failure>#</a></h2><p>To illustrate the different types of failing a test in Golang, we will first
need to write a small function that we can test. Let&rsquo;s use a simple function
<code>Max</code> that takes a slice of `int&rsquo;s and returns the largest integer of them all:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// max.go
</span><span style=color:#586e75></span><span style=color:#719e07>package</span> main

<span style=color:#268bd2>func</span> <span style=color:#268bd2>Max</span>(numbers []<span style=color:#dc322f>int</span>) <span style=color:#dc322f>int</span> {
	<span style=color:#268bd2>var</span> max <span style=color:#dc322f>int</span>

	<span style=color:#719e07>for</span> _, number <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> numbers {
		<span style=color:#719e07>if</span> number &gt; max {
			max = number
		}
	}

	<span style=color:#719e07>return</span> max
}
</code></pre></div><p>Let&rsquo;s write a small test function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> <span style=color:#2aa198>&#34;testing&#34;</span>

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	input <span style=color:#719e07>:=</span> []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span>, <span style=color:#2aa198>5</span>}
	actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(input)
	expected <span style=color:#719e07>:=</span> <span style=color:#2aa198>6</span>

	<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
		t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}
</code></pre></div><p>The <code>TestMax</code> function defines an <code>input</code> slice of <code>int</code>&rsquo;s, the result of the
invocation of <code>Max</code> with the <code>input</code> as argument (called <code>actual</code>) and the
<code>expected</code> value of the invocation.</p><p>Suppose the <code>expected</code> value does not match the <code>actual</code> result. In that case,
we want to tell the person (or program) running this test that we received
something that we weren&rsquo;t expecting. We do this by invoking <code>t.Logf</code> by
providing a nice explanation for the human.</p><p>The <code>expected</code> value here is wrong. It expects <code>6</code> while the maximum element of
the <code>input</code> slice is <code>5</code>. That means that this test should fail when we run it:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
PASS
ok  	github.com/fteem/testing_in_go	0.006s
</code></pre></div><p>Huh? Here&rsquo;s the first thing we have to understand about signaling failures in
tests: we have to tell the <code>testing</code> package that this is a failed test. And we
are the ones to define what failure means. Usually, it&rsquo;s <code>actual != expected</code>,
but other times it can be something else. What <code>testing</code> only cares about is
recording if there was a test failure or not. There are multiple ways to do
this, <code>t.Fail</code> being the easiest one.</p><p>Let&rsquo;s add a call to <code>t.Fail</code> after the <code>t.Logf</code> call:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> <span style=color:#2aa198>&#34;testing&#34;</span>

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	input <span style=color:#719e07>:=</span> []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span>, <span style=color:#2aa198>5</span>}
	actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(input)
	expected <span style=color:#719e07>:=</span> <span style=color:#2aa198>6</span>

	<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
		t.<span style=color:#268bd2>Fail</span>()
		t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}
</code></pre></div><p>Let&rsquo;s run it:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span> -v
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:11: Expected 6, got <span style=color:#2aa198>5</span>
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	github.com/fteem/testing_in_go	0.006s
</code></pre></div><p>Boom! Our test failed, as expected. You can notice that the log is now visible,
including our call to <code>Logf</code> with our informative error message <code>Expected 6, got 5</code>.</p><p>Now that we have our first test failure signaled let&rsquo;s look at different ways
we can signal test failures.</p><h2 id=delayed-vs-immediate-failure>Delayed vs. immediate failure<a hidden class=anchor aria-hidden=true href=#delayed-vs-immediate-failure>#</a></h2><p>Golang&rsquo;s <code>testing</code> package promotes two types of failures. The first failure
type immediately stops the tests from running. And the second failure type
registers the failure but reports it only after all tests finish running. These
functions are aptly named <code>Fail</code> and <code>FailNow</code> to reflect the two different
behaviors.</p><p>Let&rsquo;s explore their behaviour and usage by continuing testing the <code>Max</code>
function we already built.</p><p>We could write one other test case checking that the slice passed as an
argument is not empty. If it is, we will return <code>-1</code>. Otherwise, we will return
the maximum item we find. Let&rsquo;s write the new test first:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> <span style=color:#2aa198>&#34;testing&#34;</span>

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	input <span style=color:#719e07>:=</span> []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span>, <span style=color:#2aa198>5</span>}
	actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(input)
	expected <span style=color:#719e07>:=</span> <span style=color:#2aa198>5</span>

	<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
		t.<span style=color:#268bd2>Fail</span>()
		t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMaxEmptySlice</span>(t <span style=color:#719e07>*</span>testing.T) {
	input <span style=color:#719e07>:=</span> []<span style=color:#dc322f>int</span>{}
	actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(input)
	expected <span style=color:#719e07>:=</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>

	<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
		t.<span style=color:#268bd2>Fail</span>()
		t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}
</code></pre></div><p>If we run it, without adding any new functionality to the <code>Max</code> function, it
will fail:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
--- FAIL: TestMaxEmptySlice <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:22: Expected -1, got <span style=color:#2aa198>0</span>
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	_/users/Ilija/Documents/testing	0.005s
</code></pre></div><p>We can see here that the <code>TestMax</code> function is run and passes, while the
<code>TestMaxEmptySlice</code> fails. We achieve that by marking the test as failed using
<code>t.Fail()</code>. Let&rsquo;s add the new functionality to <code>Max</code>, which would make the test
pass:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>Max</span>(numbers []<span style=color:#dc322f>int</span>) <span style=color:#dc322f>int</span> {
	<span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(numbers) <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> {
		<span style=color:#719e07>return</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>
	}

	<span style=color:#268bd2>var</span> max <span style=color:#dc322f>int</span>

	<span style=color:#719e07>for</span> _, number <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> numbers {
		<span style=color:#719e07>if</span> number &gt; max {
			max = number
		}
	}

	<span style=color:#719e07>return</span> max
}
</code></pre></div><p>While the change does not make much sense, for our purpose, it will do the
trick. Let&rsquo;s run the test:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
PASS
ok  	_/Users/Ilija/Documents/testing	0.004s
</code></pre></div><p>Now, let&rsquo;s look into the two things that the <code>Max</code> function does. We could
theoretically attach an importance level to both of them. For example, the
guard clause which returns <code>-1</code> when the slice argument is empty has lower
importance than the actual algorithm that detects the maximum element of the
slice. If someone is expanding that algorithm and it goes south, we want to be
very loud and &ldquo;stop the world&rdquo;. That&rsquo;s because none of the other
functionalities of the function are more relevant than that one.</p><p>In cases like these, we can use the <code>FailNow()</code> function to mark the failed
test and immediately stop any further execution of the particular test that
tests the max detection. Let&rsquo;s use it in our tests:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> <span style=color:#2aa198>&#34;testing&#34;</span>

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	input <span style=color:#719e07>:=</span> []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span>, <span style=color:#2aa198>5</span>}
	actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(input)
	expected <span style=color:#719e07>:=</span> <span style=color:#2aa198>5</span>

	<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
		t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
		t.<span style=color:#268bd2>FailNow</span>()
	}
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMaxEmptySlice</span>(t <span style=color:#719e07>*</span>testing.T) {
	input <span style=color:#719e07>:=</span> []<span style=color:#dc322f>int</span>{}
	actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(input)
	expected <span style=color:#719e07>:=</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>

	<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
		t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
		t.<span style=color:#268bd2>Fail</span>()
	}
}
</code></pre></div><p>Also, we need to make the <code>Max</code> function misbehave. To short-circuit this
quickly, let&rsquo;s make the <code>Max</code> function return <code>-100</code> so we can see the
difference.</p><p>If we run this now, there would not be a difference in how the tests will run,
although we use <code>FailNow</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span> -v
<span style=color:#719e07>===</span> RUN   TestMax
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:11: Expected 5, got -100
<span style=color:#719e07>===</span> RUN   TestMaxEmptSlice
--- FAIL: TestMaxEmptySlice <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:22: Expected -1, got -100
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	_/Users/Ilija/Documents/testing	0.005s
</code></pre></div><p>That is because the <code>TestMax</code> function only does one assertion. Let&rsquo;s rework
our tests a bit to use table-driven tests:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>type</span> TestCase <span style=color:#268bd2>struct</span> {
	input    []<span style=color:#dc322f>int</span>
	expected <span style=color:#dc322f>int</span>
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	cases <span style=color:#719e07>:=</span> []TestCase{
		TestCase{
			input:    []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span>, <span style=color:#2aa198>5</span>},
			expected: <span style=color:#2aa198>5</span>,
		},
		TestCase{
			input:    []<span style=color:#dc322f>int</span>{<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>2</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>3</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>4</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>5</span>},
			expected: <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>,
		},
		TestCase{
			input:    []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>0</span>},
			expected: <span style=color:#2aa198>0</span>,
		},
	}

	<span style=color:#719e07>for</span> _, c <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> cases {
		actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(c.input)
		expected <span style=color:#719e07>:=</span> c.expected

		<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
			t.<span style=color:#268bd2>Logf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
			t.<span style=color:#268bd2>Fail</span>()
		}
	}
}
</code></pre></div><p>What the table-driven tests do is they loop over multiple test cases (often
structs with the expected input and output), and they set assertions on them.
If we would run the tests now, with using <code>t.Fail()</code> instead of <code>t.FailNow()</code>
we should see the following output:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:31: Expected 5, got -100
    max_test.go:31: Expected -1, got -100
    max_test.go:31: Expected 0, got -100
--- FAIL: TestMaxEmptySlice <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:43: Expected -1, got -100
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	_/Users/Ilija/Documents/testing	0.005s
</code></pre></div><p>We actually get all failing cases for both tests. Let&rsquo;s replace the <code>t.Fail()</code>
invocation to <code>t.FailNow()</code> in the <code>TestMax</code> function and run the test:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span> -v
<span style=color:#719e07>===</span> RUN   TestMax
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:31: Expected 5, got -100
<span style=color:#719e07>===</span> RUN   TestMaxEmptSlice
--- FAIL: TestMaxEmptySlice <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:43: Expected -1, got -100
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	_/Users/Ilija/Documents/testing	0.004s
</code></pre></div><p>You can see that instead of running each of the test cases and marking them as
failures, the test function stopped right after hitting the first failing case.</p><p>Reporting the failure is the critical difference between the two, <code>t.Fail()</code>
and <code>t.FailNow()</code>. Using the latter, we can stop the tests and communicate with
the developer that something is wrong quickly. In comparison, imagine if we had
to wait for all test cases to complete before we have some sort of output. The
long feedback loop would slow down development speed and waste time running all
tests.</p><p>Having a clear difference and use cases for <code>Fail</code> and <code>FailNow</code> in mind, let&rsquo;s
look into how we can combine failure reporting (<code>Log</code> and <code>Logf</code>) with failure
marking (<code>Fail</code> and <code>FailNow</code>) in a more structured approach.</p><h2 id=signal--report-failures-in-one-go>Signal & report failures in one go<a hidden class=anchor aria-hidden=true href=#signal--report-failures-in-one-go>#</a></h2><p>Understanding the basics and variations of logging and signaling errors is
crucial to understand what we will talk about now. If you look at all the tests
we wrote so far, although we switched up the approaches by using table-driven
tests, two steps were constant:</p><ol><li>In all tests, we had to check for a mismatch between the expected and the
actual values, and</li><li>We had to call report (<code>Log</code>) and signal failure (<code>Fail</code>) if there was a
mismatch</li></ol><p>Luckily, the <code>testing</code> package makes our life a bit easier by implementing
functions that combine both the logging and the test failure. And because there
are two ways to signal test failures, there are two functions to do
this:<code>Error</code> and <code>Fatal,</code> with their variants.</p><p>Let&rsquo;s reuse the tests that we wrote above, namely the <code>TestMax</code> and
<code>TestMaxEmptySlice</code> functions. If we would like to quickly collapse the
invocation of <code>t.FailNow()</code> and <code>t.Log()</code> we can simply use <code>t.Fatal()</code>. We use
<code>t.Logf()</code> instead of <code>t.Log()</code> in our test functions but conveniently for us,
the <code>testing</code> package also implements a <code>t.Fatalf()</code> function, which is a
combination of <code>t.FailNow()</code> + <code>t.Logf()</code>.</p><p>Let&rsquo;s see how we can use it in our <code>TestMax</code> test function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>TestMax</span>(t <span style=color:#719e07>*</span>testing.T) {
	cases <span style=color:#719e07>:=</span> []TestCase{
		TestCase{
			input:    []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span>, <span style=color:#2aa198>5</span>},
			expected: <span style=color:#2aa198>5</span>,
		},
		TestCase{
			input:    []<span style=color:#dc322f>int</span>{<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>2</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>3</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>4</span>, <span style=color:#719e07>-</span><span style=color:#2aa198>5</span>},
			expected: <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>,
		},
		TestCase{
			input:    []<span style=color:#dc322f>int</span>{<span style=color:#2aa198>0</span>},
			expected: <span style=color:#2aa198>0</span>,
		},
	}

	<span style=color:#719e07>for</span> _, c <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> cases {
		actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(c.input)
		expected <span style=color:#719e07>:=</span> c.expected

		<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
			t.<span style=color:#268bd2>Fatalf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
		}
	}
}
</code></pre></div><p>The change is small. We keep the log format and content. Still, instead of
passing it to <code>t.Logf()</code>, we pass it to <code>t.Fatalf()</code> as an argument, while
<code>t.FailNow()</code> can be removed entirely. If we rerun our specs we will not see
any difference in the behavior or the output in comparison to the previous
implementation:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:31: Expected 5, got -100
--- FAIL: TestMaxEmptySlice <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:42: Expected -1, got -100
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	_/users/Ilija/Documents/testing	0.005s
</code></pre></div><p>The style of invocation of <code>t.Fatalf()</code> we see here also applies to <code>t.Error()</code>
and <code>t.Errorf()</code>. We can make a small change to our <code>TestMaxEmptySlice</code>
function and use <code>t.Errorf()</code> instead of a combination of <code>t.Logf()</code> and
<code>t.Fail()</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> TestMaxEmptySlice t <span style=color:#719e07>*</span>testing.T) {
	input <span style=color:#719e07>:=</span> []<span style=color:#dc322f>int</span>{}
	actual <span style=color:#719e07>:=</span> <span style=color:#268bd2>Max</span>(input)
	expected <span style=color:#719e07>:=</span> <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>

	<span style=color:#719e07>if</span> actual <span style=color:#719e07>!=</span> expected {
		t.<span style=color:#268bd2>Errorf</span>(<span style=color:#2aa198>&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}
</code></pre></div><p>The usage of <code>t.Errorf()</code> is the same as <code>t.Fatalf()</code> in the
previous example. As expected, the output and the behavior of the test
function also will not change:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#b58900>test</span>
--- FAIL: TestMax <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:31: Expected 5, got -100
--- FAIL: TestMaxEmptySlice <span style=color:#719e07>(</span>0.00s<span style=color:#719e07>)</span>
    max_test.go:42: Expected -1, got -100
FAIL
<span style=color:#b58900>exit</span> status <span style=color:#2aa198>1</span>
FAIL	_/users/Ilija/Documents/testing	0.005s
</code></pre></div><h2 id=when-to-use-errorf-or-fatalf>When to use <code>Error(f)</code> or <code>Fatal(f)</code><a hidden class=anchor aria-hidden=true href=#when-to-use-errorf-or-fatalf>#</a></h2><p>So, we took a look at all the variations of signaling test failures and logging
such failures and the behavior of the respective functions. For those wondering
when we should use <code>Error</code> or <code>Fatal</code>, I think that&rsquo;s an essential question
that we should explore and come up with a good answer.</p><p>Now, there&rsquo;s no hard and fast answer here. In cases like these, we need to look
at guidelines on when to use these functions. If we look at the composition of
these two functions, it will look something like this:</p><pre><code>* Error()  = Fail()    + Log()
* Errorf() = Fail()    + Logf()
* Fatal()  = FailNow() + Log()
* Fatalf() = FailNow() + Logf()
</code></pre><p>By looking at the composition of these functions, getting a clearer indication
of the intended usage is easier:</p><p>If marking the test function as failed, but continuing its execution can/will
provide the user (the programmer) with more information that can aid them in
fixing the failure – it&rsquo;s better to use <code>Error(f)</code> instead of <code>Fatal(f)</code>. If
unsure, start with <code>Error(f)</code> and work your way towards a definitive approach.
There are multiple examples of this scenario. For instance, if your test
function executes queries against a test database, not failing on the error
from the first query might give you more debugging information.</p><p>Suppose a test function cannot recover from a failure, and its execution
doesn&rsquo;t make sense. In that case, it&rsquo;s better to use <code>Fatal(f)</code> and stop the
further execution. Such cases are errors while loading fixtures or filesystem
permission errors.</p><p>These are two guidelines you can use to choose what functions to use. Of
course, there are exceptions to this, so it&rsquo;s up to us to use good judgment
when writing our test functions.</p><h2 id=in-closing>In closing<a hidden class=anchor aria-hidden=true href=#in-closing>#</a></h2><p>In this article, we explored a lot of the details around failing tests. We went
deep in to understand how failure logging is done using Go&rsquo;s <code>testing</code> package
- although it was unclear at that moment how it is related to failing tests.
Then we went on to explore signaling test failures and the different approaches
we can take when marking our tests as failed.</p><p>We looked in-depth about the difference between <code>Fail</code> and <code>FailNow</code>, and how
to apply them better in our tests. In the end, we looked at some neat functions
that the <code>testing</code> package has that make our lives a bit simpler. We discussed
two different strategies of using the <code>Error</code> and the <code>Fatal</code> functions in our
tests.</p><p>If you would like to learn more about marking tests as failed in Go, you can
check <a href=https://golang.org/pkg/testing/>the documentation</a> of the <code>testing</code>
package.</p><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to +1000 of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/><span class=title>« Prev Page</span><br><span>Testing in Go: Writing Practical Failure Messages</span></a>
<a class=next href=https://ieftimov.com/post/testing-in-go-first-principles/><span class=title>Next Page »</span><br><span>Testing in Go: First Principles</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Failing Tests on twitter" href="https://twitter.com/intent/tweet/?text=Testing%20in%20Go%3a%20Failing%20Tests&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-failing-tests%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Failing Tests on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-failing-tests%2f&title=Testing%20in%20Go%3a%20Failing%20Tests&summary=Testing%20in%20Go%3a%20Failing%20Tests&source=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-failing-tests%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Failing Tests on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-failing-tests%2f&title=Testing%20in%20Go%3a%20Failing%20Tests"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Failing Tests on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-failing-tests%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Failing Tests on whatsapp" href="https://api.whatsapp.com/send?text=Testing%20in%20Go%3a%20Failing%20Tests%20-%20https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-failing-tests%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Failing Tests on telegram" href="https://telegram.me/share/url?text=Testing%20in%20Go%3a%20Failing%20Tests&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-failing-tests%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>