<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Testing in Go: Failing Tests - Ilija Eftimov</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Testing in Go: Failing Tests" />
<meta property="og:description" content="In the previous article on testing in Golang, titled Testing in Go: First Principles, we looked at what testing looks like in Golang. In this article, we will do a deeper dive in the testing package. More specifically, we will take a look at the different ways we can fail tests in our test suites and when and how we should use these techniques.
Without further ado, let&#39;s take a look under the covers in the testing package." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ieftimov.com/post/testing-in-go-failing-tests/" />
<meta property="og:image" content="https://ieftimov.com/cards/testing-in-go-failing-tests.png" />
<meta property="article:published_time" content="2019-05-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-05-30T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ieftimov.com/cards/testing-in-go-failing-tests.png"/>

<meta name="twitter:title" content="Testing in Go: Failing Tests"/>
<meta name="twitter:description" content="In the previous article on testing in Golang, titled Testing in Go: First Principles, we looked at what testing looks like in Golang. In this article, we will do a deeper dive in the testing package. More specifically, we will take a look at the different ways we can fail tests in our test suites and when and how we should use these techniques.
Without further ado, let&#39;s take a look under the covers in the testing package."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.com/css/main.css" />
		<link rel="stylesheet" type="text/css" href="https://ieftimov.com/css/overrides.css" />
	

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://ieftimov.com/js/main.js"></script><script src="https://ieftimov.com/js/tooltip.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://ieftimov.com/">
				<img src="https://pbs.twimg.com/profile_images/1194757753585225728/JbET17PZ_400x400.jpg" alt="Ilija Eftimov" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://ieftimov.com/">Ilija Eftimov</a></h1>
	<div class="site-description"><p>Software engineer, author and open source contributor</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/fteem" title="Github"><i data-feather="github"></i></a></li><li><a href="https://twitter.com/fteem" title="Twitter"><i data-feather="twitter"></i></a></li><li><a href="https://www.linkedin.com/in/ieftimov" title="Linkedin"><i data-feather="linkedin"></i></a></li><li><a href="mailto:blog@ieftimov.com" title="Email"><i data-feather="mail"></i></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">Archive</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="https://forms.gle/orfXK5jh1LRaiFzo8">Suggest a topic</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">30</span>
							<span class="rest">May 2019</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Testing in Go: Failing Tests</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>In the previous article on testing in Golang, titled <a href="/testing-in-go-first-principles">Testing in Go: First
Principles</a>, we looked at what testing looks
like in Golang. In this article, we will do a deeper dive in the <code>testing</code>
package. More specifically, we will take a look at the different ways we can
fail tests in our test suites and when and how we should use these techniques.</p>
<p>Without further ado, let's take a look under the covers in the <code>testing</code> package.</p>
<h2 id="a-short-overview-of-the-testing-package">A short overview of the <code>testing</code> package</h2>
<p>The <code>testing</code> package from Golang's standard library provides support for
automated testing of Go packages. It is intended to be used in combination with the
<code>go test</code> command. This package in combination with <code>go test</code> expect certain
naming conventions that we will cover in another article, but for the purpose of
this article we have to know that:</p>
<ol>
<li>Every test file ends with <code>*_test.go</code></li>
<li>Every test function has the format <code>TestXxx</code>, where <code>Xxx</code> must not start
with a lowercase letter</li>
</ol>
<p>The <code>testing</code> package exposes two different modes: testing and benchmarking.
While what we will be discussing here is transferable to benchmarking as well,
we will focus on how to fail our tests in a good way and how to provide
meaningful error messages.</p>












<figure class="imagecaption">
  <img class="caption" src="/testing-in-go-failing-tests/report.png" title="Image taken from Undraw." alt="Person looking at a report page">
  <span class="caption-text">Image taken from <a href="https://undraw.co/">Undraw</a>.</span>
</figure>

<h2 id="logging-with-log-and-logf">Logging with <code>Log</code> and <code>Logf</code></h2>
<p>If we look at the <a href="https://golang.org/pkg/testing/#T">index</a> of <code>T</code> type in the
<code>testing</code> package, there's a list of functions that represent errors or failures:</p>
<p><img src="/testing-in-go-errors/type-t-index.png" alt=""></p>
<p>Quite some options, right? But before we dive into these different functions,
let's look at another one: <code>Logf</code> (<a href="https://golang.org/pkg/testing/#T.Logf">docs</a>).</p>
<p>You might be thinking: &ldquo;I came here to read about signaling test failures, and
for some reason, I am reading about logging&rdquo;. Trust me, there's a connection
here.</p>
<p><code>Log</code> formats its arguments using default formatting, analogous to <code>Println</code>,
while <code>Logf</code> takes one or more arguments:Â a <code>format</code> string and additional
arguments. It formats its arguments according to the format (analogous to
<code>Printf</code>). Both these functions save the text in the error log. Compared to
<code>Println</code> and <code>Printf</code>, the difference is that <code>Log</code> and <code>Logf</code> save the output
to the error log (instead of <code>os.Stdout</code>) and they also add a final newline.</p>
<p>When tests fail or when the <code>-test.v</code> flag is present, the text is printed out.
Basically, <code>Log</code> &amp; <code>Logf</code> are the <code>testing</code> package's <code>Println</code> and <code>Printf</code>
with a twist - prints only in verbose mode or when a test fails. A simple
example:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="color:#b84">&#34;testing&#34;</span>

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestFoo</span>(t <span style="font-weight:bold">*</span>testing.T) {
	t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Testing Foo&#34;</span>)
}</code></pre></div>
<p>If we would run this using <code>go test</code> there won't be any output. But, if we run it
using the <code>-test.v</code> flag, we'll see something like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ go test -test.v
=== RUN   TestFoo
--- PASS: TestFoo (0.00s)
    foo_test.go:6: Testing Foo
PASS
ok  	github.com/fteem/testing_in_go	0.006s</code></pre></div>
<p>As you can see above, the test returns <code>PASS</code> because there was no test that
got marked as failed. If we would like to mark a test as failed, we would have
to invoke <code>t.Fail()</code> inside the test. Let's do that:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="color:#b84">&#34;testing&#34;</span>

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Testing Foo&#34;</span>)
	t.<span style="color:#900;font-weight:bold">Fail</span>()
}</code></pre></div>
<p>Now, when we run <code>go test</code> we should see the test marked as a failure:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ go test
--- FAIL: TestMax (0.00s)
    max_test.go:6: Testing Foo
FAIL
exit status 1
FAIL	github.com/fteem/testing_in_go	0.006s</code></pre></div>
<p>What's great about this type of logging is that although the test is marked
as a failure on line 7, the <code>t.Logf</code> call is on line 6 and the output states
that clearly. If we would add any other logging below we would see a separate
line for each of the <code>Logf</code> calls:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="color:#b84">&#34;testing&#34;</span>

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Testing Foo&#34;</span>)
	t.<span style="color:#900;font-weight:bold">Fail</span>()
	t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Another log from Foo&#34;</span>)
}</code></pre></div>
<p>And the output of the <code>go test</code> invocation:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ go test
--- FAIL: TestMax (0.00s)
    max_test.go:6: Testing Foo
    max_test.go:8: Another log from Foo
FAIL
exit status 1
FAIL	github.com/fteem/testing_in_go	0.006s</code></pre></div>
<p>This behaviour is due to the way <code>Logf</code> functions. With every invocation, it
adds the log lines to the error log, but it dumps the whole log to <code>STDOUT</code>
only when the tests actually fail, by running all of them and seeing if any
were marked as failed. That's why in the above example we see that the failure
is marked on line 7, yet all the logs are present (from line 6 and line 8).</p>
<p>So why are <code>Log and </code>Logf` important? Because of all of the next functions that
we will explore rely on them to write their outputs to the error log. And log
output is essential to showing the failures of the failing tests.</p>
<h2 id="signaling-test-failure">Signaling test <code>Fail</code>ure</h2>
<p>To be able to illustrate the different type of failing a test in Golang, we
will first need to write a small function that we can test. Let's use a simple
function <code>Max</code> that takes a slice of <code>int</code>s and returns the largest integer of
them all:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#998;font-style:italic">// max.go
</span><span style="color:#998;font-style:italic"></span><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">Max</span>(numbers []<span style="color:#458;font-weight:bold">int</span>) <span style="color:#458;font-weight:bold">int</span> {
	<span style="font-weight:bold">var</span> max <span style="color:#458;font-weight:bold">int</span>

	<span style="font-weight:bold">for</span> _, number <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> numbers {
		<span style="font-weight:bold">if</span> number &gt; max {
			max = number
		}
	}

	<span style="font-weight:bold">return</span> max
}</code></pre></div>
<p>Let's write a small test function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="color:#b84">&#34;testing&#34;</span>

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	input <span style="font-weight:bold">:=</span> []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>}
	actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(input)
	expected <span style="font-weight:bold">:=</span> <span style="color:#099">6</span>

	<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
		t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}</code></pre></div>
<p>The <code>TestMax</code> function defines an <code>input</code> slice of <code>int</code>s, the result of the
invocation of <code>Max</code> with the <code>input</code> as argument (called <code>actual</code>) and the
<code>expected</code> value of the invocation.</p>
<p>If the <code>expected</code> value does not match the <code>actual</code> result, we want to tell the
person (or program) running this test that we received something that we
weren't expecting. We do this by invoking <code>t.Logf</code> with providing a nice
explanation for the human.</p>
<p>If you missed it â the <code>expected</code> value here is wrong. It expects <code>6</code> while the
maximum element of the <code>input</code> slice is <code>5</code>. That means that this test should
fail when we run it:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go <span style="color:#999">test</span>
PASS
ok  	github.com/fteem/testing_in_go	0.006s</code></pre></div>
<p>Huh? Here's the first thing we have to understand about signaling failures in
tests: we actually have to tell the <code>testing</code> package that this is a failed
test. And we are the ones to define what failure means - usually, it's <code>actual != expected</code>, but other times it can be something else. What <code>testing</code> only
cares about is recording if there was a test failure or not. There are multiple
ways to do this, <code>t.Fail</code> being the easiest one.</p>
<p>Let's add a call to <code>t.Fail</code> after the <code>t.Logf</code> call:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="color:#b84">&#34;testing&#34;</span>

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	input <span style="font-weight:bold">:=</span> []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>}
	actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(input)
	expected <span style="font-weight:bold">:=</span> <span style="color:#099">6</span>

	<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
		t.<span style="color:#900;font-weight:bold">Fail</span>()
		t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}</code></pre></div>
<p>Let's run it:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go <span style="color:#999">test</span> -v
--- FAIL: TestMax <span style="font-weight:bold">(</span>0.00s<span style="font-weight:bold">)</span>
    max_test.go:11: Expected 6, got <span style="color:#099">5</span>
FAIL
<span style="color:#999">exit</span> status <span style="color:#099">1</span>
FAIL	github.com/fteem/testing_in_go	0.006s</code></pre></div>
<p>Boom! Our test failed, as expected. You can notice that the log is now visible,
including our call to <code>Logf</code> with our informative error message <code>Expected 6, got 5</code>.</p>
<p>Now that we have our first test failure signaled, let's look at different ways
we can signal test failures.</p>












<figure class="imagecaption">
  <img class="caption" src="/testing-in-go-failing-tests/server_down.png" title="Image taken from Undraw." alt="Graphic showing a broken connection between computers">
  <span class="caption-text">Image taken from <a href="https://undraw.co/">Undraw</a>.</span>
</figure>

<h2 id="delayed-vs-immediate-failure">Delayed vs. immediate failure</h2>
<p>Golang's <code>testing</code> package promotes two types of failures: ones that
immediately stop the tests from running and others that register the failure
but report it after all tests finish running. To reflect this behaviour, these
functions are aptly named: <code>Fail</code> and <code>FailNow</code>.</p>
<p>Let's explore their behaviour and usage by continuing testing the <code>Max</code>
function we already built.</p>
<p>One other test case that we could write is checking that the slice passed as
argument is not empty. If it is, we will return <code>-1</code>, otherwise the maximum
item we find. Let's write the new test first:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="color:#b84">&#34;testing&#34;</span>

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	input <span style="font-weight:bold">:=</span> []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>}
	actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(input)
	expected <span style="font-weight:bold">:=</span> <span style="color:#099">5</span>

	<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
		t.<span style="color:#900;font-weight:bold">Fail</span>()
		t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMaxEmptySlice</span>(t <span style="font-weight:bold">*</span>testing.T) {
	input <span style="font-weight:bold">:=</span> []<span style="color:#458;font-weight:bold">int</span>{}
	actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(input)
	expected <span style="font-weight:bold">:=</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>

	<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
		t.<span style="color:#900;font-weight:bold">Fail</span>()
		t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}</code></pre></div>
<p>If we run it, without adding any new functionality to the <code>Max</code> function, it
will fail:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">âº go test
--- FAIL: TestMaxEmptySlice (0.00s)
    max_test.go:22: Expected -1, got 0
FAIL
exit status 1
FAIL	_/users/Ilija/Documents/testing	0.005s</code></pre></div>
<p>What we can see here is that the <code>TestMax</code> function is run and it passes, while
the <code>TestMaxEmptySlice</code> fails. We achieve that by marking the test as failed
using <code>t.Fail()</code>. Let's add the new functionality to <code>Max</code> which would make the
test pass:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">Max</span>(numbers []<span style="color:#458;font-weight:bold">int</span>) <span style="color:#458;font-weight:bold">int</span> {
	<span style="font-weight:bold">if</span> <span style="color:#999">len</span>(numbers) <span style="font-weight:bold">==</span> <span style="color:#099">0</span> {
		<span style="font-weight:bold">return</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>
	}

	<span style="font-weight:bold">var</span> max <span style="color:#458;font-weight:bold">int</span>

	<span style="font-weight:bold">for</span> _, number <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> numbers {
		<span style="font-weight:bold">if</span> number &gt; max {
			max = number
		}
	}

	<span style="font-weight:bold">return</span> max
}</code></pre></div>
<p>While the change does not make much sense, for our purpose it will do the
trick. Let's run the test:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">âº go test
PASS
ok  	_/Users/Ilija/Documents/testing	0.004s</code></pre></div>
<p>Now, if we look into the two things that the <code>Max</code> function does, we could
theoretically attach an importance level to both of them. For example, the
guard clause which returns <code>-1</code> when the slice argument is empty has lower
importance than the actual algorithm that detects the maximum element of the
slice. That means that if someone is expanding that algorithm and it goes wrong
we want to be very loud and &ldquo;stop the world&rdquo;, as none of the other
functionalities is more relevant than that one.</p>
<p>In cases like these, we can use the <code>FailNow()</code> function to mark the failed
test and to immediately stop any further execution of the particular test that
tests the max detection. Let's use it in our tests:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="color:#b84">&#34;testing&#34;</span>

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	input <span style="font-weight:bold">:=</span> []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>}
	actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(input)
	expected <span style="font-weight:bold">:=</span> <span style="color:#099">5</span>

	<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
		t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
		t.<span style="color:#900;font-weight:bold">FailNow</span>()
	}
}

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMaxEmptySlice</span>(t <span style="font-weight:bold">*</span>testing.T) {
	input <span style="font-weight:bold">:=</span> []<span style="color:#458;font-weight:bold">int</span>{}
	actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(input)
	expected <span style="font-weight:bold">:=</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>

	<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
		t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
		t.<span style="color:#900;font-weight:bold">Fail</span>()
	}
}</code></pre></div>
<p>Also, we need to make the <code>Max</code> function misbehave. To short-circuit this
quickly, let's make the <code>Max</code> function return <code>-100</code> so we can see the
difference.</p>
<p>If we would run this now, there would not be a difference in how the tests will
run, although we use <code>FailNow</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">âº go test -v
=== RUN   TestMax
--- FAIL: TestMax (0.00s)
    max_test.go:11: Expected 5, got -100
=== RUN   TestMaxEmptSlice
--- FAIL: TestMaxEmptySlice (0.00s)
    max_test.go:22: Expected -1, got -100
FAIL
exit status 1
FAIL	_/Users/Ilija/Documents/testing	0.005s</code></pre></div>
<p>That is because the <code>TestMax</code> function only does one assertion. Let's rework
our tests a bit to use table-driven tests:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> TestCase <span style="font-weight:bold">struct</span> {
	input    []<span style="color:#458;font-weight:bold">int</span>
	expected <span style="color:#458;font-weight:bold">int</span>
}

<span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	cases <span style="font-weight:bold">:=</span> []TestCase{
		TestCase{
			input:    []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>},
			expected: <span style="color:#099">5</span>,
		},
		TestCase{
			input:    []<span style="color:#458;font-weight:bold">int</span>{<span style="font-weight:bold">-</span><span style="color:#099">1</span>, <span style="font-weight:bold">-</span><span style="color:#099">2</span>, <span style="font-weight:bold">-</span><span style="color:#099">3</span>, <span style="font-weight:bold">-</span><span style="color:#099">4</span>, <span style="font-weight:bold">-</span><span style="color:#099">5</span>},
			expected: <span style="font-weight:bold">-</span><span style="color:#099">1</span>,
		},
		TestCase{
			input:    []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">0</span>},
			expected: <span style="color:#099">0</span>,
		},
	}

	<span style="font-weight:bold">for</span> _, c <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> cases {
		actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(c.input)
		expected <span style="font-weight:bold">:=</span> c.expected

		<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
			t.<span style="color:#900;font-weight:bold">Logf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
			t.<span style="color:#900;font-weight:bold">Fail</span>()
		}
	}
}</code></pre></div>
<p>What the table-driven tests do is they loop over multiple test cases (often
structs with the expected input and output), and they set assertions on them.
If we would run the tests now, with using <code>t.Fail()</code> instead of <code>t.FailNow()</code>
we should see the following output:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">âº go test
--- FAIL: TestMax (0.00s)
    max_test.go:31: Expected 5, got -100
    max_test.go:31: Expected -1, got -100
    max_test.go:31: Expected 0, got -100
--- FAIL: TestMaxEmptySlice (0.00s)
    max_test.go:43: Expected -1, got -100
FAIL
exit status 1
FAIL	_/Users/Ilija/Documents/testing	0.005s</code></pre></div>
<p>We actually get all failing cases for both tests. Let's replace the <code>t.Fail()</code>
invocation to <code>t.FailNow()</code> in the <code>TestMax</code> function and run the test:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">âº go test -v
=== RUN   TestMax
--- FAIL: TestMax (0.00s)
    max_test.go:31: Expected 5, got -100
=== RUN   TestMaxEmptSlice
--- FAIL: TestMaxEmptySlice (0.00s)
    max_test.go:43: Expected -1, got -100
FAIL
exit status 1
FAIL	_/Users/Ilija/Documents/testing	0.004s</code></pre></div>
<p>You can see that instead of running each of the test cases and marking them as
failures, the test function stopped right after hitting the first case which
failed, instead of going through each case before reporting all of the errors.</p>
<p>This is the key difference between the two, <code>t.Fail()</code> and <code>t.FailNow()</code>. By
using the latter we are able to stop the tests and communicate with the
developer that there's something really wrong happening quickly. In comparison,
imagine if we had to wait for all test cases to complete before we have some
sort of output âÂ it would take much longer to get any meaningful output.</p>
<p>Having a clear difference and use cases for <code>Fail</code> and <code>FailNow</code> in mind, let's
look into how we can combine failure reporting (<code>Log</code> and <code>Logf</code>) with failure
marking (<code>Fail</code> and <code>FailNow</code>) in a more structured approach.</p>
<h2 id="signal--report-failures-in-one-go">Signal &amp; report failures in one go</h2>
<p>Understanding the basics and variations of logging and signaling errors is
crucial to understand what we will talk about now. If you look at all the tests
we wrote so far, although we switched up the approaches by using table-driven
tests, two steps were constant:</p>
<ol>
<li>In all tests we had to check for a mismatch between the expected and the
actual values, and</li>
<li>We had to call report (<code>Log</code>) and signal failure (<code>Fail</code>) if there was a
mismatch</li>
</ol>
<p>Luckily, the <code>testing</code> package makes our life a bit easier by implementing
functions that combine both, the logging and the test failure. And because
there are two ways to signal test failures, there are two functions to do this:
<code>Error</code> and <code>Fatal</code>, with their own variants.</p>
<p>Let's reuse the tests that we wrote above, namely the <code>TestMax</code> and
<code>TestMaxEmptySlice</code> functions. If we would like to quickly collapse the
invocation of <code>t.FailNow()</code> and <code>t.Log()</code> we can simply use <code>t.Fatal()</code>. We use
<code>t.Logf()</code> instead of <code>t.Log()</code> in our test functions but conveniently for us,
the <code>testing</code> package also implements a <code>t.Fatalf()</code> function, which is a
combination of <code>t.FailNow()</code> + <code>t.Logf()</code>.</p>
<p>Let's see how we can use it in our <code>TestMax</code> test function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestMax</span>(t <span style="font-weight:bold">*</span>testing.T) {
	cases <span style="font-weight:bold">:=</span> []TestCase{
		TestCase{
			input:    []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>},
			expected: <span style="color:#099">5</span>,
		},
		TestCase{
			input:    []<span style="color:#458;font-weight:bold">int</span>{<span style="font-weight:bold">-</span><span style="color:#099">1</span>, <span style="font-weight:bold">-</span><span style="color:#099">2</span>, <span style="font-weight:bold">-</span><span style="color:#099">3</span>, <span style="font-weight:bold">-</span><span style="color:#099">4</span>, <span style="font-weight:bold">-</span><span style="color:#099">5</span>},
			expected: <span style="font-weight:bold">-</span><span style="color:#099">1</span>,
		},
		TestCase{
			input:    []<span style="color:#458;font-weight:bold">int</span>{<span style="color:#099">0</span>},
			expected: <span style="color:#099">0</span>,
		},
	}

	<span style="font-weight:bold">for</span> _, c <span style="font-weight:bold">:=</span> <span style="font-weight:bold">range</span> cases {
		actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(c.input)
		expected <span style="font-weight:bold">:=</span> c.expected

		<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
			t.<span style="color:#900;font-weight:bold">Fatalf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
		}
	}
}</code></pre></div>
<p>The change is pretty simple. Basically, we keep the log format and content, but
instead of passing it to <code>t.Logf()</code> we pass it to <code>t.Fatalf()</code> as an argument,
while <code>t.FailNow()</code> can be completely removed. If we run our specs again we
will not see any difference in the behaviour or the output in comparison to the
previous implementation:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">âº go test
--- FAIL: TestMax (0.00s)
    max_test.go:31: Expected 5, got -100
--- FAIL: TestMaxEmptySlice (0.00s)
    max_test.go:42: Expected -1, got -100
FAIL
exit status 1
FAIL	_/users/Ilija/Documents/testing	0.005s</code></pre></div>
<p>The style of invocation of <code>t.Fatalf()</code> we see here also applies to <code>t.Error()</code>
and <code>t.Errorf()</code>. We can make a small change to our <code>TestMaxEmptySlice function and use </code>t.Errorf()<code>instead of a combination of</code>t.Logf()<code> and</code>t.Fail()`:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> TestMaxEmptySlice t <span style="font-weight:bold">*</span>testing.T) {
	input <span style="font-weight:bold">:=</span> []<span style="color:#458;font-weight:bold">int</span>{}
	actual <span style="font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">Max</span>(input)
	expected <span style="font-weight:bold">:=</span> <span style="font-weight:bold">-</span><span style="color:#099">1</span>

	<span style="font-weight:bold">if</span> actual <span style="font-weight:bold">!=</span> expected {
		t.<span style="color:#900;font-weight:bold">Errorf</span>(<span style="color:#b84">&#34;Expected %d, got %d&#34;</span>, expected, actual)
	}
}</code></pre></div>
<p>The usage of <code>t.Errorf()</code> is the same as the one of <code>t.Fatalf()</code> in the
previous example. As expected, the output and the behaviour of the test
function also will not change:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">âº go test
--- FAIL: TestMax (0.00s)
    max_test.go:31: Expected 5, got -100
--- FAIL: TestMaxEmptySlice (0.00s)
    max_test.go:42: Expected -1, got -100
FAIL
exit status 1
FAIL	_/users/Ilija/Documents/testing	0.005s</code></pre></div>
<h2 id="when-to-use-errorf-or-fatalf">When to use <code>Error(f)</code> or <code>Fatal(f)</code></h2>
<p>So, we took a look at all the variations of signaling test failures and
logging such failures and the behaviour of the respective functions. For those
of you wondering when you should use <code>Error</code> or <code>Fatal</code>, I think that's a very
important question that we should explore and find a good answer for.</p>
<p>Now, there's no hard and fast answer here. In cases like these, we need to look
at certain rules or guidelines on when to use these functions. If we look at
the composition of these two functions, it would look something like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">Error</span>()  = <span style="color:#900;font-weight:bold">Fail</span>()    <span style="font-weight:bold">+</span> <span style="color:#900;font-weight:bold">Log</span>()
<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">Errorf</span>() = <span style="color:#900;font-weight:bold">Fail</span>()    <span style="font-weight:bold">+</span> <span style="color:#900;font-weight:bold">Logf</span>()
<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">Fatal</span>()  = <span style="color:#900;font-weight:bold">FailNow</span>() <span style="font-weight:bold">+</span> <span style="color:#900;font-weight:bold">Log</span>()
<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">Fatalf</span>() = <span style="color:#900;font-weight:bold">FailNow</span>() <span style="font-weight:bold">+</span> <span style="color:#900;font-weight:bold">Logf</span>()</code></pre></div>
<p>By looking at the composition of these functions, getting a clearer indication
of the intended usage is easier:</p>
<p>If marking the test function as failed, but continuing its execution can/will
provide the user (the programmer) more information that can aid them in fixing
the failure, it's better to use <code>Error(f)</code> instead of <code>Fatal(f)</code>. If unsure,
start with <code>Error(f)</code> and work your way towards a definitive approach. There
are multiple examples to this scenario: your test function is to execute
multiple queries against a test database and not failing on the error from the
first query might give you more debugging information.</p>
<p>In cases, where a test function cannot recover from the failure and continuing
its execution is useless/doesn't make sense, it's better to use <code>Fatal(f)</code> and
stop the further execution. Such cases are errors while loading fixtures or
filesystem permission errors.</p>
<p>These are two guidelines you can use to choose what functions to use. Of
course, there are exceptions to this so it's up to us to use good judgement
when writing our test functions.</p>
<h2 id="in-closing">In closing</h2>
<p>In this article, we explored a lot of the details around failing tests. We went
deep in to understand how failure logging is done using Go's <code>testing</code> package</p>
<ul>
<li>although it was unclear at that moment how it is related to failing tests.
Then we went on to explore signaling test failures and the different
approaches we can take when marking our tests as failed.</li>
</ul>
<p>We looked in depth what is the difference between <code>Fail</code> and <code>FailNow</code>, and how
to apply them better in our tests. In the end, we looked at some neat functions
that the <code>testing</code> package has that make our lives a bit simpler. We discussed
two different strategies of using the <code>Error</code> and the <code>Fatal</code> functions in our
tests.</p>
<p>If you would like to learn more about marking tests as failed in Go, you can
check <a href="https://golang.org/pkg/testing/">the documentation</a> of the <code>testing</code>
package.</p>







<div id="mc_embed_signup">
<form action="https://pm.us20.list-manage.com/subscribe/post?u=d9a6471309140dcd520d05346&amp;id=2aac491644" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
        <div class="heading">Join The Newsletter</div>
        <p>
            I write about backend technologies, programming and cloud architectures. Join hundreds of other developers that get my content, twice a month. Unsubscribe whenever. Never spam.
        </p>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
        <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">

      
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d9a6471309140dcd520d05346_2aac491644" tabindex="-1" value=""></div>

    <p>You can also subscribe <a href="/index.xml">via RSS</a>.</p>
    </div>
</form>
</div>



			</div>

			<div class="tags">
				
					
				
			</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'eftimov';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> Copyright Â© 2014 - 2019 Ilija Eftimov |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-11264459-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
