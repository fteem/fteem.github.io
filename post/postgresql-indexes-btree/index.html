<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PostgreSQL Indexes: B-Tree | Ilija Eftimov ⚡️</title><meta name=keywords content="b-tree"><meta name=description content="Indexes in relational databases are a very imporatant feature, that reduce the cost of our lookup queries. In the last post on the basics of indexes in PostgreSQL, we covered the fundamentals and saw how we can create an index on a table and measure it&rsquo;s impact on our queries. In this post, we will take a dive into the inner workings and some implmentation details of the most used index type in PostgreSQL - the B-Tree index."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/postgresql-indexes-btree/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="PostgreSQL Indexes: B-Tree"><meta property="og:description" content="Indexes in relational databases are a very imporatant feature, that reduce the cost of our lookup queries. In the last post on the basics of indexes in PostgreSQL, we covered the fundamentals and saw how we can create an index on a table and measure it&rsquo;s impact on our queries. In this post, we will take a dive into the inner workings and some implmentation details of the most used index type in PostgreSQL - the B-Tree index."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/postgresql-indexes-btree/"><meta property="og:image" content="https://ieftimov.com/cards/postgresql-indexes-btree.png"><meta property="article:section" content="posts"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/postgresql-indexes-btree.png"><meta name=twitter:title content="PostgreSQL Indexes: B-Tree"><meta name=twitter:description content="Indexes in relational databases are a very imporatant feature, that reduce the cost of our lookup queries. In the last post on the basics of indexes in PostgreSQL, we covered the fundamentals and saw how we can create an index on a table and measure it&rsquo;s impact on our queries. In this post, we will take a dive into the inner workings and some implmentation details of the most used index type in PostgreSQL - the B-Tree index."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"PostgreSQL Indexes: B-Tree","item":"https://ieftimov.com/post/postgresql-indexes-btree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL Indexes: B-Tree","name":"PostgreSQL Indexes: B-Tree","description":"Indexes in relational databases are a very imporatant feature, that reduce the cost of our lookup queries. In the last post on the basics of indexes in PostgreSQL, we covered the fundamentals and saw how we can create an index on a table and measure it\u0026rsquo;s impact on our queries. In this post, we will take a dive into the inner workings and some implmentation details of the most used index type in PostgreSQL - the B-Tree index.","keywords":["b-tree"],"articleBody":"Indexes in relational databases are a very imporatant feature, that reduce the cost of our lookup queries. In the last post on the basics of indexes in PostgreSQL, we covered the fundamentals and saw how we can create an index on a table and measure it’s impact on our queries. In this post, we will take a dive into the inner workings and some implmentation details of the most used index type in PostgreSQL - the B-Tree index.\nWhat is B-Tree? From Wikipedia’s page on B-Tree:\n In computer science, a B-tree is a self-balancing tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time.\n Awesome, right? Basically, it’s a data structure that sorts itself. That’s why it’s self-balancing - it chooses it’s shape on it’s own.\n The B-tree is a generalization of a binary search tree in that a node can have more than two children. Unlike self-balancing binary search trees, the B- tree is optimized for systems that read and write large blocks of data.\n Unlike regular binary trees, the B-Tree can have multiple leaves, which it balances on it’s own. Also, it’s implementations are I/O optimized, which makes them suitable for database indexes.\n B-trees are a good example of a data structure for external memory. It is commonly used in databases and filesystems.\n Now, there’s plenty to know about B-Trees. Knowing how they work is pretty interesting, so let’s check it out.\nFunctionality As a disclaimer before we start with the B-Tree as a self-balancing data structure, I would like to inform you that there is a lot of CS theory about the B-Tree, which we will not cover in this section. For example, you might want to look first at binary trees, 23-trees and 234-trees before you dive into B-Trees. Nevertheless, what we will cover here will be sufficient for you to understand how the B-Tree index works.\nHaving that out of the way, think of a binary tree. In binary trees, each node can have a maximum of two children, hence the name - binary.\nA Binary TreeWell, a B-Tree is a tree where each node can have multiple children, or better said, a B-Tree can have N children. While in binary search trees each node can have one value, B-Trees have the concept of keys. Keys are like a list of values, that each of the nodes will hold.\nB-Trees also have the concept of order, where for B-Trees an order of 3 means that each non-leaf node of the tree can have a maximum of 3 children. Having that in mind, this means that each node can have two (3-1) keys.\nConfusing? Well, think about this: on a non-leaf node with keys 5, 10, you can add three nodes:\n one node, with values smaller than 5 one node, with values between 5 and 10 and one node, with values larger than 10  Let’s draw it out:\nThe most important thing about B-Trees is their balaning aspect. The concept revolves on the fact that each node has keys, like in the example above. The way B-Trees balance themselves is really interesting, and the keys are the most important aspect of this this functionality.\nBasically, whenever a new item (or, in our case, a number) is added, the B-Tree finds the appropriate place (or, node) for the item to go in. For example, if we want to add the number 6, the B-Tree will “ask the root node”, in what node should it push the number in. “Asking” is nothing more than comparing the new number with the keys of the node. Since the number 6 is larger then 5, but smaller then the number 10 (which are the root node keys), it will create a new node just below the root node:\nWith this mechanism, the B-Tree is always ordered and looking up a value in it is rather cheap. There are multiple implementations of B-Trees. For this post, it’s nice to know that PostgreSQL uses the B-Tree implementation of the “Lehman and Yao’s high-concurrency B-tree management algorithm”. You can read the actual paper here{:target=\"_blank\"}.\nBut, how is this relevant to the B-Tree indexes in PostgreSQL?\nB-Trees and PostgreSQL Indexes in PostgreSQL, simply put, are a replica of the data on the column(s) that is/are indexed. The only difference is in the data order - the replica of the data is sorted, which allows PostgreSQL to quickly find and retrieve the data. For example, when you search for a record in a table, where the column by which you are searching is indexed, the index decreases the cost of the query because PostgreSQL looks up in the index and can easily find the location of the data on disk.\nThe B-Tree data structure falls really nice into place, when you recall that the index is ordered. Under the hood, indexes are B-Trees, but really big ones. Due to the nature of the B-Tree data structure, whenever a new record is added on the indexed table it knows how to rebalance and keep the order of the records in it.\nLimitations Almost in all use cases, the power of indexes is noticable on large amounts of data. This means that the indexes will have to be as big as the actual data tables. Or does it?\nImagine if we are dealing with billions of records. This means that the index tables will have the billions of records stored in an ordered fashion. Okay, PostgreSQL could handle that. But, can you imagine how long would an INSERT command take? Adding the record in the data table will take really long, because the index will have to add the new record in the correct place, to keep the order of the indexes. Due to this limitation, the implementation of the B-Tree index keeps page files, which simply put, are nodes on a big B-Tree data structure.\nAlthough each index is a whole, this paging mechanism adds a separation of the data in the index, while still keeping the order. In that case, instead of dumping the whole index into memory just to add a single record, PostgreSQL finds the page where the new record should be added and writes the indexed value into it.\nMy explanation is quite abstract, but the aim of this article was to introduce the B-Tree data structure and how it falls into place with PostgreSQL. If you would like to read more details on the implementation, check Discovering the Computer Science Behind Postgres Indexes from Pat Shaughnessy. Actually, if I knew of the existence of his article before I started writing this article, I might have not even written it.\nUsing a B-Tree index Having the workings of B-Tree index aside, let’s see how to use it. The command to add an index to a column is:\nCREATE INDEX name ON table USING btree (column); Or, since the btree index is the default one, we can omit the USING part of the command:\nCREATE INDEX name ON table; This will create a BTree index on the name column in the table table.\nOutro In this article we took an overview on one of the most popular indexes in PostgreSQL. We saw what is the difference between Binary Search Trees and B-Trees, and how their behaviour translates into PostgreSQL. Take note, there is a ton of detail that I had to omit due to the length of the article and the target audience.\nLinks If you would like to dig in deeper into B-Tree, whether the index or the data structure, here are some useful links:\n Efficient Locking for Concurrent Operations on B-Trees B-Trees Anatomy of an SQL index B-Tree on Wikipedia   Liked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to +1000 of other engineers.  I care about your privacy, and will never send you spam. You can unsubscribe at any time.\n ","wordCount":"1330","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/postgresql-indexes-btree/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PostgreSQL Indexes: B-Tree</h1><div class=post-meta>February 23, 2016&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#what-is-b-tree aria-label="What is B-Tree?">What is B-Tree?</a><ul><li><a href=#functionality aria-label=Functionality>Functionality</a></li></ul></li><li><a href=#b-trees-and-postgresql aria-label="B-Trees and PostgreSQL">B-Trees and PostgreSQL</a><ul><li><a href=#limitations aria-label=Limitations>Limitations</a></li></ul></li><li><a href=#using-a-b-tree-index aria-label="Using a B-Tree index">Using a B-Tree index</a></li><li><a href=#outro aria-label=Outro>Outro</a></li><li><a href=#links aria-label=Links>Links</a></li></ul></div></details></div><div class=post-content><p>Indexes in relational databases are a very imporatant feature, that reduce the
cost of our lookup queries. In the last post on
<a href=/postgresql-indexes-first-principles>the basics of indexes</a> in PostgreSQL, we
covered the fundamentals and saw how we can create an index on a table and
measure it&rsquo;s impact on our queries. In this post, we will take a dive into the
inner workings and some implmentation details of the most used index type in
PostgreSQL - the B-Tree index.</p><h2 id=what-is-b-tree>What is B-Tree?<a hidden class=anchor aria-hidden=true href=#what-is-b-tree>#</a></h2><p>From Wikipedia&rsquo;s page on B-Tree:</p><blockquote><p>In computer science, a B-tree is a self-balancing tree data structure that
keeps data sorted and allows searches, sequential access, insertions, and
deletions in logarithmic time.</p></blockquote><p>Awesome, right? Basically, it&rsquo;s a data structure that sorts itself. That&rsquo;s why
it&rsquo;s self-balancing - it chooses it&rsquo;s shape on it&rsquo;s own.</p><blockquote><p>The B-tree is a generalization of a binary search tree in that a node can have
more than two children. Unlike self-balancing binary search trees, the B-
tree is optimized for systems that read and write large blocks of data.</p></blockquote><p>Unlike regular binary trees, the B-Tree can have multiple leaves, which it
balances on it&rsquo;s own. Also, it&rsquo;s implementations are I/O optimized, which makes
them suitable for database indexes.</p><blockquote><p>B-trees are a good example of a data structure for external memory. It is
commonly used in databases and filesystems.</p></blockquote><p>Now, there&rsquo;s plenty to know about B-Trees. Knowing how they work is pretty
interesting, so let&rsquo;s check it out.</p><h3 id=functionality>Functionality<a hidden class=anchor aria-hidden=true href=#functionality>#</a></h3><p>As a disclaimer before we start with the B-Tree as a self-balancing data
structure, I would like to inform you that there is a lot of CS theory about the
B-Tree, which we will not cover in this section. For example, you might
want to look first at binary trees, 23-trees and 234-trees before you dive into
B-Trees. Nevertheless, what we will cover here will be sufficient for you to
understand how the B-Tree index works.</p><p>Having that out of the way, think of a binary tree. In binary trees, each node
can have a maximum of two children, hence the name - binary.</p><p><img src=/binary-tree.jpg alt></p><p>A Binary Tree</p><p>Well, a B-Tree is a tree where each node can have multiple children, or better
said, a B-Tree can have <strong>N</strong> children. While in binary search trees each node
can have one value, B-Trees have the concept of <strong>keys</strong>. Keys are like a list
of values, that each of the nodes will hold.</p><p>B-Trees also have the concept of <strong>order</strong>, where for B-Trees an order of 3
means that each non-leaf node of the tree can have a <strong>maximum</strong> of 3 children.
Having that in mind, this means that each node can have two (3-1) keys.</p><p>Confusing? Well, think about this: on a non-leaf node with keys <code>5, 10</code>, you can
add three nodes:</p><ul><li>one node, with values smaller than 5</li><li>one node, with values between 5 and 10</li><li>and one node, with values larger than 10</li></ul><p>Let&rsquo;s draw it out:</p><p><img src=/b-tree-example-1.jpg alt></p><p>The most important thing about B-Trees is their balaning aspect. The concept
revolves on the fact that each node has keys, like in the example above. The way
B-Trees balance themselves is really interesting, and the keys are the most
important aspect of this this functionality.</p><p>Basically, whenever a new item (or, in our case, a number) is added, the B-Tree
finds the appropriate place (or, node) for the item to go in. For example,
if we want to add the number 6, the B-Tree will &ldquo;ask the root node&rdquo;, in what
node should it push the number in. &ldquo;Asking&rdquo; is nothing more than comparing the new
number with the keys of the node. Since the number 6 is larger then 5, but
smaller then the number 10 (which are the root node keys), it will create a new
node just below the root node:</p><p><img src=/b-tree-example-2.jpg alt></p><p>With this mechanism, the B-Tree is always ordered and looking up a value in it
is rather cheap. There are multiple implementations of B-Trees. For this post,
it&rsquo;s nice to know that PostgreSQL uses the B-Tree implementation of the &ldquo;Lehman
and Yao&rsquo;s high-concurrency B-tree management algorithm&rdquo;. You can read the actual
paper <a href=http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf>here</a>{:target="_blank"}.</p><p>But, how is this relevant to the B-Tree indexes in PostgreSQL?</p><h2 id=b-trees-and-postgresql>B-Trees and PostgreSQL<a hidden class=anchor aria-hidden=true href=#b-trees-and-postgresql>#</a></h2><p>Indexes in PostgreSQL, simply put, are a replica of the data on the column(s)
that is/are indexed. The only difference is in the data order - the replica of
the data is sorted, which allows PostgreSQL to quickly find and retrieve the
data. For example, when you search for a record in a table, where the column by
which you are searching is indexed, the index decreases the cost of the query
because PostgreSQL looks up in the index and can easily find the location of
the data on disk.</p><p>The B-Tree data structure falls really nice into place, when you recall that
the index is ordered. Under the hood, indexes are B-Trees, but really big ones.
Due to the nature of the B-Tree data structure, whenever a new record is added
on the indexed table it knows how to rebalance and keep the order of the
records in it.</p><h3 id=limitations>Limitations<a hidden class=anchor aria-hidden=true href=#limitations>#</a></h3><p>Almost in all use cases, the power of indexes is noticable on large amounts of
data. This means that the indexes will have to be as big as the actual data
tables. Or does it?</p><p>Imagine if we are dealing with billions of records. This means that the index
tables will have the billions of records stored in an ordered fashion. Okay,
PostgreSQL could handle that. But, can you imagine how long would an <code>INSERT</code>
command take? Adding the record in the data table will take really long,
because the index will have to add the new record in the correct place, to keep
the order of the indexes. Due to this limitation, the implementation of the
B-Tree index keeps <strong>page files</strong>, which simply put, are nodes on a big B-Tree
data structure.</p><p>Although each index is a whole, this paging mechanism adds a separation of the
data in the index, while still keeping the order. In that case, instead of
dumping the whole index into memory just to add a single record, PostgreSQL
finds the page where the new record should be added and writes the indexed
value into it.</p><p>My explanation is quite abstract, but the aim of this article was to introduce
the B-Tree data structure and how it falls into place with PostgreSQL. If you
would like to read more details on the implementation, check <a href=http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes>Discovering the
Computer Science Behind Postgres
Indexes</a>
from Pat Shaughnessy. Actually, if I knew of the existence of his article
before I started writing this article, I might have not even written it.</p><h2 id=using-a-b-tree-index>Using a B-Tree index<a hidden class=anchor aria-hidden=true href=#using-a-b-tree-index>#</a></h2><p>Having the workings of B-Tree index aside, let&rsquo;s see how to use it. The command
to add an index to a column is:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#719e07>CREATE</span> <span style=color:#719e07>INDEX</span> name <span style=color:#719e07>ON</span> <span style=color:#719e07>table</span> <span style=color:#719e07>USING</span> btree (<span style=color:#719e07>column</span>);</code></pre></div><p>Or, since the <code>btree</code> index is the default one, we can omit the <code>USING</code> part of
the command:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#719e07>CREATE</span> <span style=color:#719e07>INDEX</span> name <span style=color:#719e07>ON</span> <span style=color:#719e07>table</span>;</code></pre></div><p>This will create a BTree index on the <code>name</code> column in the <code>table</code> table.</p><h2 id=outro>Outro<a hidden class=anchor aria-hidden=true href=#outro>#</a></h2><p>In this article we took an overview on one of the most popular indexes in
PostgreSQL. We saw what is the difference between Binary Search Trees and
B-Trees, and how their behaviour translates into PostgreSQL. Take note, there
is a ton of detail that I had to omit due to the length of the article and the
target audience.</p><h2 id=links>Links<a hidden class=anchor aria-hidden=true href=#links>#</a></h2><p>If you would like to dig in deeper into B-Tree, whether the index or the data
structure, here are some useful links:</p><ul><li><a href=http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf>Efficient Locking for Concurrent Operations on B-Trees</a></li><li><a href=http://www.cs.utexas.edu/users/djimenez/utsa/cs3343/lecture16.html>B-Trees</a></li><li><a href=http://use-the-index-luke.com/sql/anatomy>Anatomy of an SQL index</a></li><li><a href=https://en.wikipedia.org/wiki/B-tree>B-Tree on Wikipedia</a></li></ul><section class=subscribe><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to +1000 of other engineers.</p><script async data-uid=5495dc64a0 src=https://ilija.ck.page/5495dc64a0/index.js></script><p class=privacy>I care about your privacy, and will never send you spam. You can unsubscribe at any time.</p></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/b-tree/>b-tree</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/primitive-obsession-ruby/><span class=title>« Prev Page</span><br><span>Refactoring in Ruby: Primitive Obsession</span></a>
<a class=next href=https://ieftimov.com/post/postgresql-indexes-first-principles/><span class=title>Next Page »</span><br><span>PostgreSQL Indexes: First Principles</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: B-Tree on twitter" href="https://twitter.com/intent/tweet/?text=PostgreSQL%20Indexes%3a%20B-Tree&url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-btree%2f&hashtags=b-tree"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: B-Tree on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-btree%2f&title=PostgreSQL%20Indexes%3a%20B-Tree&summary=PostgreSQL%20Indexes%3a%20B-Tree&source=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-btree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: B-Tree on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-btree%2f&title=PostgreSQL%20Indexes%3a%20B-Tree"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: B-Tree on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-btree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: B-Tree on whatsapp" href="https://api.whatsapp.com/send?text=PostgreSQL%20Indexes%3a%20B-Tree%20-%20https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-btree%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: B-Tree on telegram" href="https://telegram.me/share/url?text=PostgreSQL%20Indexes%3a%20B-Tree&url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-btree%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>