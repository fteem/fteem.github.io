<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>A deeper dive in Elixir&#39;s Plug - Ilija Eftimov</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="A deeper dive in Elixir&#39;s Plug">
<meta itemprop="description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo; documentation. One thing that stood out for me recently is the first sentence of Phoenix&#39;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug.">
<meta itemprop="datePublished" content="2018-12-31T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-12-31T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="3226">
<meta itemprop="image" content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png">



<meta itemprop="keywords" content="cowboy,router,endpoint," /><meta property="og:title" content="A deeper dive in Elixir&#39;s Plug" />
<meta property="og:description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo; documentation. One thing that stood out for me recently is the first sentence of Phoenix&#39;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/" />
<meta property="og:image" content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png" />
<meta property="article:published_time" content="2018-12-31T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-12-31T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png"/>

<meta name="twitter:title" content="A deeper dive in Elixir&#39;s Plug"/>
<meta name="twitter:description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo; documentation. One thing that stood out for me recently is the first sentence of Phoenix&#39;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://ieftimov.com/css/main.css" />
		<link rel="stylesheet" type="text/css" href="https://ieftimov.com/css/overrides.css" />
	

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://ieftimov.com/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="https://ieftimov.com/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="https://ieftimov.com/">
				<img src="/avatar.png" alt="Ilija Eftimov" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="https://ieftimov.com/">Ilija Eftimov</a></h1>
	<div class="site-description"><p>Thoughts on simple software engineering</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/fteem" title="Github"><i data-feather="github"></i></a></li><li><a href="https://twitter.com/itsilija" title="Twitter"><i data-feather="twitter"></i></a></li><li><a href="https://www.linkedin.com/in/ieftimov" title="Linkedin"><i data-feather="linkedin"></i></a></li><li><a href="mailto:blog@ieftimov.com" title="Email"><i data-feather="mail"></i></a></li><li><a href="https://t.me/ieftimovcom" title="Telegram Channel"><i data-feather="send"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li><li><a href="#" class="scheme-toggle" id="scheme-toggle"></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/categories/testing-in-go">Testing in Go</a>
			</li>
			
			<li>
				<a href="/posts">Archive</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="https://forms.gle/orfXK5jh1LRaiFzo8">Suggest a topic</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">31</span>
							<span class="rest">Dec 2018</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">A deeper dive in Elixir&#39;s Plug</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo;
documentation. One thing that stood out for me recently is the first sentence
of <a href="https://hexdocs.pm/phoenix/plug.html#content">Phoenix's Plug
documentation</a>:</p>
<blockquote>
<p>Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.</p>
</blockquote>
<p>So naturally, I felt compelled to take a deeper dive into Plug and understand
it better. I hope the following article will help you out in understanding
Plug.</p>
<h2 id="whats-plug">What's Plug?</h2>
<p>As <a href="https://github.com/elixir-plug/plug#plug">the readme</a> puts it, Plug is:</p>
<ol>
<li>A specification for composable modules between web applications</li>
<li>Connection adapters for different web servers in the Erlang VM</li>
</ol>
<p>But, what does this mean? Well, it basically states that Plug 1) <em>defines the
way</em> you build web apps in Elixir and 2) it provides you with tools to write
apps that are understood by web servers.</p>
<p>Let's take a dive and see what that means.</p>
<h2 id="web-servers-yeehaw">Web servers, yeehaw!</h2>
<p>One of the most popular HTTP servers for Erlang is
<a href="https://github.com/ninenines/cowboy">Cowboy</a>. It is a small, fast and modern
HTTP server for Erlang/OTP. If you were to write any web application in Elixir
it will run on Cowboy, because the Elixir core team has built a Plug adapter
for Cowboy, conveniently named
<a href="https://github.com/elixir-plug/plug_cowboy">plug_cowboy</a>.</p>
<p>This means that if you include this package in your package, you will get the
Elixir interface to talk to the Cowboy web server (and vice-versa). It means
that you can send and receive requests and other stuff that web servers can do.</p>
<p>So why is this important?</p>
<p>Well, to understand Plug we need to understand how it works. Basically, using
the adapter (<code>plug_cowboy</code>), Plug can accept the connection request that comes
in Cowboy and turn it into a meaningful struct, also known as <code>Plug.Conn</code>.</p>
<p>This means that Plug uses <code>plug_cowboy</code> to understand Cowboy's nitty-gritty
details. By doing this Plug allows us to easily build handler functions and
modules that can receive, handle and respond to requests.</p>
<p>Of course, the idea behind Plug is not to work only with Cowboy. If you look at
<a href="https://stackoverflow.com/a/26323883/6015550">this SO answer</a> from José Valim
(Elixir's BDFL) he clearly states &ldquo;Plug is meant to be a generic adapter for
different web servers. Currently we support just Cowboy but there is work to
support others.&rdquo;</p>
<h2 id="enter-plug">Enter Plug</h2>
<p>Okay, now that we've scratched the surface of Cowboy and it's Plug adapter,
let's look at Plug itself.</p>
<p>If you look at <a href="https://github.com/elixir-plug/plug/blob/master/README.md">Plug's
README</a>, you will
notice that there are two flavours of plugs, a function or a module.</p>
<p>The most minimal plug can be a function, it just takes a <code>Plug.Conn</code> struct
(that we will explore more later) and some options. The function will
manipulate the struct and return it at the end. Here's the example from the
<code>README</code>:</p>
<p><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">def hello_world_plug(conn, _opts) do
  conn
  <span style="font-weight:bold">|&gt;</span> put_resp_content_type(<span style="color:#b84">&#34;</span><span style="color:#b84">text/plain</span><span style="color:#b84">&#34;</span>)
  <span style="font-weight:bold">|&gt;</span> send_resp(<span style="color:#099">200</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">Hello world</span><span style="color:#b84">&#34;</span>)
end</code></pre></div>
<!-- raw HTML omitted -->Code blatantly copied from
<a href="https://github.com/elixir-plug/plug/blob/master/README.md">Plug's docs</a>.
<!-- raw HTML omitted --></p>
<p>If you look at the function, it's quite simple. It receives the connection
struct, puts its content type to <code>text/plain</code> and returns a response with an
HTTP 200 status and <code>&quot;Hello world&quot;</code> as the body.</p>
<p>The second flavour is the module Plug. This means that instead of just having a
function that will be invoked as part of the request lifecycle, you can define
a module that takes a connection and initialized options and returns the
connection:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#458;font-weight:bold">MyPlug</span> do
  def init([]), <span style="color:#b84">do</span>: false
  def call(conn, _opts), <span style="color:#b84">do</span>: conn
end</code></pre></div>
<p><!-- raw HTML omitted -->Code blatantly copied from
<a href="https://github.com/elixir-plug/plug/blob/master/README.md">Plug's docs</a>.
<!-- raw HTML omitted --></p>
<p>Having this in mind, let's take a step further and see how we can use Plug in a
tiny application.</p>
<h2 id="plugging-a-plug-as-an-endpoint">Plugging a plug as an endpoint</h2>
<p>So far, the most important things we covered was what's Plug and what is it
used for on a high level. We also took a look at two different types of plugs.</p>
<p>Now, let's see how we can mount a Plug on a Cowboy server and essentially use
it as an endpoint:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#458;font-weight:bold">PlugTest</span> do
  import <span style="color:#458;font-weight:bold">Plug.Conn</span>

  def init(options) do
    <span style="color:#998;font-style:italic"># initialize options</span>

    options
  end

  def call(conn, _opts) do
    conn
    <span style="font-weight:bold">|&gt;</span> put_resp_content_type(<span style="color:#b84">&#34;</span><span style="color:#b84">text/plain</span><span style="color:#b84">&#34;</span>)
    <span style="font-weight:bold">|&gt;</span> send_resp(<span style="color:#099">200</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">Hello world</span><span style="color:#b84">&#34;</span>)
  end
end</code></pre></div>
<p>What this module will do is, when mounted on a Cowboy server, will set the
<code>Content-Type</code> header to <code>text/plain</code> and will return an HTTP 200 with a body of
<code>Hello world</code>.</p>
<p>Let's fire up IEx and test this ourselves:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">› iex -S mix
Erlang/OTP 21 [erts-10.2] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace]

Interactive Elixir (1.7.4) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; {:ok, _ } = Plug.Cowboy.http PlugTest, [], port: 3000
{:ok, #PID&lt;0.202.0&gt;}</code></pre></div>
<p>This starts the Cowboy server as a BEAM process, listening on port 3000. If we
<code>cURL</code> it we'll see the response body and it's headers:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">› curl -v 127.0.0.1:3000
&gt; GET / HTTP/1.1
&gt; Host: 127.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; cache-control: max-age=0, private, must-revalidate
&lt; content-length: 11
&lt; content-type: text/plain; charset=utf-8
&lt; date: Tue, 25 Dec 2018 22:54:54 GMT
&lt; server: Cowboy
&lt;
* Connection #0 to host 127.0.0.1 left intact
Hello world</code></pre></div>
<p>You see, the <code>Content-Type</code> of the response is set to <code>text/plain</code> and the body
is <code>Hello world</code>. In this example, the plug is essentially an endpoint by
itself, serving plain text to our <code>cURL</code> command (or to a browser). As you
might be able to imagine at this point, you can plug in much more elaborate
Plugs to a Cowboy server and it will serve them just fine.</p>
<p>To shut down the endpoint all you need to do is:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">iex(2)&gt; Plug.Cowboy.shutdown PlugTest.HTTP
:ok</code></pre></div>
<p>What we are witnessing here is probably the tiniest web application one can
write in Elixir. It's an app that takes a request and returns a valid response
over HTTP with a status and a body.</p>
<p>So, how does this actually work? How do we accept the request and build a
response here?</p>
<h2 id="diving-into-the-plugconn">Diving into the <code>Plug.Conn</code></h2>
<p>To understand this, we need to zoom in the <code>call/2</code> function of our module
<code>PlugTest</code>. I will also throw in an <code>IO.inspect</code> right at the end of the
function so we can inspect what this struct is:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">def call(conn, _opts) do
  conn
  <span style="font-weight:bold">|&gt;</span> put_resp_content_type(<span style="color:#b84">&#34;</span><span style="color:#b84">text/plain</span><span style="color:#b84">&#34;</span>)
  <span style="font-weight:bold">|&gt;</span> send_resp(<span style="color:#099">200</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">Hello world</span><span style="color:#b84">&#34;</span>)
  <span style="font-weight:bold">|&gt;</span> <span style="color:#458;font-weight:bold">IO</span><span style="font-weight:bold">.</span>inspect
end</code></pre></div>
<p>If you start the Cowboy instance again via your IEx session and you hit
<code>127.0.0.1:3000</code> via <code>cURL</code> (or a browser), you should see something like this
in your IEx session:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">%Plug.Conn{
  adapter: {Plug.Cowboy.Conn, :...},
  assigns: %{},
  before_send: [],
  body_params: %Plug.Conn.Unfetched{aspect: :body_params},
  cookies: %Plug.Conn.Unfetched{aspect: :cookies},
  halted: false,
  host: &#34;127.0.0.1&#34;,
  method: &#34;GET&#34;,
  owner: #PID&lt;0.316.0&gt;,
  params: %Plug.Conn.Unfetched{aspect: :params},
  path_info: [],
  path_params: %{},
  port: 3000,
  private: %{},
  query_params: %Plug.Conn.Unfetched{aspect: :query_params},
  query_string: &#34;&#34;,
  remote_ip: {127, 0, 0, 1},
  req_cookies: %Plug.Conn.Unfetched{aspect: :cookies},
  req_headers: [
    {&#34;accept&#34;,
     &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#34;},
    {&#34;accept-encoding&#34;, &#34;gzip, deflate, br&#34;},
    {&#34;accept-language&#34;, &#34;en-US,en;q=0.9&#34;},
    {&#34;connection&#34;, &#34;keep-alive&#34;},
    {&#34;host&#34;, &#34;127.0.0.1:3000&#34;},
    {&#34;upgrade-insecure-requests&#34;, &#34;1&#34;},
    {&#34;user-agent&#34;,
     &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#34;}
  ],
  request_path: &#34;/&#34;,
  resp_body: nil,
  resp_cookies: %{},
  resp_headers: [
    {&#34;cache-control&#34;, &#34;max-age=0, private, must-revalidate&#34;},
    {&#34;content-type&#34;, &#34;text/plain; charset=utf-8&#34;}
  ],
  scheme: :http,
  script_name: [],
  secret_key_base: nil,
  state: :sent,
  status: 200
}</code></pre></div>
<p>What are we actually looking at? Well, it's actually the Plug representation
of a connection. This is a direct interface to the underlying web server and
the request that the Cowboy server has received.</p>
<p>Some of the attributes of the struct are pretty self-explanatory, like <code>scheme</code>,
<code>method</code>, <code>host</code>, <code>request_path</code>, etc. If you would like to go into detail what
each of these fields is, I suggest taking a look at <code>Plug.Conn</code>'s
<a href="https://hexdocs.pm/plug/Plug.Conn.html#module-request-fields">documentation</a>.</p>
<p>But, to understand better the <code>Plug.Conn</code> struct, we need to understand the
connection lifecycle of each connection struct.</p>
<h3 id="connection-lifecycle">Connection lifecycle</h3>
<p>Just like any map in Elixir <code>Plug.Conn</code> allows us to pattern match on it. Let's
modify the little endpoint we created before and try to add some extra
<code>IO.inspect</code> function calls:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#458;font-weight:bold">PlugTest</span> do
  import <span style="color:#458;font-weight:bold">Plug.Conn</span>

  def init(options) do
    <span style="color:#998;font-style:italic"># initialize options</span>

    options
  end

  def call(conn, _opts) do
    conn
    <span style="font-weight:bold">|&gt;</span> inspect_state
    <span style="font-weight:bold">|&gt;</span> put_resp_content_type(<span style="color:#b84">&#34;</span><span style="color:#b84">text/plain</span><span style="color:#b84">&#34;</span>)
    <span style="font-weight:bold">|&gt;</span> inspect_state
    <span style="font-weight:bold">|&gt;</span> put_private(<span style="color:#b84">:foo</span>, <span style="color:#b84">:bar</span>)
    <span style="font-weight:bold">|&gt;</span> inspect_state
    <span style="font-weight:bold">|&gt;</span> resp(<span style="color:#099">200</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">Hello world</span><span style="color:#b84">&#34;</span>)
    <span style="font-weight:bold">|&gt;</span> inspect_state
    <span style="font-weight:bold">|&gt;</span> send_resp()
    <span style="font-weight:bold">|&gt;</span> inspect_state
  end

  defp inspect_state(conn <span style="font-weight:bold">=</span> %{<span style="color:#b84">state</span>: state}) do
    <span style="color:#458;font-weight:bold">IO</span><span style="font-weight:bold">.</span>inspect state
    conn
  end
end</code></pre></div>
<p>Because <code>Plug.Conn</code> allows pattern matching, we can get the <code>state</code> of the
connection, print it out and return the connection itself so the pipeline in
the <code>call/2</code> function would continue working as expected.</p>
<p>Let's mount this plug on a Cowboy instance and hit it with a simple <code>cURL</code>
request:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">iex<span style="font-weight:bold">(</span>6<span style="font-weight:bold">)</span>&gt; Plug.Cowboy.http PlugTest, <span style="font-weight:bold">[</span><span style="font-weight:bold">]</span>, port: <span style="color:#099">3000</span>
<span style="font-weight:bold">{</span>:ok, <span style="color:#998;font-style:italic">#PID&lt;0.453.0&gt;}</span>

<span style="color:#998;font-style:italic"># curl 127.0.0.1:3000</span>

iex<span style="font-weight:bold">(</span>21<span style="font-weight:bold">)</span>&gt; :unset
:unset
:unset
:set
:sent</code></pre></div>
<p>You see, when the connection enters the plug it's state changes from <code>:unset</code> to
<code>:set</code> to finally <code>:sent</code>. This means that once the plug is invoked the state of
the connection is <code>:unset</code>. Then we do multiple actions, or in other words, we
invoke multiple functions on the <code>Plug.Conn</code> which add more information to the
connection. Obviously, since all variables in Elixir are immutable, each of
these function returns a new <code>Plug.Conn</code> instance, instead of mutating the
existing one.</p>
<p>Once the body and the status of the connection are set, then the state changes
to <code>:set</code>. Up until that moment, the state is fixed as <code>:unset</code>. Once we send
the response back to the client the state is changed to <code>:sent</code>.</p>
<p>What we need to understand here is that whether we have one or more plugs in a
pipeline, they will all receive a <code>Plug.Conn</code>, call functions on it, whether
to extract or add data to it and then the connection will be passed on to the
next plug. Eventually, in the pipeline, there will be a plug (in the form of an
endpoint or a Phoenix controller) that will set the body and the response status
and send the response back to the client.</p>
<p>There are a bit more details to this, but this is just enough to wrap our minds
around <code>Plug</code> and <code>Plug.Conn</code> in general.</p>
<h2 id="next-level-plugging-using-plugrouter">Next-level <code>Plug</code>ging using <code>Plug.Router</code></h2>
<p>Now that we understand how <code>Plug.Conn</code> works and how plugs can change the
connection by invoking functions defined in the <code>Plug.Conn</code> module, let's look
at a more advanced feature of plugs - turning a plug into a router.</p>
<p>In our first example, we saw the simplest of the Elixir web apps - a simple
plug that takes the request and returns a simple response with a text body and
an HTTP 200. But, what if we want to handle different routes or HTTP methods?
What if we want to gracefully handle any request to an unknown route with an
HTTP 404?</p>
<p>One nicety that <code>Plug</code> comes with is a module called <code>Plug.Router</code>, you can see
its documentation <a href="https://hexdocs.pm/plug/Plug.Router.html#content">here</a>.
The router module contains a DSL that allows us to define a routing algorithm
for incoming requests and writing handlers (powered by Plug) for the routes.
If you are coming from Ruby land, while <code>Plug</code> is basically Rack, this DSL is
Sinatra.rb.</p>
<p>Let's create a tiny router using <code>Plug.Router</code>, add some plugs to its pipeline
and some endpoints.</p>
<p><strong>Quick aside: What is a pipeline?</strong></p>
<p>Although it has the same name as the pipeline operator (<code>|&gt;</code>), a pipeline in
Plug's context is a list of plugs executed one after another. That's really it.
The last plug in that pipeline is usually an endpoint that will set the body and
the status of the response and return the response to the client.</p>
<p>Now, back to our router:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#458;font-weight:bold">MyRouter</span> do
  use <span style="color:#458;font-weight:bold">Plug.Router</span>

  plug <span style="color:#b84">:match</span>
  plug <span style="color:#b84">:dispatch</span>

  get <span style="color:#b84">&#34;</span><span style="color:#b84">/hello</span><span style="color:#b84">&#34;</span> do
    send_resp(conn, <span style="color:#099">200</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">world</span><span style="color:#b84">&#34;</span>)
  end

  match _ do
    send_resp(conn, <span style="color:#099">404</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">oops</span><span style="color:#b84">&#34;</span>)
  end
end</code></pre></div>
<p><!-- raw HTML omitted -->Code blatantly copied from
<a href="https://hexdocs.pm/plug/Plug.Router.html"><code>Plug.Router</code>'s docs</a>.
<!-- raw HTML omitted --></p>
<p>The first thing that you will notice here is that all routers are modules as
well. By <code>use</code>ing the <code>Plug.Router</code> module, we include some functions that make
our lives easier, like <code>get</code> or <code>match</code>.</p>
<p>If you notice at the top of the module we have two lines:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">plug <span style="color:#b84">:match</span>
plug <span style="color:#b84">:dispatch</span></code></pre></div>
<p>This is the router's <em>pipeline</em>. All of the requests coming to the router will
pass through these two plugs: <code>match</code> and <code>dispatch</code>. The first one does the
matching of the route that we define (e.g. <code>/hello</code>), while the other one will
invoke the function defined for a particular route. This means that if we would
like to add other plugs, most of the time they will be invoked between the two
mandatory ones (<code>match</code> and <code>dispatch</code>).</p>
<p>Let's mount our router on a Cowboy server and see it's behaviour:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">iex<span style="font-weight:bold">(</span>29<span style="font-weight:bold">)</span>&gt; Plug.Cowboy.http MyRouter, <span style="font-weight:bold">[</span><span style="font-weight:bold">]</span>, port: <span style="color:#099">3000</span>
<span style="font-weight:bold">{</span>:ok, <span style="color:#998;font-style:italic">#PID&lt;0.1500.0&gt;}</span></code></pre></div>
<p>When we hit <code>127.0.0.1:3000/hello</code>, we will get the following:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">› curl -v 127.0.0.1:3000/hello
*   Trying 127.0.0.1...
* TCP_NODELAY <span style="color:#999">set</span>
* Connected to 127.0.0.1 <span style="font-weight:bold">(</span>127.0.0.1<span style="font-weight:bold">)</span> port <span style="color:#099">3000</span> <span style="font-weight:bold">(</span><span style="color:#998;font-style:italic">#0)</span>
&gt; GET /hello HTTP/1.1
&gt; Host: 127.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span style="color:#099">200</span> OK
&lt; cache-control: max-age<span style="font-weight:bold">=</span>0, private, must-revalidate
&lt; content-length: <span style="color:#099">5</span>
&lt; date: Thu, <span style="color:#099">27</span> Dec <span style="color:#099">2018</span> 22:50:47 GMT
&lt; server: Cowboy
&lt;
* Connection <span style="color:#998;font-style:italic">#0 to host 127.0.0.1 left intact</span>
world</code></pre></div>
<p>As you can see, we received <code>world</code> as the response body and an HTTP 200. But if
we hit any other URL, the router will match the other route:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">› curl -v 127.0.0.1:3000/foo
*   Trying 127.0.0.1...
* TCP_NODELAY <span style="color:#999">set</span>
* Connected to 127.0.0.1 <span style="font-weight:bold">(</span>127.0.0.1<span style="font-weight:bold">)</span> port <span style="color:#099">3000</span> <span style="font-weight:bold">(</span><span style="color:#998;font-style:italic">#0)</span>
&gt; GET /foo HTTP/1.1
&gt; Host: 127.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span style="color:#099">404</span> Not Found
&lt; cache-control: max-age<span style="font-weight:bold">=</span>0, private, must-revalidate
&lt; content-length: <span style="color:#099">4</span>
&lt; date: Thu, <span style="color:#099">27</span> Dec <span style="color:#099">2018</span> 22:51:56 GMT
&lt; server: Cowboy
&lt;
* Connection <span style="color:#998;font-style:italic">#0 to host 127.0.0.1 left intact</span>
oops</code></pre></div>
<p>As you can see, because the <code>/hello</code> route didn't match we defaulted to the
other route, also known as &ldquo;catch all&rdquo; route, which returned <code>oops</code> as the
response body and an HTTP 404 status.</p>
<p>If you would like to learn more about <code>Plug.Router</code> and its route matching
macros you can read more in
<a href="https://hexdocs.pm/plug/Plug.Router.html#module-routes">its documentation</a>. We
still need to cover some more distance with Plug.</p>
<h2 id="built-in-plugs">Built-in Plugs</h2>
<p>In the previous section, we mentioned the plugs <code>match</code> and <code>dispatch</code>, and plug
pipelines. We also mentioned that we can plug in other plugs in the pipeline
so we can inspect or change the <code>Plug.Conn</code> of each request.</p>
<p>What is very exciting here is that <code>Plug</code> also comes with already built-in plugs.
That means that there's a list of plugs that you can plug-in in any Plug-based
application:</p>
<ul>
<li><code>Plug.CSRFProtection</code></li>
<li><code>Plug.Head</code></li>
<li><code>Plug.Logger</code></li>
<li><code>Plug.MethodOverride</code></li>
<li><code>Plug.Parsers</code></li>
<li><code>Plug.RequestId</code></li>
<li><code>Plug.SSL</code></li>
<li><code>Plug.Session</code></li>
<li><code>Plug.Static</code></li>
</ul>
<p>Let's try to understand how a couple of them work and how we can plug them in
our <code>MyRouter</code> router module.</p>
<h3 id="plughead"><code>Plug.Head</code></h3>
<p>This is a rather simple plug. It's so simple, I will add
<a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/head.ex#L1">all of its code</a>
here:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#458;font-weight:bold">Plug.Head</span> do
  <span style="color:#008080">@behaviour</span> <span style="color:#458;font-weight:bold">Plug</span>

  alias <span style="color:#458;font-weight:bold">Plug.Conn</span>

  def init([]), <span style="color:#b84">do</span>: []

  def call(%<span style="color:#458;font-weight:bold">Conn</span>{<span style="color:#b84">method</span>: <span style="color:#b84">&#34;</span><span style="color:#b84">HEAD</span><span style="color:#b84">&#34;</span>} <span style="font-weight:bold">=</span> conn, []), <span style="color:#b84">do</span>: %{conn <span style="font-weight:bold">|</span> <span style="color:#b84">method</span>: <span style="color:#b84">&#34;</span><span style="color:#b84">GET</span><span style="color:#b84">&#34;</span>}
  def call(conn, []), <span style="color:#b84">do</span>: conn
end</code></pre></div>
<p>What this plug does is it turns any HTTP <code>HEAD</code> request into a <code>GET</code> request.
That's all. Its <code>call</code> function receives a <code>Plug.Conn</code>, matches only the ones
that have a <code>method: &quot;HEAD&quot;</code> and returns a new <code>Plug.Conn</code> with the <code>method</code>
changed to <code>&quot;GET&quot;</code>.</p>
<p>If you've been wondering what the <code>HEAD</code> method is for, this is from
<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">RFC 2616</a>:</p>
<blockquote>
<p>The HEAD method is identical to GET except that the server MUST NOT return a
message-body in the response. The metainformation contained in the HTTP headers
in response to a HEAD request SHOULD be identical to the information sent in
response to a GET request. This method can be used for obtaining
metainformation about the entity implied by the request without transferring
the entity-body itself. This method is often used for testing hypertext links
for validity, accessibility, and recent modification.</p>
</blockquote>
<p>Let's plug this plug in our <code>Plug.Router</code> (pun totally intended):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">defmodule <span style="color:#458;font-weight:bold">MyRouter</span> do
  use <span style="color:#458;font-weight:bold">Plug.Router</span>

  plug <span style="color:#458;font-weight:bold">Plug.Head</span>
  plug <span style="color:#b84">:match</span>
  plug <span style="color:#b84">:dispatch</span>

  get <span style="color:#b84">&#34;</span><span style="color:#b84">/hello</span><span style="color:#b84">&#34;</span> do
    send_resp(conn, <span style="color:#099">200</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">world</span><span style="color:#b84">&#34;</span>)
  end

  match _ do
    send_resp(conn, <span style="color:#099">404</span>, <span style="color:#b84">&#34;</span><span style="color:#b84">oops</span><span style="color:#b84">&#34;</span>)
  end
end</code></pre></div>
<p>Once we <code>cURL</code> the routes we would get the following behaviour:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">› curl -I 127.0.0.1:3000/hello
HTTP/1.1 <span style="color:#099">200</span> OK
cache-control: max-age<span style="font-weight:bold">=</span>0, private, must-revalidate
content-length: <span style="color:#099">5</span>
date: Thu, <span style="color:#099">27</span> Dec <span style="color:#099">2018</span> 23:25:13 GMT
server: Cowboy

› curl -I 127.0.0.1:3000/foo
HTTP/1.1 <span style="color:#099">404</span> Not Found
cache-control: max-age<span style="font-weight:bold">=</span>0, private, must-revalidate
content-length: <span style="color:#099">4</span>
date: Thu, <span style="color:#099">27</span> Dec <span style="color:#099">2018</span> 23:25:17 GMT
server: Cowboy</code></pre></div>
<p>As you can see, although we didn't explicitly match the <code>HEAD</code> routes using the
<code>head</code> macro, the <code>Plug.Head</code> plug remapped the <code>HEAD</code> requests to <code>GET</code> and
our handlers still kept on working as expected (the first one returned an HTTP
200, and the second one an HTTP 404).</p>
<h3 id="pluglogger"><code>Plug.Logger</code></h3>
<p>This one is a bit more complicated so we cannot inline
<a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/logger.ex#L1">all of its code</a>
in this article. Basically, if we would plug this plug in our router, it will
log all of the incoming requests and response statuses, like so:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">  GET /index.html
  Sent 200 in 572ms</code></pre></div>
<p>This plug uses Elixir's <code>Logger</code> (<a href="https://hexdocs.pm/logger/Logger.html">docs</a>)
under the hood, which supports four different logging levels:</p>
<ul>
<li><code>:debug</code> - for debug-related messages</li>
<li><code>:info</code> - for information of any kind (default level)</li>
<li><code>:warn</code> - for warnings</li>
<li><code>:error</code> - for errors</li>
</ul>
<p>If we would look at the source of its <code>call/2</code> function, we would notice two
logical units. The first one is:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">def call(conn, level) do
  <span style="color:#458;font-weight:bold">Logger</span><span style="font-weight:bold">.</span>log(level, fn <span style="font-weight:bold">-&gt;</span>
    [conn<span style="font-weight:bold">.</span>method, <span style="color:#b84">?</span><span style="color:#b84">\s</span>, conn<span style="font-weight:bold">.</span>request_path]
  end)

  <span style="color:#998;font-style:italic"># Snipped...</span>
end</code></pre></div>
<p>This one will take Elixir's <code>Logger</code> and using the logging <code>level</code> will log the
information to the backend (by default it's <code>console</code>). The information that is
logged is the method of the request (e.g. <code>GET</code>, <code>POST</code>, etc) and the request
path (e.g. <code>/foo/bar</code>). This results in the first line of the log:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">GET /index.html</code></pre></div>
<p>The second logical unit is a bit more elaborate:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">def call(conn, level) do
  <span style="color:#998;font-style:italic"># Snipped...</span>

  start <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">System</span><span style="font-weight:bold">.</span>monotonic_time()

  <span style="color:#458;font-weight:bold">Conn</span><span style="font-weight:bold">.</span>register_before_send(conn, fn conn <span style="font-weight:bold">-&gt;</span>
    <span style="color:#458;font-weight:bold">Logger</span><span style="font-weight:bold">.</span>log(level, fn <span style="font-weight:bold">-&gt;</span>
      stop <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">System</span><span style="font-weight:bold">.</span>monotonic_time()
      diff <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">System</span><span style="font-weight:bold">.</span>convert_time_unit(stop <span style="font-weight:bold">-</span> start, <span style="color:#b84">:native</span>, <span style="color:#b84">:microsecond</span>)
      status <span style="font-weight:bold">=</span> <span style="color:#458;font-weight:bold">Integer</span><span style="font-weight:bold">.</span>to_string(conn<span style="font-weight:bold">.</span>status)

      [connection_type(conn), <span style="color:#b84">?</span><span style="color:#b84">\s</span>, status, <span style="color:#b84">&#34;</span><span style="color:#b84"> in </span><span style="color:#b84">&#34;</span>, formatted_diff(diff)]
    end)

    conn
  end)
end</code></pre></div>
<p>In short: this section records the time between the <code>start</code> and the <code>stop</code>
(end) of the request and prints out the <code>diff</code>erence between the two (or in
other words - the amount of time the response took). Also, it prints out the
HTTP status of the response.</p>
<p>To do this it uses <code>Plug.Conn.register_before_send/2</code>
(<a href="https://hexdocs.pm/plug/Plug.Conn.html#register_before_send/2">docs</a>) which
is a utility function that registers callbacks to be invoked before the
response is sent. This means that the function which will calculate the <code>diff</code>
and log it to the <code>Logger</code> with the response status will be invoked by
<code>Plug.Conn</code> right before the response is sent to the client.</p>
<h2 id="wrapping-up-with-plug">Wrapping up with Plug</h2>
<p>You actually made it this far - I applaud you. I hope that this was a nice
journey for you in Plug and it's related modules/functions and that you learned
something new.</p>
<p>We looked at quite a bit of details in and around <code>Plug</code>. For some of the
modules that we spoke about we barely scratched the surface. For example,
<code>Plug.Conn</code> has quite a bit of more useful functions. Or <code>Plug.Router</code> has more
functions in its DSL where you can write more elaborate and thoughtful APIs or
web apps. In line with this, <code>Plug</code> also offers more built-in plugs. It even
has a plug which can serve static files with ease, and plugging it in your
Plug-based apps is a breeze.</p>
<p>But, aside from all the things that we skipped in this article, I hope that you
understood how powerful the Plug model is and how much power it provides us
with such simplicity and unobtrusiveness.</p>
<p>In future posts, we will look at even more details about other plugs in <code>Plug</code>,
but until then please shoot me a comment or a message if you've found this
article helpful (or not).</p>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/cowboy">cowboy</a></li>
							
							<li><a href="/tags/router">router</a></li>
							
							<li><a href="/tags/endpoint">endpoint</a></li>
							
						</ul>
					
				
			</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'eftimov';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the </a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2021  Copyright © Ilija Eftimov |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-11264459-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
