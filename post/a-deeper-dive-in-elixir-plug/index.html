<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>A deeper dive in Elixir&#39;s Plug - Ilija Eftimov</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Ilija Eftimov" />
  <meta name="description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects&amp;rsquo; documentation. One thing that stood out for me recently is the first sentence of Phoenix&amp;rsquo;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug." />

  <meta name="keywords" content="Software, Programming, Computer Science, Products" />






<meta name="generator" content="Hugo 0.55.6" />


<link rel="canonical" href="https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.ec807d8b802a40889537c26e014f733206312ea440d42e1f0dabed80918de1ac.css" integrity="sha256-7IB9i4AqQIiVN8JuAU9zMgYxLqRA1C4fDavtgJGN4aw=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/overrides.css">

<link rel="stylesheet" href="/css/subscribe.css">


<meta property="og:title" content="A deeper dive in Elixir&#39;s Plug" />
<meta property="og:description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo; documentation. One thing that stood out for me recently is the first sentence of Phoenix&rsquo;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/" />

<meta property="og:image" content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png" />
<meta property="article:published_time" content="2018-12-31T00:00:00&#43;00:00"/>


<meta itemprop="name" content="A deeper dive in Elixir&#39;s Plug">
<meta itemprop="description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo; documentation. One thing that stood out for me recently is the first sentence of Phoenix&rsquo;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug.">



<meta itemprop="wordCount" content="3496">

  <meta itemprop="image" content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png">



<meta itemprop="keywords" content="cowboy,router,endpoint," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png"/>

<meta name="twitter:title" content="A deeper dive in Elixir&#39;s Plug"/>
<meta name="twitter:description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo; documentation. One thing that stood out for me recently is the first sentence of Phoenix&rsquo;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-11264459-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script type='text/javascript'>
window.Tooltip||function(t,e){var o={
url:"https://cdn.tooltip.io/static/player.js",
key:"189f262e-7c0e-4a30-b1dd-1e425f03fe5e",
async:true
};
window.Tooltip={cs:[],_apiKey:o.key};for(
var r=["identify","goal","updateUserData","start","stop","refresh","show","hide","on"],
i={},n=0;n<r.length;n++){var a=r[n];i[a]=function(t){return function(){var e=Array.prototype.slice.call(arguments);
window.Tooltip.cs.push({method:t,args:e})}}(a)}window.Tooltip.API=i;var n=t.createElement(e),s=t.getElementsByTagName(e)[0];
n.type="text/javascript",n.async=o.async,s.parentNode.insertBefore(n,s),n.src=o.url}(document,"script");
</script>



</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Ilija Eftimov</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ieftimov.com/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ieftimov.com/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ieftimov.com/about/">About</a>
          
        
      </li>
    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Ilija Eftimov
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ieftimov.com/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ieftimov.com/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ieftimov.com/about/">About</a>
          

        

      </li>
    
    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">A deeper dive in Elixir&#39;s Plug</h1>
      
      <div class="post-meta">
        <time datetime="2018-12-31" class="post-time">
          31-12-2018
        </time>
        <div class="post-category">
            <a href="https://ieftimov.com/categories/elixir/"> elixir </a>
            <a href="https://ieftimov.com/categories/plug/"> plug </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    

    
    <div class="post-content">
      

<p>Being new to Elixir and Phoenix, I spend quite some time in the projects&rsquo;
documentation. One thing that stood out for me recently is the first sentence of
<a href="https://hexdocs.pm/phoenix/plug.html#content">Phoenix&rsquo;s Plug documentation</a>:</p>

<blockquote>
<p>Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.</p>
</blockquote>

<p>So naturally, I felt compelled to take a deeper dive into Plug and understand it
better. I hope the following article will help you out in understanding Plug.</p>

<h2 id="what-s-plug">What&rsquo;s Plug?</h2>

<p>As <a href="https://github.com/elixir-plug/plug#plug">the readme</a> puts it, Plug is:
1. A specification for composable modules between web applications
2. Connection adapters for different web servers in the Erlang VM</p>

<p>But, what does this mean? Well, it basically states that Plug 1) <em>defines
the way</em> you build web apps in Elixir and 2) it provides you with tools to write
apps that are understood by web servers.</p>

<p>Let&rsquo;s take a dive and see what that means.</p>

<h2 id="web-servers-yeehaw">Web servers, yeehaw!</h2>

<p>One of the most popular HTTP servers for Erlang is
<a href="https://github.com/ninenines/cowboy">Cowboy</a>. It is a small, fast and modern
HTTP server for Erlang/OTP. If you were to write any web application in Elixir
it will run on Cowboy, because the Elixir core team has built a Plug adapter for
Cowboy, conveniently named
<a href="https://github.com/elixir-plug/plug_cowboy">plug_cowboy</a>.</p>

<p>This means that if you include this package in your package, you will get the
Elixir interface to talk to the Cowboy web server (and vice-versa). It means
that you can send and receive requests and other stuff that web servers can do.</p>

<p>So why is this important?</p>

<p>Well, to understand Plug we need to understand how it works. Basically, using
the adapter (<code>plug_cowboy</code>), Plug can accept the connection request that comes
in Cowboy and turn it into a meaningful struct, also known as <code>Plug.Conn</code>.</p>

<p>This means that Plug uses <code>plug_cowboy</code> to understand Cowboy&rsquo;s nitty-gritty
details. By doing this Plug allows us to easily build handler functions and
modules that can receive, handle and respond to requests.</p>

<p>Of course, the idea behind Plug is not to work only with Cowboy. If you look
at <a href="https://stackoverflow.com/a/26323883/6015550">this SO answer</a> from José
Valim (Elixir&rsquo;s BDFL) he clearly states &ldquo;Plug is meant to be a generic adapter
for different web servers. Currently we support just Cowboy but there is work to
support others.&rdquo;</p>

<h2 id="enter-plug">Enter Plug</h2>

<p>Okay, now that we&rsquo;ve scratched the surface of Cowboy and it&rsquo;s Plug adapter, let&rsquo;s
look at Plug itself.</p>

<p>If you look at
<a href="https://github.com/elixir-plug/plug/blob/master/README.md">Plug&rsquo;s README</a>, you
will notice that there are two flavours of plugs, a function or a module.</p>

<p>The most minimal plug can be a function, it just takes a <code>Plug.Conn</code> struct
(that we will explore more later) and some options. The function will
manipulate the struct and return it at the end. Here&rsquo;s the example from the
<code>README</code>:</p>

<p><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">def</span> <span class="n">hello_world_plug</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_opts</span><span class="p">)</span> <span class="n">do</span>
  <span class="n">conn</span>
  <span class="o">|&gt;</span> <span class="n">put_resp_content_type</span><span class="p">(</span><span class="s2">&#34;text/plain&#34;</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="n">send_resp</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s2">&#34;Hello world&#34;</span><span class="p">)</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>
<small>Code blatantly copied from
<a href="https://github.com/elixir-plug/plug/blob/master/README.md">Plug&rsquo;s docs</a>.
</small></p>

<p>If you look at the function, it&rsquo;s quite simple. It receives the connection
struct, puts its content type to <code>text/plain</code> and returns a response with an HTTP
200 status and <code>&quot;Hello world&quot;</code> as the body.</p>

<p>The second flavour is the module Plug. This means that instead of just having a
function that will be invoked as part of the request lifecycle, you can define a
module that takes a connection and initialized options and returns the
connection:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">defmodule</span> <span class="nc">MyPlug</span> <span class="n">do</span>
  <span class="n">def</span> <span class="n">init</span><span class="p">([]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">false</span>
  <span class="n">def</span> <span class="n">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_opts</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">conn</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p><small>Code blatantly copied from
<a href="https://github.com/elixir-plug/plug/blob/master/README.md">Plug&rsquo;s docs</a>.
</small></p>

<p>Having this in mind, let&rsquo;s take a step further and see how we can use Plug in a
tiny application.</p>








<div id="mc_embed_signup">
<form action="https://pm.us20.list-manage.com/subscribe/post?u=d9a6471309140dcd520d05346&amp;id=2aac491644" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
        <div class="heading">Join The Newsletter</div>
        <p>
            I write about backend technologies, programming and cloud architectures. Join hundreds of other developers that get my content, twice a month. Unsubscribe whenever. Never any spam, ads, or affiliate links.
        </p>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
        <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">

      
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d9a6471309140dcd520d05346_2aac491644" tabindex="-1" value=""></div>

    <p>You can also subscribe <a href="https://ieftimov.com/index.xml">via RSS</a>.</p>
    </div>
</form>
</div>



<h2 id="plugging-a-plug-as-an-endpoint">Plugging a plug as an endpoint</h2>

<p>So far, the most important things we covered was what&rsquo;s Plug and what is it used
for on a high level. We also took a look at two different types of plugs.</p>

<p>Now, let&rsquo;s see how we can mount a Plug on a Cowboy server and essentially use it
as an endpoint:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">defmodule</span> <span class="nc">PlugTest</span> <span class="n">do</span>
  <span class="n">import</span> <span class="nc">Plug.Conn</span>

  <span class="n">def</span> <span class="n">init</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="n">do</span>
    <span class="c1"># initialize options</span>

    <span class="n">options</span>
  <span class="n">end</span>

  <span class="n">def</span> <span class="n">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_opts</span><span class="p">)</span> <span class="n">do</span>
    <span class="n">conn</span>
    <span class="o">|&gt;</span> <span class="n">put_resp_content_type</span><span class="p">(</span><span class="s2">&#34;text/plain&#34;</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">send_resp</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s2">&#34;Hello world&#34;</span><span class="p">)</span>
  <span class="n">end</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p>What this module will do is, when mounted on a Cowboy server, will set the
<code>Content-Type</code> header to <code>text/plain</code> and will return an HTTP 200 with a body of
<code>Hello world</code>.</p>

<p>Let&rsquo;s fire up IEx and test this ourselves:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">› iex -S mix
Erlang/OTP 21 [erts-10.2] [source] [64-bit] [smp4] [ds4:10] [async-threads:1] [hipe] [dtrace]

Interactive Elixir (1.7.4) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; {:ok, _ } = Plug.Cowboy.http PlugTest, [], port: 3000
{:ok, #PID&lt;0.202.0&gt;}</code></pre></td></tr></table>
</div>
</div>

<p>This starts the Cowboy server as a BEAM process, listening on port 3000. If we
<code>cURL</code> it we&rsquo;ll see the response body and it&rsquo;s headers:</p>

<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">› curl -v 127.0.0.1:3000
&gt; GET / HTTP/1.1
&gt; Host: 127.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; cache-control: max-age=0, private, must-revalidate
&lt; content-length: 11
&lt; content-type: text/plain; charset=utf-8
&lt; date: Tue, 25 Dec 2018 2254 GMT
&lt; server: Cowboy
&lt;
* Connection #0 to host 127.0.0.1 left intact
Hello world</code></pre></div>

<p>You see, the <code>Content-Type</code> of the response is set to <code>text/plain</code> and the body
is <code>Hello world</code>. In this example, the plug is essentially an endpoint by
itself, serving plain text to our <code>cURL</code> command (or to a browser). As you might
be able to imagine at this point, you can plug in much more elaborate Plugs to a
Cowboy server and it will serve them just fine.</p>

<p>To shut down the endpoint all you need to do is:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">iex(2)&gt; Plug.Cowboy.shutdown PlugTest.HTTP
:ok</code></pre></td></tr></table>
</div>
</div>

<p>What we are witnessing here is probably the tiniest web application one can
write in Elixir. It&rsquo;s an app that takes a request and returns a valid response
over HTTP with a status and a body.</p>

<p>So, how does this actually work? How do we accept the request and build a
response here?</p>

<h2 id="diving-into-the-plug-conn">Diving into the <code>Plug.Conn</code></h2>

<p>To understand this, we need to zoom in the <code>call/2</code> function of our module
<code>PlugTest</code>. I will also throw in an <code>IO.inspect</code> right at the end of the
function so we can inspect what this struct is:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">def</span> <span class="n">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_opts</span><span class="p">)</span> <span class="n">do</span>
  <span class="n">conn</span>
  <span class="o">|&gt;</span> <span class="n">put_resp_content_type</span><span class="p">(</span><span class="s2">&#34;text/plain&#34;</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="n">send_resp</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s2">&#34;Hello world&#34;</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p>If you start the Cowboy instance again via your IEx session and you hit
<code>127.0.0.1:3000</code> via <code>cURL</code> (or a browser), you should see something like this
in your IEx session:</p>

<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">%Plug.Conn{
  adapter: {Plug.Cowboy.Conn, :...},
  assigns: %{},
  before_send: [],
  body_params: %Plug.Conn.Unfetched{aspect: :body_params},
  cookies: %Plug.Conn.Unfetched{aspect: :cookies},
  halted: false,
  host: &#34;127.0.0.1&#34;,
  method: &#34;GET&#34;,
  owner: #PID&lt;0.316.0&gt;,
  params: %Plug.Conn.Unfetched{aspect: :params},
  path_info: [],
  path_params: %{},
  port: 3000,
  private: %{},
  query_params: %Plug.Conn.Unfetched{aspect: :query_params},
  query_string: &#34;&#34;,
  remote_ip: {127, 0, 0, 1},
  req_cookies: %Plug.Conn.Unfetched{aspect: :cookies},
  req_headers: [
    {&#34;accept&#34;,
     &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#34;},
    {&#34;accept-encoding&#34;, &#34;gzip, deflate, br&#34;},
    {&#34;accept-language&#34;, &#34;en-US,en;q=0.9&#34;},
    {&#34;connection&#34;, &#34;keep-alive&#34;},
    {&#34;host&#34;, &#34;127.0.0.1:3000&#34;},
    {&#34;upgrade-insecure-requests&#34;, &#34;1&#34;},
    {&#34;user-agent&#34;,
     &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#34;}
  ],
  request_path: &#34;/&#34;,
  resp_body: nil,
  resp_cookies: %{},
  resp_headers: [
    {&#34;cache-control&#34;, &#34;max-age=0, private, must-revalidate&#34;},
    {&#34;content-type&#34;, &#34;text/plain; charset=utf-8&#34;}
  ],
  scheme: :http,
  script_name: [],
  secret_key_base: nil,
  state: :sent,
  status: 200
}</code></pre></div>

<p>What are we actually looking at? Well, it&rsquo;s actually the Plug representation
of a connection. This is a direct interface to the underlying web server and
the request that the Cowboy server has received.</p>

<p>Some of the attributes of the struct are pretty self-explanatory, like <code>scheme</code>,
<code>method</code>, <code>host</code>, <code>request_path</code>, etc. If you would like to go into detail what
each of these fields is, I suggest taking a look at <code>Plug.Conn</code>&rsquo;s
<a href="https://hexdocs.pm/plug/Plug.Conn.html#module-request-fields">documentation</a>.</p>

<p>But, to understand better the <code>Plug.Conn</code> struct, we need to understand the
connection lifecycle of each connection struct.</p>








<div id="mc_embed_signup">
<form action="https://pm.us20.list-manage.com/subscribe/post?u=d9a6471309140dcd520d05346&amp;id=2aac491644" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
        <div class="heading">Join The Newsletter</div>
        <p>
            I write about backend technologies, programming and cloud architectures. Join hundreds of other developers that get my content, twice a month. Unsubscribe whenever. Never any spam, ads, or affiliate links.
        </p>
	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
        <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">

      
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d9a6471309140dcd520d05346_2aac491644" tabindex="-1" value=""></div>

    <p>You can also subscribe <a href="https://ieftimov.com/index.xml">via RSS</a>.</p>
    </div>
</form>
</div>



<h3 id="connection-lifecycle">Connection lifecycle</h3>

<p>Just like any map in Elixir <code>Plug.Conn</code> allows us to pattern match on it. Let&rsquo;s
modify the little endpoint we created before and try to add some extra
<code>IO.inspect</code> function calls:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">defmodule</span> <span class="nc">PlugTest</span> <span class="n">do</span>
  <span class="n">import</span> <span class="nc">Plug.Conn</span>

  <span class="n">def</span> <span class="n">init</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="n">do</span>
    <span class="c1"># initialize options</span>

    <span class="n">options</span>
  <span class="n">end</span>

  <span class="n">def</span> <span class="n">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_opts</span><span class="p">)</span> <span class="n">do</span>
    <span class="n">conn</span>
    <span class="o">|&gt;</span> <span class="n">inspect_state</span>
    <span class="o">|&gt;</span> <span class="n">put_resp_content_type</span><span class="p">(</span><span class="s2">&#34;text/plain&#34;</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">inspect_state</span>
    <span class="o">|&gt;</span> <span class="n">put_private</span><span class="p">(</span><span class="ss">:foo</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">inspect_state</span>
    <span class="o">|&gt;</span> <span class="n">resp</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s2">&#34;Hello world&#34;</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">inspect_state</span>
    <span class="o">|&gt;</span> <span class="n">send_resp</span><span class="p">()</span>
    <span class="o">|&gt;</span> <span class="n">inspect_state</span>
  <span class="n">end</span>

  <span class="n">defp</span> <span class="n">inspect_state</span><span class="p">(</span><span class="n">conn</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">state</span><span class="p">:</span> <span class="n">state</span><span class="p">})</span> <span class="n">do</span>
    <span class="nc">IO</span><span class="o">.</span><span class="n">inspect</span> <span class="n">state</span>
    <span class="n">conn</span>
  <span class="n">end</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p>Because <code>Plug.Conn</code> allows pattern matching, we can get the <code>state</code> of the
connection, print it out and return the connection itself so the pipeline in
the <code>call/2</code> function would continue working as expected.</p>

<p>Let&rsquo;s mount this plug on a Cowboy instance and hit it with a simple <code>cURL</code>
request:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">iex<span class="o">(</span><span class="m">6</span><span class="o">)</span>&gt; Plug.Cowboy.http PlugTest, <span class="o">[]</span>, port: <span class="m">3000</span>
<span class="o">{</span>:ok, <span class="c1">#PID&lt;0.453.0&gt;}</span>

<span class="c1"># curl 127.0.0.1:3000</span>

iex<span class="o">(</span><span class="m">21</span><span class="o">)</span>&gt; :unset
:unset
:unset
:set
:sent</code></pre></td></tr></table>
</div>
</div>

<p>You see, when the connection enters the plug it&rsquo;s state changes from <code>:unset</code> to
<code>:set</code> to finally <code>:sent</code>. This means that once the plug is invoked the state of
the connection is <code>:unset</code>. Then we do multiple actions, or in other words, we
invoke multiple functions on the <code>Plug.Conn</code> which add more information to the
connection. Obviously, since all variables in Elixir are immutable, each of
these function returns a new <code>Plug.Conn</code> instance, instead of mutating the
existing one.</p>

<p>Once the body and the status of the connection are set, then the state changes
to <code>:set</code>. Up until that moment, the state is fixed as <code>:unset</code>. Once we send
the response back to the client the state is changed to <code>:sent</code>.</p>

<p>What we need to understand here is that whether we have one or more plugs in a
pipeline, they will all receive a <code>Plug.Conn</code>, call functions on it, whether
to extract or add data to it and then the connection will be passed on to the
next plug. Eventually, in the pipeline, there will be a plug (in the form of an
endpoint or a Phoenix controller) that will set the body and the response status
and send the response back to the client.</p>

<p>There are a bit more details to this, but this is just enough to wrap our minds
around <code>Plug</code> and <code>Plug.Conn</code> in general.</p>

<h2 id="next-level-plug-ging-using-plug-router">Next-level <code>Plug</code>ging using <code>Plug.Router</code></h2>

<p>Now that we understand how <code>Plug.Conn</code> works and how plugs can change the
connection by invoking functions defined in the <code>Plug.Conn</code> module, let&rsquo;s look
at a more advanced feature of plugs - turning a plug into a router.</p>

<p>In our first example, we saw the simplest of the Elixir web apps - a simple
plug that takes the request and returns a simple response with a text body and
an HTTP 200. But, what if we want to handle different routes or HTTP methods?
What if we want to gracefully handle any request to an unknown route with an
HTTP 404?</p>

<p>One nicety that <code>Plug</code> comes with is a module called <code>Plug.Router</code>, you can see
its documentation <a href="https://hexdocs.pm/plug/Plug.Router.html#content">here</a>.
The router module contains a DSL that allows us to define a routing algorithm
for incoming requests and writing handlers (powered by Plug) for the routes.
If you are coming from Ruby land, while <code>Plug</code> is basically Rack, this DSL is
Sinatra.rb.</p>

<p>Let&rsquo;s create a tiny router using <code>Plug.Router</code>, add some plugs to its pipeline
and some endpoints.</p>

<p><strong>Quick aside: What is a pipeline?</strong></p>

<p>Although it has the same name as the pipeline operator (<code>|&gt;</code>), a pipeline in
Plug&rsquo;s context is a list of plugs executed one after another. That&rsquo;s really it.
The last plug in that pipeline is usually an endpoint that will set the body and
the status of the response and return the response to the client.</p>

<p>Now, back to our router:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">defmodule</span> <span class="nc">MyRouter</span> <span class="n">do</span>
  <span class="n">use</span> <span class="nc">Plug.Router</span>

  <span class="n">plug</span> <span class="ss">:match</span>
  <span class="n">plug</span> <span class="ss">:dispatch</span>

  <span class="n">get</span> <span class="s2">&#34;/hello&#34;</span> <span class="n">do</span>
    <span class="n">send_resp</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="s2">&#34;world&#34;</span><span class="p">)</span>
  <span class="n">end</span>

  <span class="n">match</span> <span class="n">_</span> <span class="n">do</span>
    <span class="n">send_resp</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="mi">404</span><span class="p">,</span> <span class="s2">&#34;oops&#34;</span><span class="p">)</span>
  <span class="n">end</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p><small>Code blatantly copied from
<a href="https://hexdocs.pm/plug/Plug.Router.html"><code>Plug.Router</code>&rsquo;s docs</a>.
</small></p>

<p>The first thing that you will notice here is that all routers are modules as
well. By <code>use</code>ing the <code>Plug.Router</code> module, we include some functions that make
our lives easier, like <code>get</code> or <code>match</code>.</p>

<p>If you notice at the top of the module we have two lines:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">plug</span> <span class="ss">:match</span>
<span class="n">plug</span> <span class="ss">:dispatch</span></code></pre></td></tr></table>
</div>
</div>

<p>This is the router&rsquo;s <em>pipeline</em>. All of the requests coming to the router will
pass through these two plugs: <code>match</code> and <code>dispatch</code>. The first one does the
matching of the route that we define (e.g. <code>/hello</code>), while the other one will
invoke the function defined for a particular route. This means that if we would
like to add other plugs, most of the time they will be invoked between the two
mandatory ones (<code>match</code> and <code>dispatch</code>).</p>

<p>Let&rsquo;s mount our router on a Cowboy server and see it&rsquo;s behaviour:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">iex<span class="o">(</span><span class="m">29</span><span class="o">)</span>&gt; Plug.Cowboy.http MyRouter, <span class="o">[]</span>, port: <span class="m">3000</span>
<span class="o">{</span>:ok, <span class="c1">#PID&lt;0.1500.0&gt;}</span></code></pre></td></tr></table>
</div>
</div>

<p>When we hit <code>127.0.0.1:3000/hello</code>, we will get the following:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">› curl -v <span class="m">127</span>.0.0.1:3000/hello
*   Trying <span class="m">127</span>.0.0.1...
* TCP_NODELAY <span class="nb">set</span>
* Connected to <span class="m">127</span>.0.0.1 <span class="o">(</span><span class="m">127</span>.0.0.1<span class="o">)</span> port <span class="m">3000</span> <span class="o">(</span><span class="c1">#0)</span>
&gt; GET /hello HTTP/1.1
&gt; Host: <span class="m">127</span>.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span class="m">200</span> OK
&lt; cache-control: max-age<span class="o">=</span><span class="m">0</span>, private, must-revalidate
&lt; content-length: <span class="m">5</span>
&lt; date: Thu, <span class="m">27</span> Dec <span class="m">2018</span> <span class="m">2247</span> GMT
&lt; server: Cowboy
&lt;
* Connection <span class="c1">#0 to host 127.0.0.1 left intact</span>
world</code></pre></td></tr></table>
</div>
</div>

<p>As you can see, we received <code>world</code> as the response body and an HTTP 200. But if
we hit any other URL, the router will match the other route:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">› curl -v <span class="m">127</span>.0.0.1:3000/foo
*   Trying <span class="m">127</span>.0.0.1...
* TCP_NODELAY <span class="nb">set</span>
* Connected to <span class="m">127</span>.0.0.1 <span class="o">(</span><span class="m">127</span>.0.0.1<span class="o">)</span> port <span class="m">3000</span> <span class="o">(</span><span class="c1">#0)</span>
&gt; GET /foo HTTP/1.1
&gt; Host: <span class="m">127</span>.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span class="m">404</span> Not Found
&lt; cache-control: max-age<span class="o">=</span><span class="m">0</span>, private, must-revalidate
&lt; content-length: <span class="m">4</span>
&lt; date: Thu, <span class="m">27</span> Dec <span class="m">2018</span> <span class="m">2256</span> GMT
&lt; server: Cowboy
&lt;
* Connection <span class="c1">#0 to host 127.0.0.1 left intact</span>
oops</code></pre></td></tr></table>
</div>
</div>

<p>As you can see, because the <code>/hello</code> route didn&rsquo;t match we defaulted to the
other route, also known as &ldquo;catch all&rdquo; route, which returned <code>oops</code> as the
response body and an HTTP 404 status.</p>

<p>If you would like to learn more about <code>Plug.Router</code> and its route matching
macros you can read more in
<a href="https://hexdocs.pm/plug/Plug.Router.html#module-routes">its documentation</a>. We
still need to cover some more distance with Plug.</p>

<h2 id="built-in-plugs">Built-in Plugs</h2>

<p>In the previous section, we mentioned the plugs <code>match</code> and <code>dispatch</code>, and plug
pipelines. We also mentioned that we can plug in other plugs in the pipeline
so we can inspect or change the <code>Plug.Conn</code> of each request.</p>

<p>What is very exciting here is that <code>Plug</code> also comes with already built-in plugs.
That means that there&rsquo;s a list of plugs that you can plug-in in any Plug-based
application:</p>

<ul>
<li><code>Plug.CSRFProtection</code></li>
<li><code>Plug.Head</code></li>
<li><code>Plug.Logger</code></li>
<li><code>Plug.MethodOverride</code></li>
<li><code>Plug.Parsers</code></li>
<li><code>Plug.RequestId</code></li>
<li><code>Plug.SSL</code></li>
<li><code>Plug.Session</code></li>
<li><code>Plug.Static</code></li>
</ul>

<p>Let&rsquo;s try to understand how a couple of them work and how we can plug them in
our <code>MyRouter</code> router module.</p>

<h3 id="plug-head"><code>Plug.Head</code></h3>

<p>This is a rather simple plug. It&rsquo;s so simple, I will add
<a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/head.ex#L1">all of its code</a>
here:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">defmodule</span> <span class="nc">Plug.Head</span> <span class="n">do</span>
  <span class="na">@behaviour</span> <span class="nc">Plug</span>

  <span class="n">alias</span> <span class="nc">Plug.Conn</span>

  <span class="n">def</span> <span class="n">init</span><span class="p">([]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[]</span>

  <span class="n">def</span> <span class="n">call</span><span class="p">(%</span><span class="nc">Conn</span><span class="p">{</span><span class="ss">method</span><span class="p">:</span> <span class="s2">&#34;HEAD&#34;</span><span class="p">}</span> <span class="o">=</span> <span class="n">conn</span><span class="p">,</span> <span class="p">[]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">%{</span><span class="n">conn</span> <span class="o">|</span> <span class="ss">method</span><span class="p">:</span> <span class="s2">&#34;GET&#34;</span><span class="p">}</span>
  <span class="n">def</span> <span class="n">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">[]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">conn</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p>What this plug does is it turns any HTTP <code>HEAD</code> request into a <code>GET</code> request.
That&rsquo;s all. Its <code>call</code> function receives a <code>Plug.Conn</code>, matches only the ones
that have a <code>method: &quot;HEAD&quot;</code> and returns a new <code>Plug.Conn</code> with the <code>method</code>
changed to <code>&quot;GET&quot;</code>.</p>

<p>If you&rsquo;ve been wondering what the <code>HEAD</code> method is for, this is from
<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">RFC 2616</a>:</p>

<blockquote>
<p>The HEAD method is identical to GET except that the server MUST NOT return a
message-body in the response. The metainformation contained in the HTTP headers
in response to a HEAD request SHOULD be identical to the information sent in
response to a GET request. This method can be used for obtaining
metainformation about the entity implied by the request without transferring
the entity-body itself. This method is often used for testing hypertext links
for validity, accessibility, and recent modification.</p>
</blockquote>

<p>Let&rsquo;s plug this plug in our <code>Plug.Router</code> (pun totally intended):</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">defmodule</span> <span class="nc">MyRouter</span> <span class="n">do</span>
  <span class="n">use</span> <span class="nc">Plug.Router</span>

  <span class="n">plug</span> <span class="nc">Plug.Head</span>
  <span class="n">plug</span> <span class="ss">:match</span>
  <span class="n">plug</span> <span class="ss">:dispatch</span>

  <span class="n">get</span> <span class="s2">&#34;/hello&#34;</span> <span class="n">do</span>
    <span class="n">send_resp</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="s2">&#34;world&#34;</span><span class="p">)</span>
  <span class="n">end</span>

  <span class="n">match</span> <span class="n">_</span> <span class="n">do</span>
    <span class="n">send_resp</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="mi">404</span><span class="p">,</span> <span class="s2">&#34;oops&#34;</span><span class="p">)</span>
  <span class="n">end</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p>Once we <code>cURL</code> the routes we would get the following behaviour:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">› curl -I <span class="m">127</span>.0.0.1:3000/hello
HTTP/1.1 <span class="m">200</span> OK
cache-control: max-age<span class="o">=</span><span class="m">0</span>, private, must-revalidate
content-length: <span class="m">5</span>
date: Thu, <span class="m">27</span> Dec <span class="m">2018</span> <span class="m">2313</span> GMT
server: Cowboy

› curl -I <span class="m">127</span>.0.0.1:3000/foo
HTTP/1.1 <span class="m">404</span> Not Found
cache-control: max-age<span class="o">=</span><span class="m">0</span>, private, must-revalidate
content-length: <span class="m">4</span>
date: Thu, <span class="m">27</span> Dec <span class="m">2018</span> <span class="m">2317</span> GMT
server: Cowboy</code></pre></td></tr></table>
</div>
</div>

<p>As you can see, although we didn&rsquo;t explicitly match the <code>HEAD</code> routes using the
<code>head</code> macro, the <code>Plug.Head</code> plug remapped the <code>HEAD</code> requests to <code>GET</code> and
our handlers still kept on working as expected (the first one returned an HTTP
200, and the second one an HTTP 404).</p>

<h3 id="plug-logger"><code>Plug.Logger</code></h3>

<p>This one is a bit more complicated so we cannot inline
<a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/logger.ex#L1">all of its code</a>
in this article. Basically, if we would plug this plug in our router, it will
log all of the incoming requests and response statuses, like so:</p>

<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">  GET /index.html
  Sent 200 in 572ms</code></pre></div>

<p>This plug uses Elixir&rsquo;s <code>Logger</code> (<a href="https://hexdocs.pm/logger/Logger.html">docs</a>)
under the hood, which supports four different logging levels:</p>

<ul>
<li><code>:debug</code> - for debug-related messages</li>
<li><code>:info</code> - for information of any kind (default level)</li>
<li><code>:warn</code> - for warnings</li>
<li><code>:error</code> - for errors</li>
</ul>

<p>If we would look at the source of its <code>call/2</code> function, we would notice two
logical units. The first one is:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">def</span> <span class="n">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span> <span class="n">do</span>
  <span class="nc">Logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">fn</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="n">conn</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="sc">?</span><span class="se">\s</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">request_path</span><span class="p">]</span>
  <span class="n">end</span><span class="p">)</span>

  <span class="c1"># Snipped...</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p>This one will take Elixir&rsquo;s <code>Logger</code> and using the logging <code>level</code> will log the
information to the backend (by default it&rsquo;s <code>console</code>). The information that is
logged is the method of the request (e.g. <code>GET</code>, <code>POST</code>, etc) and the request
path (e.g. <code>/foo/bar</code>). This results in the first line of the log:</p>

<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">GET /index.html</code></pre></div>

<p>The second logical unit is a bit more elaborate:</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-elixir" data-lang="elixir"><span class="n">def</span> <span class="n">call</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span> <span class="n">do</span>
  <span class="c1"># Snipped...</span>

  <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span>

  <span class="nc">Conn</span><span class="o">.</span><span class="n">register_before_send</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">fn</span> <span class="n">conn</span> <span class="o">-&gt;</span>
    <span class="nc">Logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">fn</span> <span class="o">-&gt;</span>
      <span class="n">stop</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">monotonic_time</span><span class="p">()</span>
      <span class="n">diff</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">convert_time_unit</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="ss">:native</span><span class="p">,</span> <span class="ss">:microsecond</span><span class="p">)</span>
      <span class="n">status</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>

      <span class="p">[</span><span class="n">connection_type</span><span class="p">(</span><span class="n">conn</span><span class="p">),</span> <span class="sc">?</span><span class="se">\s</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="s2">&#34; in &#34;</span><span class="p">,</span> <span class="n">formatted_diff</span><span class="p">(</span><span class="n">diff</span><span class="p">)]</span>
    <span class="n">end</span><span class="p">)</span>

    <span class="n">conn</span>
  <span class="n">end</span><span class="p">)</span>
<span class="n">end</span></code></pre></td></tr></table>
</div>
</div>

<p>In short: this section records the time between the <code>start</code> and the <code>stop</code> (end)
of the request and prints out the <code>diff</code>erence between the two (or in other
words - the amount of time the response took). Also, it prints out the HTTP
status of the response.</p>

<p>To do this it uses <code>Plug.Conn.register_before_send/2</code>
(<a href="https://hexdocs.pm/plug/Plug.Conn.html#register_before_send/2">docs</a>)
which is a utility function that registers callbacks to be invoked before the
response is sent. This means that the function which will calculate the <code>diff</code>
and log it to the <code>Logger</code> with the response status will be invoked by
<code>Plug.Conn</code> right before the response is sent to the client.</p>

<h2 id="wrapping-up-with-plug">Wrapping up with Plug</h2>

<p>You actually made it this far - I applaud you. I hope that this was a nice
journey for you in Plug and it&rsquo;s related modules/functions and that you learned
something new.</p>

<p>We looked at quite a bit of details in and around <code>Plug</code>. For some of the
modules that we spoke about we barely scratched the surface. For example,
<code>Plug.Conn</code> has quite a bit of more useful functions. Or <code>Plug.Router</code> has more
functions in its DSL where you can write more elaborate and thoughtful APIs or
web apps. In line with this, <code>Plug</code> also offers more built-in plugs. It even has
a plug which can serve static files with ease, and plugging it in your
Plug-based apps is a breeze.</p>

<p>But, aside from all the things that we skipped in this article, I hope that you
understood how powerful the Plug model is and how much power it provides us
with such simplicity and unobtrusiveness.</p>

<p>In future posts, we will look at even more details about other plugs in <code>Plug</code>,
but until then please shoot me a comment or a message if you&rsquo;ve found this
article helpful (or not).</p>

    </div>

    
    


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ieftimov.com/tags/cowboy/">cowboy</a>
          <a href="https://ieftimov.com/tags/router/">router</a>
          <a href="https://ieftimov.com/tags/endpoint/">endpoint</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/understanding-basics-elixir-concurrency-model/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">Understanding the basics of Elixir&#39;s concurrency model</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/haveibeenpwned-password-lookup-elixir/">
            <span class="next-text nav-default">Validate your passwords using Elixir and haveibeenpwned.com&#39;s API</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  <div class="disqus-comment">
  <div class="disqus-button" id="load_disqus" onclick="load_disqus()">
    Show Disqus Comments
  </div>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
      this.page.url = "https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/";
    };
    function load_disqus() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'eftimov';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

      $('#load_disqus').remove();
    };
  </script>
  <noscript>Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  </div>

    

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="https://stackoverflow.com/users/601555/ilija-eftimov" rel="me noopener" class="iconfont"
      title="stack-overflow"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M809.714286 932.571429l-638.857143 0 0-274.285714-91.428571 0 0 365.714286 821.714286 0 0-365.714286-91.428571 0 0 274.285714zm-538.285714-299.428571l18.857143-89.714286 447.428571 94.285714-18.857143 89.142857zm58.857143-213.714286l38.285714-83.428571 414.285714 193.714286-38.285714 82.857143zm114.857143-203.428571l58.285714-70.285714 350.857143 293.142857-58.285714 70.285714zm226.857143-216l272.571429 366.285714-73.142857 54.857143-272.571429-366.285714zm-410.285714 840.571429l0-90.857143 457.142857 0 0 90.857143-457.142857 0z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/fteem" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/ieftimov/" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/fteem" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="blog@ieftimov.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>


<a href="https://ieftimov.com/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2014 -
    2019
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Ilija Eftimov
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>






  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  













</body>
</html>
