<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A deeper dive in Elixir's Plug | Ilija Eftimov ⚡️</title><meta name=keywords content="cowboy,router,endpoint"><meta name=description content="Being new to Elixir and Phoenix, I spend quite some time in the projects' documentation. One thing that stood out for me recently is the first sentence of Phoenix&rsquo;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/><link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=ieftimov data-description="Support me on Buy me a coffee!" data-message data-color=#FFDD00 data-position=Left data-x_margin=18 data-y_margin=18></script><meta property="og:title" content="A deeper dive in Elixir's Plug"><meta property="og:description" content="Being new to Elixir and Phoenix, I spend quite some time in the projects' documentation. One thing that stood out for me recently is the first sentence of Phoenix&rsquo;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/"><meta property="og:image" content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png"><meta property="article:published_time" content="2018-12-31T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-31T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/a-deeper-dive-in-elixir-plug.png"><meta name=twitter:title content="A deeper dive in Elixir's Plug"><meta name=twitter:description content="Being new to Elixir and Phoenix, I spend quite some time in the projects' documentation. One thing that stood out for me recently is the first sentence of Phoenix&rsquo;s Plug documentation:
 Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.
 So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"A deeper dive in Elixir's Plug","item":"https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A deeper dive in Elixir's Plug","name":"A deeper dive in Elixir\u0027s Plug","description":"Being new to Elixir and Phoenix, I spend quite some time in the projects\u0026#39; documentation. One thing that stood out for me recently is the first sentence of Phoenix\u0026amp;rsquo;s Plug …","keywords":["cowboy","router","endpoint"],"articleBody":"Being new to Elixir and Phoenix, I spend quite some time in the projects' documentation. One thing that stood out for me recently is the first sentence of Phoenix’s Plug documentation:\n Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.\n So naturally, I felt compelled to take a deeper dive into Plug and understand it better. I hope the following article will help you out in understanding Plug.\nWhat’s Plug? As the readme puts it, Plug is:\n A specification for composable modules between web applications Connection adapters for different web servers in the Erlang VM  But, what does this mean? Well, it basically states that Plug 1) defines the way you build web apps in Elixir and 2) it provides you with tools to write apps that are understood by web servers.\nLet’s take a dive and see what that means.\nWeb servers, yeehaw! One of the most popular HTTP servers for Erlang is Cowboy. It is a small, fast and modern HTTP server for Erlang/OTP. If you were to write any web application in Elixir it will run on Cowboy, because the Elixir core team has built a Plug adapter for Cowboy, conveniently named plug_cowboy.\nThis means that if you include this package in your package, you will get the Elixir interface to talk to the Cowboy web server (and vice-versa). It means that you can send and receive requests and other stuff that web servers can do.\nSo why is this important?\nWell, to understand Plug we need to understand how it works. Basically, using the adapter (plug_cowboy), Plug can accept the connection request that comes in Cowboy and turn it into a meaningful struct, also known as Plug.Conn.\nThis means that Plug uses plug_cowboy to understand Cowboy’s nitty-gritty details. By doing this Plug allows us to easily build handler functions and modules that can receive, handle and respond to requests.\nOf course, the idea behind Plug is not to work only with Cowboy. If you look at this SO answer from José Valim (Elixir’s BDFL) he clearly states “Plug is meant to be a generic adapter for different web servers. Currently we support just Cowboy but there is work to support others.”\nEnter Plug Okay, now that we’ve scratched the surface of Cowboy and it’s Plug adapter, let’s look at Plug itself.\nIf you look at Plug’s README, you will notice that there are two flavours of plugs, a function or a module.\nThe most minimal plug can be a function, it just takes a Plug.Conn struct (that we will explore more later) and some options. The function will manipulate the struct and return it at the end. Here’s the example from the README:\n1 2 3 4 5  def hello_world_plug(conn, _opts) do conn | put_resp_content_type(\"text/plain\") | send_resp(200, \"Hello world\") end   Code blatantly copied from Plug’s docs. If you look at the function, it’s quite simple. It receives the connection struct, puts its content type to text/plain and returns a response with an HTTP 200 status and \"Hello world\" as the body.\nThe second flavour is the module Plug. This means that instead of just having a function that will be invoked as part of the request lifecycle, you can define a module that takes a connection and initialized options and returns the connection:\n1 2 3 4  defmodule MyPlug do def init([]), do: false def call(conn, _opts), do: conn end   Code blatantly copied from Plug’s docs. Having this in mind, let’s take a step further and see how we can use Plug in a tiny application.\nPlugging a plug as an endpoint So far, the most important things we covered was what’s Plug and what is it used for on a high level. We also took a look at two different types of plugs.\nNow, let’s see how we can mount a Plug on a Cowboy server and essentially use it as an endpoint:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  defmodule PlugTest do import Plug.Conn def init(options) do # initialize options options end def call(conn, _opts) do conn | put_resp_content_type(\"text/plain\") | send_resp(200, \"Hello world\") end end   What this module will do is, when mounted on a Cowboy server, will set the Content-Type header to text/plain and will return an HTTP 200 with a body of Hello world.\nLet’s fire up IEx and test this ourselves:\n1 2 3 4 5 6  › iex -S mix Erlang/OTP 21 [erts-10.2] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Interactive Elixir (1.7.4) - press Ctrl+C to exit (type h() ENTER for help) iex(1) {:ok, _ } = Plug.Cowboy.http PlugTest, [], port: 3000 {:ok, #PID}   This starts the Cowboy server as a BEAM process, listening on port 3000. If we cURL it we’ll see the response body and it’s headers:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  › curl -v 127.0.0.1:3000  GET / HTTP/1.1  Host: 127.0.0.1:3000  User-Agent: curl/7.54.0  Accept: */*     You see, the Content-Type of the response is set to text/plain and the body is Hello world. In this example, the plug is essentially an endpoint by itself, serving plain text to our cURL command (or to a browser). As you might be able to imagine at this point, you can plug in much more elaborate Plugs to a Cowboy server and it will serve them just fine.\nTo shut down the endpoint all you need to do is:\n1 2  iex(2) Plug.Cowboy.shutdown PlugTest.HTTP :ok   What we are witnessing here is probably the tiniest web application one can write in Elixir. It’s an app that takes a request and returns a valid response over HTTP with a status and a body.\nSo, how does this actually work? How do we accept the request and build a response here?\nDiving into the Plug.Conn To understand this, we need to zoom in the call/2 function of our module PlugTest. I will also throw in an IO.inspect right at the end of the function so we can inspect what this struct is:\n1 2 3 4 5 6  def call(conn, _opts) do conn | put_resp_content_type(\"text/plain\") | send_resp(200, \"Hello world\") | IO.inspect end   If you start the Cowboy instance again via your IEx session and you hit 127.0.0.1:3000 via cURL (or a browser), you should see something like this in your IEx session:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  %Plug.Conn{ adapter: {Plug.Cowboy.Conn, :...}, assigns: %{}, before_send: [], body_params: %Plug.Conn.Unfetched{aspect: :body_params}, cookies: %Plug.Conn.Unfetched{aspect: :cookies}, halted: false, host: \"127.0.0.1\", method: \"GET\", owner: #PID, params: %Plug.Conn.Unfetched{aspect: :params}, path_info: [], path_params: %{}, port: 3000, private: %{}, query_params: %Plug.Conn.Unfetched{aspect: :query_params}, query_string: \"\", remote_ip: {127, 0, 0, 1}, req_cookies: %Plug.Conn.Unfetched{aspect: :cookies}, req_headers: [ {\"accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\"}, {\"accept-encoding\", \"gzip, deflate, br\"}, {\"accept-language\", \"en-US,en;q=0.9\"}, {\"connection\", \"keep-alive\"}, {\"host\", \"127.0.0.1:3000\"}, {\"upgrade-insecure-requests\", \"1\"}, {\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"} ], request_path: \"/\", resp_body: nil, resp_cookies: %{}, resp_headers: [ {\"cache-control\", \"max-age=0, private, must-revalidate\"}, {\"content-type\", \"text/plain; charset=utf-8\"} ], scheme: :http, script_name: [], secret_key_base: nil, state: :sent, status: 200 }   What are we actually looking at? Well, it’s actually the Plug representation of a connection. This is a direct interface to the underlying web server and the request that the Cowboy server has received.\nSome of the attributes of the struct are pretty self-explanatory, like scheme, method, host, request_path, etc. If you would like to go into detail what each of these fields is, I suggest taking a look at Plug.Conn’s documentation.\nBut, to understand better the Plug.Conn struct, we need to understand the connection lifecycle of each connection struct.\nConnection lifecycle Just like any map in Elixir Plug.Conn allows us to pattern match on it. Let’s modify the little endpoint we created before and try to add some extra IO.inspect function calls:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  defmodule PlugTest do import Plug.Conn def init(options) do # initialize options options end def call(conn, _opts) do conn | inspect_state | put_resp_content_type(\"text/plain\") | inspect_state | put_private(:foo, :bar) | inspect_state | resp(200, \"Hello world\") | inspect_state | send_resp() | inspect_state end defp inspect_state(conn = %{state: state}) do IO.inspect state conn end end   Because Plug.Conn allows pattern matching, we can get the state of the connection, print it out and return the connection itself so the pipeline in the call/2 function would continue working as expected.\nLet’s mount this plug on a Cowboy instance and hit it with a simple cURL request:\n1 2 3 4 5 6 7 8 9 10  iex(6) Plug.Cowboy.http PlugTest, [], port: 3000 {:ok, #PID} # curl 127.0.0.1:3000 iex(21) :unset :unset :unset :set :sent   You see, when the connection enters the plug it’s state changes from :unset to :set to finally :sent. This means that once the plug is invoked the state of the connection is :unset. Then we do multiple actions, or in other words, we invoke multiple functions on the Plug.Conn which add more information to the connection. Obviously, since all variables in Elixir are immutable, each of these function returns a new Plug.Conn instance, instead of mutating the existing one.\nOnce the body and the status of the connection are set, then the state changes to :set. Up until that moment, the state is fixed as :unset. Once we send the response back to the client the state is changed to :sent.\nWhat we need to understand here is that whether we have one or more plugs in a pipeline, they will all receive a Plug.Conn, call functions on it, whether to extract or add data to it and then the connection will be passed on to the next plug. Eventually, in the pipeline, there will be a plug (in the form of an endpoint or a Phoenix controller) that will set the body and the response status and send the response back to the client.\nThere are a bit more details to this, but this is just enough to wrap our minds around Plug and Plug.Conn in general.\nNext-level Plugging using Plug.Router Now that we understand how Plug.Conn works and how plugs can change the connection by invoking functions defined in the Plug.Conn module, let’s look at a more advanced feature of plugs - turning a plug into a router.\nIn our first example, we saw the simplest of the Elixir web apps - a simple plug that takes the request and returns a simple response with a text body and an HTTP 200. But, what if we want to handle different routes or HTTP methods? What if we want to gracefully handle any request to an unknown route with an HTTP 404?\nOne nicety that Plug comes with is a module called Plug.Router, you can see its documentation here. The router module contains a DSL that allows us to define a routing algorithm for incoming requests and writing handlers (powered by Plug) for the routes. If you are coming from Ruby land, while Plug is basically Rack, this DSL is Sinatra.rb.\nLet’s create a tiny router using Plug.Router, add some plugs to its pipeline and some endpoints.\nQuick aside: What is a pipeline?\nAlthough it has the same name as the pipeline operator (|), a pipeline in Plug’s context is a list of plugs executed one after another. That’s really it. The last plug in that pipeline is usually an endpoint that will set the body and the status of the response and return the response to the client.\nNow, back to our router:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  defmodule MyRouter do use Plug.Router plug :match plug :dispatch get \"/hello\" do send_resp(conn, 200, \"world\") end match _ do send_resp(conn, 404, \"oops\") end end   Code blatantly copied from Plug.Router’s docs. The first thing that you will notice here is that all routers are modules as well. By useing the Plug.Router module, we include some functions that make our lives easier, like get or match.\nIf you notice at the top of the module we have two lines:\n1 2  plug :match plug :dispatch   This is the router’s pipeline. All of the requests coming to the router will pass through these two plugs: match and dispatch. The first one does the matching of the route that we define (e.g. /hello), while the other one will invoke the function defined for a particular route. This means that if we would like to add other plugs, most of the time they will be invoked between the two mandatory ones (match and dispatch).\nLet’s mount our router on a Cowboy server and see it’s behaviour:\n1 2  iex(29) Plug.Cowboy.http MyRouter, [], port: 3000 {:ok, #PID}   When we hit 127.0.0.1:3000/hello, we will get the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  › curl -v 127.0.0.1:3000/hello * Trying 127.0.0.1... * TCP_NODELAY set * Connected to 127.0.0.1 (127.0.0.1) port 3000 (#0)  GET /hello HTTP/1.1  Host: 127.0.0.1:3000  User-Agent: curl/7.54.0  Accept: */*  200 OK 5 27 Dec 2018 22:50:47 GMT #0 to host 127.0.0.1 left intact world   As you can see, we received world as the response body and an HTTP 200. But if we hit any other URL, the router will match the other route:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  › curl -v 127.0.0.1:3000/foo * Trying 127.0.0.1... * TCP_NODELAY set * Connected to 127.0.0.1 (127.0.0.1) port 3000 (#0)  GET /foo HTTP/1.1  Host: 127.0.0.1:3000  User-Agent: curl/7.54.0  Accept: */*  404 Not Found 4 27 Dec 2018 22:51:56 GMT #0 to host 127.0.0.1 left intact oops   As you can see, because the /hello route didn’t match we defaulted to the other route, also known as “catch all” route, which returned oops as the response body and an HTTP 404 status.\nIf you would like to learn more about Plug.Router and its route matching macros you can read more in its documentation. We still need to cover some more distance with Plug.\nBuilt-in Plugs In the previous section, we mentioned the plugs match and dispatch, and plug pipelines. We also mentioned that we can plug in other plugs in the pipeline so we can inspect or change the Plug.Conn of each request.\nWhat is very exciting here is that Plug also comes with already built-in plugs. That means that there’s a list of plugs that you can plug-in in any Plug-based application:\n Plug.CSRFProtection Plug.Head Plug.Logger Plug.MethodOverride Plug.Parsers Plug.RequestId Plug.SSL Plug.Session Plug.Static  Let’s try to understand how a couple of them work and how we can plug them in our MyRouter router module.\nPlug.Head This is a rather simple plug. It’s so simple, I will add all of its code here:\n1 2 3 4 5 6 7 8 9 10  defmodule Plug.Head do @behaviour Plug alias Plug.Conn def init([]), do: [] def call(%Conn{method: \"HEAD\"} = conn, []), do: %{conn | method: \"GET\"} def call(conn, []), do: conn end   What this plug does is it turns any HTTP HEAD request into a GET request. That’s all. Its call function receives a Plug.Conn, matches only the ones that have a method: \"HEAD\" and returns a new Plug.Conn with the method changed to \"GET\".\nIf you’ve been wondering what the HEAD method is for, this is from RFC 2616:\n The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification.\n Let’s plug this plug in our Plug.Router (pun totally intended):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  defmodule MyRouter do use Plug.Router plug Plug.Head plug :match plug :dispatch get \"/hello\" do send_resp(conn, 200, \"world\") end match _ do send_resp(conn, 404, \"oops\") end end   Once we cURL the routes we would get the following behaviour:\n1 2 3 4 5 6 7 8 9 10 11 12 13  › curl -I 127.0.0.1:3000/hello HTTP/1.1 200 OK cache-control: max-age=0, private, must-revalidate content-length: 5 date: Thu, 27 Dec 2018 23:25:13 GMT server: Cowboy › curl -I 127.0.0.1:3000/foo HTTP/1.1 404 Not Found cache-control: max-age=0, private, must-revalidate content-length: 4 date: Thu, 27 Dec 2018 23:25:17 GMT server: Cowboy   As you can see, although we didn’t explicitly match the HEAD routes using the head macro, the Plug.Head plug remapped the HEAD requests to GET and our handlers still kept on working as expected (the first one returned an HTTP 200, and the second one an HTTP 404).\nPlug.Logger This one is a bit more complicated so we cannot inline all of its code in this article. Basically, if we would plug this plug in our router, it will log all of the incoming requests and response statuses, like so:\n1 2  GET /index.html Sent 200 in 572ms   This plug uses Elixir’s Logger (docs) under the hood, which supports four different logging levels:\n :debug - for debug-related messages :info - for information of any kind (default level) :warn - for warnings :error - for errors  If we would look at the source of its call/2 function, we would notice two logical units. The first one is:\n1 2 3 4 5 6 7  def call(conn, level) do Logger.log(level, fn - [conn.method, ?\\s, conn.request_path] end) # Snipped... end   This one will take Elixir’s Logger and using the logging level will log the information to the backend (by default it’s console). The information that is logged is the method of the request (e.g. GET, POST, etc) and the request path (e.g. /foo/bar). This results in the first line of the log:\n1  GET /index.html   The second logical unit is a bit more elaborate:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def call(conn, level) do # Snipped... start = System.monotonic_time() Conn.register_before_send(conn, fn conn - Logger.log(level, fn - stop = System.monotonic_time() diff = System.convert_time_unit(stop - start, :native, :microsecond) status = Integer.to_string(conn.status) [connection_type(conn), ?\\s, status, \" in \", formatted_diff(diff)] end) conn end) end   In short: this section records the time between the start and the stop (end) of the request and prints out the difference between the two (or in other words - the amount of time the response took). Also, it prints out the HTTP status of the response.\nTo do this it uses Plug.Conn.register_before_send/2 (docs) which is a utility function that registers callbacks to be invoked before the response is sent. This means that the function which will calculate the diff and log it to the Logger with the response status will be invoked by Plug.Conn right before the response is sent to the client.\nWrapping up with Plug You actually made it this far - I applaud you. I hope that this was a nice journey for you in Plug and it’s related modules/functions and that you learned something new.\nWe looked at quite a bit of details in and around Plug. For some of the modules that we spoke about we barely scratched the surface. For example, Plug.Conn has quite a bit of more useful functions. Or Plug.Router has more functions in its DSL where you can write more elaborate and thoughtful APIs or web apps. In line with this, Plug also offers more built-in plugs. It even has a plug which can serve static files with ease, and plugging it in your Plug-based apps is a breeze.\nBut, aside from all the things that we skipped in this article, I hope that you understood how powerful the Plug model is and how much power it provides us with such simplicity and unobtrusiveness.\nIn future posts, we will look at even more details about other plugs in Plug, but until then please shoot me a comment or a message if you’ve found this article helpful (or not).\nLiked this article? Subscribe to my newsletter and get my fresh posts in your inbox. It's short and sweet, going out monthly to over 1,000 subscribers.  ","wordCount":"3503","inLanguage":"en","datePublished":"2018-12-31T00:00:00Z","dateModified":"2018-12-31T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/a-deeper-dive-in-elixir-plug/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://ieftimov.com/posts title=Archive><span>Archive</span></a></li><li><a href=https://ieftimov.com/about title=About><span>About</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>A deeper dive in Elixir's Plug</h1><div class=post-meta>December 31, 2018&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#whats-plug aria-label="What&amp;rsquo;s Plug?">What&rsquo;s Plug?</a></li><li><a href=#web-servers-yeehaw aria-label="Web servers, yeehaw!">Web servers, yeehaw!</a></li><li><a href=#enter-plug aria-label="Enter Plug">Enter Plug</a></li><li><a href=#plugging-a-plug-as-an-endpoint aria-label="Plugging a plug as an endpoint">Plugging a plug as an endpoint</a></li><li><a href=#diving-into-the-plugconn aria-label="Diving into the Plug.Conn">Diving into the <code>Plug.Conn</code></a><ul><li><a href=#connection-lifecycle aria-label="Connection lifecycle">Connection lifecycle</a></li></ul></li><li><a href=#next-level-plugging-using-plugrouter aria-label="Next-level Plugging using Plug.Router">Next-level <code>Plug</code>ging using <code>Plug.Router</code></a></li><li><a href=#built-in-plugs aria-label="Built-in Plugs">Built-in Plugs</a><ul><li><a href=#plughead aria-label=Plug.Head><code>Plug.Head</code></a></li><li><a href=#pluglogger aria-label=Plug.Logger><code>Plug.Logger</code></a></li></ul></li><li><a href=#wrapping-up-with-plug aria-label="Wrapping up with Plug">Wrapping up with Plug</a></li></ul></div></details></div><div class=post-content><p>Being new to Elixir and Phoenix, I spend quite some time in the projects'
documentation. One thing that stood out for me recently is the first sentence
of <a href=https://hexdocs.pm/phoenix/plug.html#content>Phoenix&rsquo;s Plug
documentation</a>:</p><blockquote><p>Plug lives at the heart of Phoenix’s HTTP layer and Phoenix puts Plug front and center.</p></blockquote><p>So naturally, I felt compelled to take a deeper dive into Plug and understand
it better. I hope the following article will help you out in understanding
Plug.</p><h2 id=whats-plug>What&rsquo;s Plug?<a hidden class=anchor aria-hidden=true href=#whats-plug>#</a></h2><p>As <a href=https://github.com/elixir-plug/plug#plug>the readme</a> puts it, Plug is:</p><ol><li>A specification for composable modules between web applications</li><li>Connection adapters for different web servers in the Erlang VM</li></ol><p>But, what does this mean? Well, it basically states that Plug 1) <em>defines the
way</em> you build web apps in Elixir and 2) it provides you with tools to write
apps that are understood by web servers.</p><p>Let&rsquo;s take a dive and see what that means.</p><h2 id=web-servers-yeehaw>Web servers, yeehaw!<a hidden class=anchor aria-hidden=true href=#web-servers-yeehaw>#</a></h2><p>One of the most popular HTTP servers for Erlang is
<a href=https://github.com/ninenines/cowboy>Cowboy</a>. It is a small, fast and modern
HTTP server for Erlang/OTP. If you were to write any web application in Elixir
it will run on Cowboy, because the Elixir core team has built a Plug adapter
for Cowboy, conveniently named
<a href=https://github.com/elixir-plug/plug_cowboy>plug_cowboy</a>.</p><p>This means that if you include this package in your package, you will get the
Elixir interface to talk to the Cowboy web server (and vice-versa). It means
that you can send and receive requests and other stuff that web servers can do.</p><p>So why is this important?</p><p>Well, to understand Plug we need to understand how it works. Basically, using
the adapter (<code>plug_cowboy</code>), Plug can accept the connection request that comes
in Cowboy and turn it into a meaningful struct, also known as <code>Plug.Conn</code>.</p><p>This means that Plug uses <code>plug_cowboy</code> to understand Cowboy&rsquo;s nitty-gritty
details. By doing this Plug allows us to easily build handler functions and
modules that can receive, handle and respond to requests.</p><p>Of course, the idea behind Plug is not to work only with Cowboy. If you look at
<a href=https://stackoverflow.com/a/26323883/6015550>this SO answer</a> from José Valim
(Elixir&rsquo;s BDFL) he clearly states &ldquo;Plug is meant to be a generic adapter for
different web servers. Currently we support just Cowboy but there is work to
support others.&rdquo;</p><h2 id=enter-plug>Enter Plug<a hidden class=anchor aria-hidden=true href=#enter-plug>#</a></h2><p>Okay, now that we&rsquo;ve scratched the surface of Cowboy and it&rsquo;s Plug adapter,
let&rsquo;s look at Plug itself.</p><p>If you look at <a href=https://github.com/elixir-plug/plug/blob/master/README.md>Plug&rsquo;s
README</a>, you will
notice that there are two flavours of plugs, a function or a module.</p><p>The most minimal plug can be a function, it just takes a <code>Plug.Conn</code> struct
(that we will explore more later) and some options. The function will
manipulate the struct and return it at the end. Here&rsquo;s the example from the
<code>README</code>:</p><p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>def</span> hello_world_plug(conn, _opts) <span style=color:#5f8700>do</span>
  conn
  |&gt; put_resp_content_type(<span style=color:#00afaf>&#34;text/plain&#34;</span>)
  |&gt; send_resp(<span style=color:#00afaf>200</span>, <span style=color:#00afaf>&#34;Hello world&#34;</span>)
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div>Code blatantly copied from
<a href=https://github.com/elixir-plug/plug/blob/master/README.md>Plug&rsquo;s docs</a>.</p><p>If you look at the function, it&rsquo;s quite simple. It receives the connection
struct, puts its content type to <code>text/plain</code> and returns a response with an
HTTP 200 status and <code>"Hello world"</code> as the body.</p><p>The second flavour is the module Plug. This means that instead of just having a
function that will be invoked as part of the request lifecycle, you can define
a module that takes a connection and initialized options and returns the
connection:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>defmodule</span> <span style=color:#0087ff>MyPlug</span> <span style=color:#5f8700>do</span>
  <span style=color:#0087ff>def</span> init([]), <span style=color:#00afaf>do</span>: <span style=color:#d75f00>false</span>
  <span style=color:#0087ff>def</span> call(conn, _opts), <span style=color:#00afaf>do</span>: conn
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>Code blatantly copied from
<a href=https://github.com/elixir-plug/plug/blob/master/README.md>Plug&rsquo;s docs</a>.</p><p>Having this in mind, let&rsquo;s take a step further and see how we can use Plug in a
tiny application.</p><h2 id=plugging-a-plug-as-an-endpoint>Plugging a plug as an endpoint<a hidden class=anchor aria-hidden=true href=#plugging-a-plug-as-an-endpoint>#</a></h2><p>So far, the most important things we covered was what&rsquo;s Plug and what is it
used for on a high level. We also took a look at two different types of plugs.</p><p>Now, let&rsquo;s see how we can mount a Plug on a Cowboy server and essentially use
it as an endpoint:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>defmodule</span> <span style=color:#0087ff>PlugTest</span> <span style=color:#5f8700>do</span>
  <span style=color:#d75f00>import</span> <span style=color:#0087ff>Plug.Conn</span>

  <span style=color:#0087ff>def</span> init(options) <span style=color:#5f8700>do</span>
    <span style=color:#4e4e4e># initialize options</span>

    options
  <span style=color:#5f8700>end</span>

  <span style=color:#0087ff>def</span> call(conn, _opts) <span style=color:#5f8700>do</span>
    conn
    |&gt; put_resp_content_type(<span style=color:#00afaf>&#34;text/plain&#34;</span>)
    |&gt; send_resp(<span style=color:#00afaf>200</span>, <span style=color:#00afaf>&#34;Hello world&#34;</span>)
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>What this module will do is, when mounted on a Cowboy server, will set the
<code>Content-Type</code> header to <code>text/plain</code> and will return an HTTP 200 with a body of
<code>Hello world</code>.</p><p>Let&rsquo;s fire up IEx and test this ourselves:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>› iex -S mix
Erlang/OTP 21 [erts-10.2] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace]

Interactive Elixir (1.7.4) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; {:ok, _ } = Plug.Cowboy.http PlugTest, [], port: 3000
{:ok, #PID&lt;0.202.0&gt;}</code></pre></td></tr></table></div></div><p>This starts the Cowboy server as a BEAM process, listening on port 3000. If we
<code>cURL</code> it we&rsquo;ll see the response body and it&rsquo;s headers:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>› curl -v 127.0.0.1:3000
&gt; GET / HTTP/1.1
&gt; Host: 127.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; cache-control: max-age=0, private, must-revalidate
&lt; content-length: 11
&lt; content-type: text/plain; charset=utf-8
&lt; date: Tue, 25 Dec 2018 22:54:54 GMT
&lt; server: Cowboy
&lt;
* Connection #0 to host 127.0.0.1 left intact
Hello world</code></pre></td></tr></table></div></div><p>You see, the <code>Content-Type</code> of the response is set to <code>text/plain</code> and the body
is <code>Hello world</code>. In this example, the plug is essentially an endpoint by
itself, serving plain text to our <code>cURL</code> command (or to a browser). As you
might be able to imagine at this point, you can plug in much more elaborate
Plugs to a Cowboy server and it will serve them just fine.</p><p>To shut down the endpoint all you need to do is:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>iex(2)&gt; Plug.Cowboy.shutdown PlugTest.HTTP
:ok</code></pre></td></tr></table></div></div><p>What we are witnessing here is probably the tiniest web application one can
write in Elixir. It&rsquo;s an app that takes a request and returns a valid response
over HTTP with a status and a body.</p><p>So, how does this actually work? How do we accept the request and build a
response here?</p><h2 id=diving-into-the-plugconn>Diving into the <code>Plug.Conn</code><a hidden class=anchor aria-hidden=true href=#diving-into-the-plugconn>#</a></h2><p>To understand this, we need to zoom in the <code>call/2</code> function of our module
<code>PlugTest</code>. I will also throw in an <code>IO.inspect</code> right at the end of the
function so we can inspect what this struct is:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>def</span> call(conn, _opts) <span style=color:#5f8700>do</span>
  conn
  |&gt; put_resp_content_type(<span style=color:#00afaf>&#34;text/plain&#34;</span>)
  |&gt; send_resp(<span style=color:#00afaf>200</span>, <span style=color:#00afaf>&#34;Hello world&#34;</span>)
  |&gt; <span style=color:#0087ff>IO</span>.inspect
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>If you start the Cowboy instance again via your IEx session and you hit
<code>127.0.0.1:3000</code> via <code>cURL</code> (or a browser), you should see something like this
in your IEx session:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">43
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>%Plug.Conn{
  adapter: {Plug.Cowboy.Conn, :...},
  assigns: %{},
  before_send: [],
  body_params: %Plug.Conn.Unfetched{aspect: :body_params},
  cookies: %Plug.Conn.Unfetched{aspect: :cookies},
  halted: false,
  host: &#34;127.0.0.1&#34;,
  method: &#34;GET&#34;,
  owner: #PID&lt;0.316.0&gt;,
  params: %Plug.Conn.Unfetched{aspect: :params},
  path_info: [],
  path_params: %{},
  port: 3000,
  private: %{},
  query_params: %Plug.Conn.Unfetched{aspect: :query_params},
  query_string: &#34;&#34;,
  remote_ip: {127, 0, 0, 1},
  req_cookies: %Plug.Conn.Unfetched{aspect: :cookies},
  req_headers: [
    {&#34;accept&#34;,
     &#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#34;},
    {&#34;accept-encoding&#34;, &#34;gzip, deflate, br&#34;},
    {&#34;accept-language&#34;, &#34;en-US,en;q=0.9&#34;},
    {&#34;connection&#34;, &#34;keep-alive&#34;},
    {&#34;host&#34;, &#34;127.0.0.1:3000&#34;},
    {&#34;upgrade-insecure-requests&#34;, &#34;1&#34;},
    {&#34;user-agent&#34;,
     &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#34;}
  ],
  request_path: &#34;/&#34;,
  resp_body: nil,
  resp_cookies: %{},
  resp_headers: [
    {&#34;cache-control&#34;, &#34;max-age=0, private, must-revalidate&#34;},
    {&#34;content-type&#34;, &#34;text/plain; charset=utf-8&#34;}
  ],
  scheme: :http,
  script_name: [],
  secret_key_base: nil,
  state: :sent,
  status: 200
}</code></pre></td></tr></table></div></div><p>What are we actually looking at? Well, it&rsquo;s actually the Plug representation
of a connection. This is a direct interface to the underlying web server and
the request that the Cowboy server has received.</p><p>Some of the attributes of the struct are pretty self-explanatory, like <code>scheme</code>,
<code>method</code>, <code>host</code>, <code>request_path</code>, etc. If you would like to go into detail what
each of these fields is, I suggest taking a look at <code>Plug.Conn</code>&rsquo;s
<a href=https://hexdocs.pm/plug/Plug.Conn.html#module-request-fields>documentation</a>.</p><p>But, to understand better the <code>Plug.Conn</code> struct, we need to understand the
connection lifecycle of each connection struct.</p><h3 id=connection-lifecycle>Connection lifecycle<a hidden class=anchor aria-hidden=true href=#connection-lifecycle>#</a></h3><p>Just like any map in Elixir <code>Plug.Conn</code> allows us to pattern match on it. Let&rsquo;s
modify the little endpoint we created before and try to add some extra
<code>IO.inspect</code> function calls:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">27
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>defmodule</span> <span style=color:#0087ff>PlugTest</span> <span style=color:#5f8700>do</span>
  <span style=color:#d75f00>import</span> <span style=color:#0087ff>Plug.Conn</span>

  <span style=color:#0087ff>def</span> init(options) <span style=color:#5f8700>do</span>
    <span style=color:#4e4e4e># initialize options</span>

    options
  <span style=color:#5f8700>end</span>

  <span style=color:#0087ff>def</span> call(conn, _opts) <span style=color:#5f8700>do</span>
    conn
    |&gt; inspect_state
    |&gt; put_resp_content_type(<span style=color:#00afaf>&#34;text/plain&#34;</span>)
    |&gt; inspect_state
    |&gt; put_private(<span style=color:#00afaf>:foo</span>, <span style=color:#00afaf>:bar</span>)
    |&gt; inspect_state
    |&gt; resp(<span style=color:#00afaf>200</span>, <span style=color:#00afaf>&#34;Hello world&#34;</span>)
    |&gt; inspect_state
    |&gt; send_resp()
    |&gt; inspect_state
  <span style=color:#5f8700>end</span>

  <span style=color:#0087ff>defp</span> inspect_state(conn = %{<span style=color:#00afaf>state</span>: state}) <span style=color:#5f8700>do</span>
    <span style=color:#0087ff>IO</span>.inspect state
    conn
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>Because <code>Plug.Conn</code> allows pattern matching, we can get the <code>state</code> of the
connection, print it out and return the connection itself so the pipeline in
the <code>call/2</code> function would continue working as expected.</p><p>Let&rsquo;s mount this plug on a Cowboy instance and hit it with a simple <code>cURL</code>
request:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>iex(6)&gt; Plug.Cowboy.http PlugTest, [], port: <span style=color:#00afaf>3000</span>
{:ok, <span style=color:#4e4e4e>#PID&lt;0.453.0&gt;}</span>

<span style=color:#4e4e4e># curl 127.0.0.1:3000</span>

iex(21)&gt; :unset
:unset
:unset
:set
:sent</code></pre></td></tr></table></div></div><p>You see, when the connection enters the plug it&rsquo;s state changes from <code>:unset</code> to
<code>:set</code> to finally <code>:sent</code>. This means that once the plug is invoked the state of
the connection is <code>:unset</code>. Then we do multiple actions, or in other words, we
invoke multiple functions on the <code>Plug.Conn</code> which add more information to the
connection. Obviously, since all variables in Elixir are immutable, each of
these function returns a new <code>Plug.Conn</code> instance, instead of mutating the
existing one.</p><p>Once the body and the status of the connection are set, then the state changes
to <code>:set</code>. Up until that moment, the state is fixed as <code>:unset</code>. Once we send
the response back to the client the state is changed to <code>:sent</code>.</p><p>What we need to understand here is that whether we have one or more plugs in a
pipeline, they will all receive a <code>Plug.Conn</code>, call functions on it, whether
to extract or add data to it and then the connection will be passed on to the
next plug. Eventually, in the pipeline, there will be a plug (in the form of an
endpoint or a Phoenix controller) that will set the body and the response status
and send the response back to the client.</p><p>There are a bit more details to this, but this is just enough to wrap our minds
around <code>Plug</code> and <code>Plug.Conn</code> in general.</p><h2 id=next-level-plugging-using-plugrouter>Next-level <code>Plug</code>ging using <code>Plug.Router</code><a hidden class=anchor aria-hidden=true href=#next-level-plugging-using-plugrouter>#</a></h2><p>Now that we understand how <code>Plug.Conn</code> works and how plugs can change the
connection by invoking functions defined in the <code>Plug.Conn</code> module, let&rsquo;s look
at a more advanced feature of plugs - turning a plug into a router.</p><p>In our first example, we saw the simplest of the Elixir web apps - a simple
plug that takes the request and returns a simple response with a text body and
an HTTP 200. But, what if we want to handle different routes or HTTP methods?
What if we want to gracefully handle any request to an unknown route with an
HTTP 404?</p><p>One nicety that <code>Plug</code> comes with is a module called <code>Plug.Router</code>, you can see
its documentation <a href=https://hexdocs.pm/plug/Plug.Router.html#content>here</a>.
The router module contains a DSL that allows us to define a routing algorithm
for incoming requests and writing handlers (powered by Plug) for the routes.
If you are coming from Ruby land, while <code>Plug</code> is basically Rack, this DSL is
Sinatra.rb.</p><p>Let&rsquo;s create a tiny router using <code>Plug.Router</code>, add some plugs to its pipeline
and some endpoints.</p><p><strong>Quick aside: What is a pipeline?</strong></p><p>Although it has the same name as the pipeline operator (<code>|></code>), a pipeline in
Plug&rsquo;s context is a list of plugs executed one after another. That&rsquo;s really it.
The last plug in that pipeline is usually an endpoint that will set the body and
the status of the response and return the response to the client.</p><p>Now, back to our router:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>defmodule</span> <span style=color:#0087ff>MyRouter</span> <span style=color:#5f8700>do</span>
  <span style=color:#d75f00>use</span> <span style=color:#0087ff>Plug.Router</span>

  plug <span style=color:#00afaf>:match</span>
  plug <span style=color:#00afaf>:dispatch</span>

  get <span style=color:#00afaf>&#34;/hello&#34;</span> <span style=color:#5f8700>do</span>
    send_resp(conn, <span style=color:#00afaf>200</span>, <span style=color:#00afaf>&#34;world&#34;</span>)
  <span style=color:#5f8700>end</span>

  match _ <span style=color:#5f8700>do</span>
    send_resp(conn, <span style=color:#00afaf>404</span>, <span style=color:#00afaf>&#34;oops&#34;</span>)
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>Code blatantly copied from
<a href=https://hexdocs.pm/plug/Plug.Router.html><code>Plug.Router</code>&rsquo;s docs</a>.</p><p>The first thing that you will notice here is that all routers are modules as
well. By <code>use</code>ing the <code>Plug.Router</code> module, we include some functions that make
our lives easier, like <code>get</code> or <code>match</code>.</p><p>If you notice at the top of the module we have two lines:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir>plug <span style=color:#00afaf>:match</span>
plug <span style=color:#00afaf>:dispatch</span></code></pre></td></tr></table></div></div><p>This is the router&rsquo;s <em>pipeline</em>. All of the requests coming to the router will
pass through these two plugs: <code>match</code> and <code>dispatch</code>. The first one does the
matching of the route that we define (e.g. <code>/hello</code>), while the other one will
invoke the function defined for a particular route. This means that if we would
like to add other plugs, most of the time they will be invoked between the two
mandatory ones (<code>match</code> and <code>dispatch</code>).</p><p>Let&rsquo;s mount our router on a Cowboy server and see it&rsquo;s behaviour:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>iex(29)&gt; Plug.Cowboy.http MyRouter, [], port: <span style=color:#00afaf>3000</span>
{:ok, <span style=color:#4e4e4e>#PID&lt;0.1500.0&gt;}</span></code></pre></td></tr></table></div></div><p>When we hit <code>127.0.0.1:3000/hello</code>, we will get the following:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>› curl -v 127.0.0.1:3000/hello
*   Trying 127.0.0.1...
* TCP_NODELAY <span style=color:#0087ff>set</span>
* Connected to 127.0.0.1 (127.0.0.1) port <span style=color:#00afaf>3000</span> (<span style=color:#4e4e4e>#0)</span>
&gt; GET /hello HTTP/1.1
&gt; Host: 127.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span style=color:#00afaf>200</span> OK
&lt; cache-control: max-age=0, private, must-revalidate
&lt; content-length: <span style=color:#00afaf>5</span>
&lt; date: Thu, <span style=color:#00afaf>27</span> Dec <span style=color:#00afaf>2018</span> 22:50:47 GMT
&lt; server: Cowboy
&lt;
* Connection <span style=color:#4e4e4e>#0 to host 127.0.0.1 left intact</span>
world</code></pre></td></tr></table></div></div><p>As you can see, we received <code>world</code> as the response body and an HTTP 200. But if
we hit any other URL, the router will match the other route:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>› curl -v 127.0.0.1:3000/foo
*   Trying 127.0.0.1...
* TCP_NODELAY <span style=color:#0087ff>set</span>
* Connected to 127.0.0.1 (127.0.0.1) port <span style=color:#00afaf>3000</span> (<span style=color:#4e4e4e>#0)</span>
&gt; GET /foo HTTP/1.1
&gt; Host: 127.0.0.1:3000
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span style=color:#00afaf>404</span> Not Found
&lt; cache-control: max-age=0, private, must-revalidate
&lt; content-length: <span style=color:#00afaf>4</span>
&lt; date: Thu, <span style=color:#00afaf>27</span> Dec <span style=color:#00afaf>2018</span> 22:51:56 GMT
&lt; server: Cowboy
&lt;
* Connection <span style=color:#4e4e4e>#0 to host 127.0.0.1 left intact</span>
oops</code></pre></td></tr></table></div></div><p>As you can see, because the <code>/hello</code> route didn&rsquo;t match we defaulted to the
other route, also known as &ldquo;catch all&rdquo; route, which returned <code>oops</code> as the
response body and an HTTP 404 status.</p><p>If you would like to learn more about <code>Plug.Router</code> and its route matching
macros you can read more in
<a href=https://hexdocs.pm/plug/Plug.Router.html#module-routes>its documentation</a>. We
still need to cover some more distance with Plug.</p><h2 id=built-in-plugs>Built-in Plugs<a hidden class=anchor aria-hidden=true href=#built-in-plugs>#</a></h2><p>In the previous section, we mentioned the plugs <code>match</code> and <code>dispatch</code>, and plug
pipelines. We also mentioned that we can plug in other plugs in the pipeline
so we can inspect or change the <code>Plug.Conn</code> of each request.</p><p>What is very exciting here is that <code>Plug</code> also comes with already built-in plugs.
That means that there&rsquo;s a list of plugs that you can plug-in in any Plug-based
application:</p><ul><li><code>Plug.CSRFProtection</code></li><li><code>Plug.Head</code></li><li><code>Plug.Logger</code></li><li><code>Plug.MethodOverride</code></li><li><code>Plug.Parsers</code></li><li><code>Plug.RequestId</code></li><li><code>Plug.SSL</code></li><li><code>Plug.Session</code></li><li><code>Plug.Static</code></li></ul><p>Let&rsquo;s try to understand how a couple of them work and how we can plug them in
our <code>MyRouter</code> router module.</p><h3 id=plughead><code>Plug.Head</code><a hidden class=anchor aria-hidden=true href=#plughead>#</a></h3><p>This is a rather simple plug. It&rsquo;s so simple, I will add
<a href=https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/head.ex#L1>all of its code</a>
here:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>defmodule</span> <span style=color:#0087ff>Plug.Head</span> <span style=color:#5f8700>do</span>
  @behaviour <span style=color:#0087ff>Plug</span>

  <span style=color:#d75f00>alias</span> <span style=color:#0087ff>Plug.Conn</span>

  <span style=color:#0087ff>def</span> init([]), <span style=color:#00afaf>do</span>: []

  <span style=color:#0087ff>def</span> call(%<span style=color:#0087ff>Conn</span>{<span style=color:#00afaf>method</span>: <span style=color:#00afaf>&#34;HEAD&#34;</span>} = conn, []), <span style=color:#00afaf>do</span>: %{conn | <span style=color:#00afaf>method</span>: <span style=color:#00afaf>&#34;GET&#34;</span>}
  <span style=color:#0087ff>def</span> call(conn, []), <span style=color:#00afaf>do</span>: conn
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>What this plug does is it turns any HTTP <code>HEAD</code> request into a <code>GET</code> request.
That&rsquo;s all. Its <code>call</code> function receives a <code>Plug.Conn</code>, matches only the ones
that have a <code>method: "HEAD"</code> and returns a new <code>Plug.Conn</code> with the <code>method</code>
changed to <code>"GET"</code>.</p><p>If you&rsquo;ve been wondering what the <code>HEAD</code> method is for, this is from
<a href=https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html>RFC 2616</a>:</p><blockquote><p>The HEAD method is identical to GET except that the server MUST NOT return a
message-body in the response. The metainformation contained in the HTTP headers
in response to a HEAD request SHOULD be identical to the information sent in
response to a GET request. This method can be used for obtaining
metainformation about the entity implied by the request without transferring
the entity-body itself. This method is often used for testing hypertext links
for validity, accessibility, and recent modification.</p></blockquote><p>Let&rsquo;s plug this plug in our <code>Plug.Router</code> (pun totally intended):</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>defmodule</span> <span style=color:#0087ff>MyRouter</span> <span style=color:#5f8700>do</span>
  <span style=color:#d75f00>use</span> <span style=color:#0087ff>Plug.Router</span>

  plug <span style=color:#0087ff>Plug.Head</span>
  plug <span style=color:#00afaf>:match</span>
  plug <span style=color:#00afaf>:dispatch</span>

  get <span style=color:#00afaf>&#34;/hello&#34;</span> <span style=color:#5f8700>do</span>
    send_resp(conn, <span style=color:#00afaf>200</span>, <span style=color:#00afaf>&#34;world&#34;</span>)
  <span style=color:#5f8700>end</span>

  match _ <span style=color:#5f8700>do</span>
    send_resp(conn, <span style=color:#00afaf>404</span>, <span style=color:#00afaf>&#34;oops&#34;</span>)
  <span style=color:#5f8700>end</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>Once we <code>cURL</code> the routes we would get the following behaviour:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>› curl -I 127.0.0.1:3000/hello
HTTP/1.1 <span style=color:#00afaf>200</span> OK
cache-control: max-age=0, private, must-revalidate
content-length: <span style=color:#00afaf>5</span>
date: Thu, <span style=color:#00afaf>27</span> Dec <span style=color:#00afaf>2018</span> 23:25:13 GMT
server: Cowboy

› curl -I 127.0.0.1:3000/foo
HTTP/1.1 <span style=color:#00afaf>404</span> Not Found
cache-control: max-age=0, private, must-revalidate
content-length: <span style=color:#00afaf>4</span>
date: Thu, <span style=color:#00afaf>27</span> Dec <span style=color:#00afaf>2018</span> 23:25:17 GMT
server: Cowboy</code></pre></td></tr></table></div></div><p>As you can see, although we didn&rsquo;t explicitly match the <code>HEAD</code> routes using the
<code>head</code> macro, the <code>Plug.Head</code> plug remapped the <code>HEAD</code> requests to <code>GET</code> and
our handlers still kept on working as expected (the first one returned an HTTP
200, and the second one an HTTP 404).</p><h3 id=pluglogger><code>Plug.Logger</code><a hidden class=anchor aria-hidden=true href=#pluglogger>#</a></h3><p>This one is a bit more complicated so we cannot inline
<a href=https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/logger.ex#L1>all of its code</a>
in this article. Basically, if we would plug this plug in our router, it will
log all of the incoming requests and response statuses, like so:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>  GET /index.html
  Sent 200 in 572ms</code></pre></td></tr></table></div></div><p>This plug uses Elixir&rsquo;s <code>Logger</code> (<a href=https://hexdocs.pm/logger/Logger.html>docs</a>)
under the hood, which supports four different logging levels:</p><ul><li><code>:debug</code> - for debug-related messages</li><li><code>:info</code> - for information of any kind (default level)</li><li><code>:warn</code> - for warnings</li><li><code>:error</code> - for errors</li></ul><p>If we would look at the source of its <code>call/2</code> function, we would notice two
logical units. The first one is:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>def</span> call(conn, level) <span style=color:#5f8700>do</span>
  <span style=color:#0087ff>Logger</span>.log(level, <span style=color:#5f8700>fn</span> -&gt;
    [conn.method, <span style=color:#00afaf>?</span><span style=color:#af0000>\s</span>, conn.request_path]
  <span style=color:#5f8700>end</span>)

  <span style=color:#4e4e4e># Snipped...</span>
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>This one will take Elixir&rsquo;s <code>Logger</code> and using the logging <code>level</code> will log the
information to the backend (by default it&rsquo;s <code>console</code>). The information that is
logged is the method of the request (e.g. <code>GET</code>, <code>POST</code>, etc) and the request
path (e.g. <code>/foo/bar</code>). This results in the first line of the log:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>GET /index.html</code></pre></td></tr></table></div></div><p>The second logical unit is a bit more elaborate:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=color:#0087ff>def</span> call(conn, level) <span style=color:#5f8700>do</span>
  <span style=color:#4e4e4e># Snipped...</span>

  start = <span style=color:#0087ff>System</span>.monotonic_time()

  <span style=color:#0087ff>Conn</span>.register_before_send(conn, <span style=color:#5f8700>fn</span> conn -&gt;
    <span style=color:#0087ff>Logger</span>.log(level, <span style=color:#5f8700>fn</span> -&gt;
      stop = <span style=color:#0087ff>System</span>.monotonic_time()
      diff = <span style=color:#0087ff>System</span>.convert_time_unit(stop - start, <span style=color:#00afaf>:native</span>, <span style=color:#00afaf>:microsecond</span>)
      status = <span style=color:#0087ff>Integer</span>.to_string(conn.status)

      [connection_type(conn), <span style=color:#00afaf>?</span><span style=color:#af0000>\s</span>, status, <span style=color:#00afaf>&#34; in &#34;</span>, formatted_diff(diff)]
    <span style=color:#5f8700>end</span>)

    conn
  <span style=color:#5f8700>end</span>)
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>In short: this section records the time between the <code>start</code> and the <code>stop</code>
(end) of the request and prints out the <code>diff</code>erence between the two (or in
other words - the amount of time the response took). Also, it prints out the
HTTP status of the response.</p><p>To do this it uses <code>Plug.Conn.register_before_send/2</code>
(<a href=https://hexdocs.pm/plug/Plug.Conn.html#register_before_send/2>docs</a>) which
is a utility function that registers callbacks to be invoked before the
response is sent. This means that the function which will calculate the <code>diff</code>
and log it to the <code>Logger</code> with the response status will be invoked by
<code>Plug.Conn</code> right before the response is sent to the client.</p><h2 id=wrapping-up-with-plug>Wrapping up with Plug<a hidden class=anchor aria-hidden=true href=#wrapping-up-with-plug>#</a></h2><p>You actually made it this far - I applaud you. I hope that this was a nice
journey for you in Plug and it&rsquo;s related modules/functions and that you learned
something new.</p><p>We looked at quite a bit of details in and around <code>Plug</code>. For some of the
modules that we spoke about we barely scratched the surface. For example,
<code>Plug.Conn</code> has quite a bit of more useful functions. Or <code>Plug.Router</code> has more
functions in its DSL where you can write more elaborate and thoughtful APIs or
web apps. In line with this, <code>Plug</code> also offers more built-in plugs. It even
has a plug which can serve static files with ease, and plugging it in your
Plug-based apps is a breeze.</p><p>But, aside from all the things that we skipped in this article, I hope that you
understood how powerful the Plug model is and how much power it provides us
with such simplicity and unobtrusiveness.</p><p>In future posts, we will look at even more details about other plugs in <code>Plug</code>,
but until then please shoot me a comment or a message if you&rsquo;ve found this
article helpful (or not).</p><section class=subscribe><b>Liked this article?</b> <a href=/newsletter>Subscribe to my
newsletter</a> and get my fresh posts in your inbox. It's short and sweet,
going out monthly to over 1,000 subscribers.</section></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/cowboy/>cowboy</a></li><li><a href=https://ieftimov.com/tags/router/>router</a></li><li><a href=https://ieftimov.com/tags/endpoint/>endpoint</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/understanding-basics-elixir-concurrency-model/><span class=title>« Prev Page</span><br><span>Understanding the basics of Elixir's concurrency model</span></a>
<a class=next href=https://ieftimov.com/post/haveibeenpwned-password-lookup-elixir/><span class=title>Next Page »</span><br><span>Validate your passwords using Elixir and haveibeenpwned.com's API</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share A deeper dive in Elixir's Plug on twitter" href="https://twitter.com/intent/tweet/?text=A%20deeper%20dive%20in%20Elixir%27s%20Plug&url=https%3a%2f%2fieftimov.com%2fpost%2fa-deeper-dive-in-elixir-plug%2f&hashtags=cowboy%2crouter%2cendpoint"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A deeper dive in Elixir's Plug on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fa-deeper-dive-in-elixir-plug%2f&title=A%20deeper%20dive%20in%20Elixir%27s%20Plug&summary=A%20deeper%20dive%20in%20Elixir%27s%20Plug&source=https%3a%2f%2fieftimov.com%2fpost%2fa-deeper-dive-in-elixir-plug%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A deeper dive in Elixir's Plug on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fa-deeper-dive-in-elixir-plug%2f&title=A%20deeper%20dive%20in%20Elixir%27s%20Plug"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A deeper dive in Elixir's Plug on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fa-deeper-dive-in-elixir-plug%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A deeper dive in Elixir's Plug on whatsapp" href="https://api.whatsapp.com/send?text=A%20deeper%20dive%20in%20Elixir%27s%20Plug%20-%20https%3a%2f%2fieftimov.com%2fpost%2fa-deeper-dive-in-elixir-plug%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A deeper dive in Elixir's Plug on telegram" href="https://telegram.me/share/url?text=A%20deeper%20dive%20in%20Elixir%27s%20Plug&url=https%3a%2f%2fieftimov.com%2fpost%2fa-deeper-dive-in-elixir-plug%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>