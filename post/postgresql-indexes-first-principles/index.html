<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PostgreSQL Indexes: First Principles | Ilija Eftimov ⚡️</title><meta name=keywords content="first principles"><meta name=description content="We have all heard about indexes. Yeah, that thing that it&rsquo;s automatically added to the Primary Key column that enables fast data retrieval and stuff. Sure, but have you ever asked yourself if there are multiple types or implementations of indexes? Or maybe, what type of indexes your favourite RDBMS implements? In this blog post, we will take a step back to the beginning, exploring what indexes are, what is their role, types of indexes, metrics and so on."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/postgresql-indexes-first-principles/><link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="PostgreSQL Indexes: First Principles"><meta property="og:description" content="We have all heard about indexes. Yeah, that thing that it&rsquo;s automatically added to the Primary Key column that enables fast data retrieval and stuff. Sure, but have you ever asked yourself if there are multiple types or implementations of indexes? Or maybe, what type of indexes your favourite RDBMS implements? In this blog post, we will take a step back to the beginning, exploring what indexes are, what is their role, types of indexes, metrics and so on."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/postgresql-indexes-first-principles/"><meta property="og:image" content="https://ieftimov.com/cards/postgresql-indexes-first-principles.png"><meta property="article:published_time" content="2016-01-30T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/postgresql-indexes-first-principles.png"><meta name=twitter:title content="PostgreSQL Indexes: First Principles"><meta name=twitter:description content="We have all heard about indexes. Yeah, that thing that it&rsquo;s automatically added to the Primary Key column that enables fast data retrieval and stuff. Sure, but have you ever asked yourself if there are multiple types or implementations of indexes? Or maybe, what type of indexes your favourite RDBMS implements? In this blog post, we will take a step back to the beginning, exploring what indexes are, what is their role, types of indexes, metrics and so on."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"PostgreSQL Indexes: First Principles","item":"https://ieftimov.com/post/postgresql-indexes-first-principles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL Indexes: First Principles","name":"PostgreSQL Indexes: First Principles","description":"We have all heard about indexes. Yeah, that thing that it\u0026amp;rsquo;s automatically added to the Primary Key column that enables fast data retrieval and stuff. Sure, but have you ever …","keywords":["first principles"],"articleBody":"We have all heard about indexes. Yeah, that thing that it’s automatically added to the Primary Key column that enables fast data retrieval and stuff. Sure, but have you ever asked yourself if there are multiple types or implementations of indexes? Or maybe, what type of indexes your favourite RDBMS implements? In this blog post, we will take a step back to the beginning, exploring what indexes are, what is their role, types of indexes, metrics and so on. And all of this in PostgreSQL.\nWhat’s the Problem? When explaining indexes, everyone uses the phonebook analogy. The problem is that the phonebook analogy is so good, thinking of any other one is a waste of time. But, before we jump into indexes, we need to understand the problem that they solve.\nSo, think of a phonebook. The phonebook is a book with all of the names and phone numbers of the people in a city or a country. Now, let’s say we want to find John Doe’s phone number. Knowing that the phone book is alphabetically ordered we look for the page where the surname Doe is. There, we look for John and his phone number. Good, that is efficient enough for a phonebook.\nNow, imagine if our phonebook was not alphabetically sorted? Hell, right? We would need to go through all of the pages, reading every name in the phonebook, until we find our John Doe. This is called sequential searching. You go over all of the records, until you find the person whose phone number you are looking for.\nOne does not need to be a genius to understand that this is super inefficient. The problem with database tables is that the data in them is unordered. If we had a people table, containing all information about people, to lookup the person with the full name John Doe, we would need to execute:\n1  SELECT * FROM people WHERE first_name = \"John\" and last_name = \"Doe\";   Easy enough. But although this query is fast, under the hood, the database will hit every row of the table, until it finds the record it is looking for. I am sure your side-project won’t have this problem soon, but imagine a table with millions of records, without indexes. Data retrieval would take seconds, sometimes maybe minutes. Imagine waiting 30 seconds for a list of videos on YouTube?\nIntroducing Indexes I guess the phonebook example painted the picture well for you. Now, what’s interesting is that the phonebooks, actually have indexes. But, they are different. They are not like a book index, which shows what chapter starts on which page. Or maybe they do, I haven’t seen a phonebook in a while.\nClustered Indexes Nevertheless, indexes have different architectures/indexing methods. And the phonebook has a clustered index. Clustering means that the data is in a distinct order, resulting the row data to be stored in order. If this confuses you, think again about the phonebook - the records in the book are ordered alphabetically. Regardless of how simple this might seem to you, it’s a clustered index. The way the data is ordered (clusters) makes it really easy to search and find the needed phone number. So, a clustered index is an index which physically orders the data (the actual bits on disk) in a certain way, and when new data arrives it is saved in the same order.\nA caveat with the clustered indexes is that only one can be created on a given database table. That occurs due to their nature - they enforce a data order. Also, clustered indexes increase the write time, because when new data arrives, all of the data has to be rearranged. But on the bright side - they can greatly increase the reading speed of the table.\nTo summarize - clustered indexes order the data physically (on disk) in clusters.\nNon-clustered Indexes I know you guessed it - if there are clustered indexes, the opposite type has to exist. And you are right, non-clustered indexes are a thing. They are the type that we know to use most, but I guess not everyone knows how their implementation works.\nNon-clustered indexes are indexes that keep a separate ordering list that has pointers to the physical rows. It’s basically like a book index, it knows on what page a certain chapter starts and ends. Now, unlike the clustered index, a table can have many non-clustered indexes. But, the caveat with these indexes is that each new index will increase the time it takes to write new records.\nSo, to summarize - non-clustered indexes do not order the data physically, they just keep a list of the data order.\nIndexing effects So, after we covered the index architecture, we can explore how indexes work in PostgreSQL. But first things first - let’s play with some indexes.\nIndexes in PostgreSQL are manipulated via a set of commands. For this example, I will use a table with 1000 records, representing 1000 users. The table schema will look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  +-------------------------------------------------+ | Table \"public.users\" | +-------------------------------------------------+ | Column | Type | Modifiers | +------------+------------------------+-----------+ | id | integer | not null | | first_name | character varying(60) | | | last_name | character varying(60) | | | email | character varying(120) | | | gender | character varying(6) | | | created_at | date | | +-------------------------------------------------+ |Indexes: | | \"users_pkey\" PRIMARY KEY, btree (id) | +-------------------------------------------------+   If you want to follow along with this tutorial, you can easily create this table with the following query:\n1 2 3 4 5 6 7 8  CREATE TABLE users ( id INT PRIMARY KEY, first_name VARCHAR(60), last_name VARCHAR(60), email VARCHAR(120), gender VARCHAR(6), created_at DATE );   Having the table now, we can dump any amount of data we want. I will use the following CSV file, which contains 1000 user records. Dumping the data in the table is easy using PostgreSQL’s COPY command. If you are unfamiliar with the command, check out my post which explains it in depth.\nIn our case, the actual command is:\n1 2 3 4 5 6 7 8 9 10 11 12  COPY users ( id, first_name, last_name, email, gender, created_at ) FROM '/some/path/here/to/dummy-users.csv' DELIMITER ','; /* Output: COPY 1000 */   Having the data in the database now, let’s see the real impact of the indexes.\nAnalyzing Queries PostgreSQL creates a query plan for each query it receives. When writing your queries, it is very important to choose the best query plan, which adheres to the query structure and the properties of the data. The query plans are really easy to produce in PostgreSQL. It comes with a really neat command called EXPLAIN, which shows the query plan, which contains all of the relevant info.\nFor example, let’s see the query plan for the query that returns all of the users:\n1  EXPLAIN SELECT * FROM users;   This will return the following output:\n1 2 3 4  QUERY PLAN ---------------------------------------------------------- Seq Scan on users (cost=0.00..20.00 rows=1000 width=48) (1 row)   As you can notice, this simple query requires a Sequential Scan, because there is no WHERE clause in it. This means that it will have to scan each row of the table and return it.\nIn the parentheses we notice couple of values. The cost is a range of arbitrary units (that closely resemble disk page fetches) - starting from the expected before the output phase can begin, to the estimated total cost of this query. Then, the numbers of rows output that were estimated by the query planner. Last, the width represents the average width of the rows, in bytes.\nLet’s add a WHERE clause to the query:\n1  SELECT * FROM users WHERE email = 'phughes5m@nbcnews.com';   The query will return the user whose email is phughes5m@nbcnews.com . Perfect. Let’s EXPLAIN the query, and see its query plan:\n1  EXPLAIN SELECT * FROM users WHERE email = 'phughes5m@nbcnews.com';   1 2 3 4  QUERY PLAN ---------------------------------------------------------- Seq Scan on users (cost=0.00..22.50 rows=1 width=48) Filter: ((email)::text = 'phughes5m@nbcnews.com'::text)   As you can see, although the WHERE clause was added, and the result set was reduced to only one row, the time didn’t go down. Actually, it increased. This happens because the query will issue a Sequential Scan on the table. Let’s see if adding an index to the email column will decrease the cost of the query.\nAdding an Index Adding an index in PostgreSQL is done via the CREATE INDEX command:\n1  CREATE INDEX index name ON table name USING method(column name);   Or, in our specific case:\n1  CREATE INDEX email_idx ON users USING btree(email);   After we run this command, let’s see a description of the table:\n1 2 3 4 5 6 7 8 9 10 11 12  Table \"public.users\" Column | Type | Modifiers ------------+------------------------+----------- id | integer | not null first_name | character varying(60) | last_name | character varying(60) | email | character varying(120) | gender | character varying(6) | created_at | date | Indexes: \"users_pkey\" PRIMARY KEY, btree (id) \"email_idx\" btree (email)   You can see in the “Indexes” section, the new index appears. After we added the index, let’s see the query plan for the SELECT query:\n1  EXPLAIN SELECT * FROM users WHERE email = 'phughes5m@nbcnews.com';   1 2 3 4  QUERY PLAN ---------------------------------------------------------------------- Index Scan using email_idx on users (cost=0.28..8.29 rows=1 width=48) Index Cond: ((email)::text = 'phughes5m@nbcnews.com'::text)   Whoa! The projected query cost dropped from the original 22.50 to 8.29. So, what changed? As you can notice, instead of a Sequential Scan, now PostgreSQL will issue a Index Scan. We won’t go into details here, because types and approaches of scanning is topic for another blogpost. Simply said, Postgres will issue a scan based on the indexes, therefore finding the exact location of the user that we are looking for and returning it. This is a much cheaper operation then using a sequential scan.\nSequential isn’t Always the Worst Let’s see a different example. Let’s say, we want to return all of the users that have the id between 100 and 200:\n1  EXPLAIN SELECT * FROM users WHERE id  100 AND id 200;   1 2 3 4 5  QUERY PLAN ---------------------------------------------------------------------- Index Scan using users_pkey on users (cost=0.28..11.28 rows=100 width=48) Index Cond: ((id  100) AND (id   Looks about right, right? It uses a Index Scan, with an Index Cond(itional) searching for all ids between 100 and 200. Good enough.\nHow about we try to return all users with ids between 200 and 800?\n1  EXPLAIN SELECT * FROM users WHERE id  200 AND id 800;   1 2 3 4 5  QUERY PLAN ------------------------------------------------------- Seq Scan on users (cost=0.00..25.00 rows=600 width=48) Filter: ((id  200) AND (id   Hold on, what happened here? Although there is an index on the primary key column, PostgreSQL decides that doing a sequential scan on the user table is more performant than an index scan. An index scan would require finding 600 indexes and returning each and every one of those records whose index were found. On the other hand, a sequential scan would just go over each of the records and filter out the unwanted rows.\nSo, although this is a contrived example, you can see in some situations an index scan will not be as performant as a sequential scan.\nCareful Usage Indexes are a powerful way to improve the performance of your tables, but they have to be used carefully. Often, indexes can actually stand in the way of your queries, if not used properly.\nNext time we will see what are the index types in PostgreSQL and how we can leverage them.\nLiked this article? You can buy me a coffee. Or simply subscribe to my newsletter and get my fresh posts in your inbox. It's short and sweet, going out monthly to over 1,000 subscribers.  ","wordCount":"1998","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/postgresql-indexes-first-principles/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://ieftimov.com/posts title=Archive><span>Archive</span></a></li><li><a href=https://ieftimov.com/about title=About><span>About</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PostgreSQL Indexes: First Principles</h1><div class=post-meta>January 30, 2016&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#whats-the-problem aria-label="What&amp;rsquo;s the Problem?">What&rsquo;s the Problem?</a></li><li><a href=#introducing-indexes aria-label="Introducing Indexes">Introducing Indexes</a><ul><li><a href=#clustered-indexes aria-label="Clustered Indexes">Clustered Indexes</a></li><li><a href=#non-clustered-indexes aria-label="Non-clustered Indexes">Non-clustered Indexes</a></li></ul></li><li><a href=#indexing-effects aria-label="Indexing effects">Indexing effects</a><ul><li><a href=#analyzing-queries aria-label="Analyzing Queries">Analyzing Queries</a></li><li><a href=#adding-an-index aria-label="Adding an Index">Adding an Index</a></li></ul></li><li><a href=#sequential-isnt-always-the-worst aria-label="Sequential isn&amp;rsquo;t Always the Worst">Sequential isn&rsquo;t Always the Worst</a></li><li><a href=#careful-usage aria-label="Careful Usage">Careful Usage</a></li></ul></div></details></div><div class=post-content><p>We have all heard about indexes. Yeah, that thing that it&rsquo;s automatically added
to the Primary Key column that enables fast data retrieval and stuff. Sure, but
have you ever asked yourself if there are multiple types or implementations of
indexes? Or maybe, what type of indexes your favourite RDBMS implements? In
this blog post, we will take a step back to the beginning, exploring what
indexes are, what is their role, types of indexes, metrics and so on. And all
of this in PostgreSQL.</p><h2 id=whats-the-problem>What&rsquo;s the Problem?<a hidden class=anchor aria-hidden=true href=#whats-the-problem>#</a></h2><p>When explaining indexes, everyone uses the phonebook analogy. The problem is
that the phonebook analogy is so good, thinking of any other one is a waste of
time. But, before we jump into indexes, we need to understand the problem that
they solve.</p><p>So, think of a phonebook. The phonebook is a book with all of the names and
phone numbers of the people in a city or a country. Now, let&rsquo;s say we want to
find John Doe&rsquo;s phone number. Knowing that the phone book is alphabetically
ordered we look for the page where the surname Doe is. There, we look for John
and his phone number. Good, that is efficient enough for a phonebook.</p><p>Now, imagine if our phonebook was not alphabetically sorted? Hell, right? We
would need to go through all of the pages, reading every name in the phonebook,
until we find our John Doe. This is called <strong>sequential searching</strong>. You go
over all of the records, until you find the person whose phone number you are
looking for.</p><p>One does not need to be a genius to understand that this is super inefficient.
The problem with database tables is that the data in them is unordered. If we
had a <code>people</code> table, containing all information about people, to lookup the
person with the full name John Doe, we would need to execute:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>SELECT</span> * <span style=color:#5f8700>FROM</span> people <span style=color:#5f8700>WHERE</span> first_name = <span style=color:#00afaf>&#34;John&#34;</span> <span style=color:#5f8700>and</span> last_name = <span style=color:#00afaf>&#34;Doe&#34;</span>;
</code></pre></td></tr></table></div></div><p>Easy enough. But although this query is fast, under the hood, the database will
hit every row of the table, until it finds the record it is looking for. I am
sure your side-project won&rsquo;t have this problem soon, but imagine a table with
millions of records, without indexes. Data retrieval would take seconds,
sometimes maybe minutes. Imagine waiting 30 seconds for a list of videos on
YouTube?</p><h2 id=introducing-indexes>Introducing Indexes<a hidden class=anchor aria-hidden=true href=#introducing-indexes>#</a></h2><p>I guess the phonebook example painted the picture well for you. Now, what&rsquo;s
interesting is that the phonebooks, actually have indexes. But, they are
different. They are not like a book index, which shows what chapter starts on
which page. Or maybe they do, I haven&rsquo;t seen a phonebook in a while.</p><h3 id=clustered-indexes>Clustered Indexes<a hidden class=anchor aria-hidden=true href=#clustered-indexes>#</a></h3><p>Nevertheless, indexes have different architectures/indexing methods. And the
phonebook has a <strong>clustered index</strong>. Clustering means that the data is in a
distinct order, resulting the row data to be stored in order. If this confuses
you, think again about the phonebook - the records in the book are ordered
alphabetically. Regardless of how simple this might seem to you, it&rsquo;s a
clustered index. The way the data is ordered (clusters) makes it really easy to
search and find the needed phone number. So, a clustered index is an index
which <strong>physically</strong> orders the data (the actual bits on disk) in a certain
way, and when new data arrives it is saved in the same order.</p><p>A caveat with the clustered indexes is that <strong>only one</strong> can be created on a
given database table. That occurs due to their nature - they enforce a data
order. Also, clustered indexes increase the write time, because when new data
arrives, all of the data has to be rearranged. But on the bright side - they
can greatly increase the reading speed of the table.</p><p>To summarize - clustered indexes <strong>order</strong> the data physically (on disk) in
clusters.</p><h3 id=non-clustered-indexes>Non-clustered Indexes<a hidden class=anchor aria-hidden=true href=#non-clustered-indexes>#</a></h3><p>I know you guessed it - if there are clustered indexes, the opposite type has
to exist. And you are right, non-clustered indexes are a thing. They are the
type that we know to use most, but I guess not everyone knows how their
implementation works.</p><p>Non-clustered indexes are indexes that keep a separate ordering list that has
pointers to the physical rows. It&rsquo;s basically like a book index, it knows on
what page a certain chapter starts and ends. Now, unlike the clustered index, a
table can have many non-clustered indexes. But, the caveat with these indexes
is that each new index will increase the time it takes to write new records.</p><p>So, to summarize - non-clustered indexes <strong>do not order</strong> the data physically,
they just keep a list of the data order.</p><h2 id=indexing-effects>Indexing effects<a hidden class=anchor aria-hidden=true href=#indexing-effects>#</a></h2><p>So, after we covered the index architecture, we can explore how indexes work in
PostgreSQL. But first things first - let&rsquo;s play with some indexes.</p><p>Indexes in PostgreSQL are manipulated via a set of commands. For this example,
I will use a table with 1000 records, representing 1000 users. The table schema
will look like this:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>+-------------------------------------------------+
|             Table &#34;public.users&#34;                |
+-------------------------------------------------+
|  Column    |         Type           | Modifiers |
+------------+------------------------+-----------+
| id         | integer                | not null  |
| first_name | character varying(60)  |           |
| last_name  | character varying(60)  |           |
| email      | character varying(120) |           |
| gender     | character varying(6)   |           |
| created_at | date                   |           |
+-------------------------------------------------+
|Indexes:                                         |
|   &#34;users_pkey&#34; PRIMARY KEY, btree (id)          |
+-------------------------------------------------+
</code></pre></td></tr></table></div></div><p>If you want to follow along with this tutorial, you can easily create this
table with the following query:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>CREATE</span> <span style=color:#5f8700>TABLE</span> users (
  id <span style=color:#0087ff>INT</span> <span style=color:#5f8700>PRIMARY</span> <span style=color:#5f8700>KEY</span>,
  first_name <span style=color:#0087ff>VARCHAR</span>(<span style=color:#00afaf>60</span>),
  last_name <span style=color:#0087ff>VARCHAR</span>(<span style=color:#00afaf>60</span>),
  email <span style=color:#0087ff>VARCHAR</span>(<span style=color:#00afaf>120</span>),
  gender <span style=color:#0087ff>VARCHAR</span>(<span style=color:#00afaf>6</span>),
  created_at <span style=color:#0087ff>DATE</span>
);
</code></pre></td></tr></table></div></div><p>Having the table now, we can dump any amount of data we want. I will use the
following <a href=https://www.dropbox.com/s/poqimjc03506gac/dummy-users.csv>CSV
file</a>, which
contains 1000 user records. Dumping the data in the table is easy using
PostgreSQL&rsquo;s <code>COPY</code> command. If you are unfamiliar with the command, check out
<a href=/postgresql-copy>my post</a> which explains it in depth.</p><p>In our case, the actual command is:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>COPY</span> users (
  id,
  first_name,
  last_name,
  email,
  gender,
  created_at
)
<span style=color:#5f8700>FROM</span> <span style=color:#00afaf>&#39;/some/path/here/to/dummy-users.csv&#39;</span>
<span style=color:#5f8700>DELIMITER</span> <span style=color:#00afaf>&#39;,&#39;</span>;

<span style=color:#4e4e4e>/* Output: COPY 1000 */</span>
</code></pre></td></tr></table></div></div><p>Having the data in the database now, let&rsquo;s see the real impact of the indexes.</p><h3 id=analyzing-queries>Analyzing Queries<a hidden class=anchor aria-hidden=true href=#analyzing-queries>#</a></h3><p>PostgreSQL creates a query plan for each query it receives. When writing your
queries, it is very important to choose the best query plan, which adheres to
the query structure and the properties of the data. The query plans are really
easy to produce in PostgreSQL. It comes with a really neat command called
<code>EXPLAIN</code>, which shows the query plan, which contains all of the relevant info.</p><p>For example, let&rsquo;s see the query plan for the query that returns all of the
users:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>EXPLAIN</span> <span style=color:#5f8700>SELECT</span> * <span style=color:#5f8700>FROM</span> users;
</code></pre></td></tr></table></div></div><p>This will return the following output:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>                          QUERY PLAN
----------------------------------------------------------
 Seq Scan on users  (cost=0.00..20.00 rows=1000 width=48)
(1 row)
</code></pre></td></tr></table></div></div><p>As you can notice, this simple query requires a <strong>Seq</strong>uential <strong>Scan</strong>,
because there is no <code>WHERE</code> clause in it. This means that it will have to scan
each row of the table and return it.</p><p>In the parentheses we notice couple of values. The cost is a range of arbitrary
units (that closely resemble disk page fetches) - starting from the expected
before the output phase can begin, to the estimated total cost of this query.
Then, the numbers of rows output that were estimated by the query planner.
Last, the width represents the average width of the rows, in bytes.</p><p>Let&rsquo;s add a <code>WHERE</code> clause to the query:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>SELECT</span> * <span style=color:#5f8700>FROM</span> users <span style=color:#5f8700>WHERE</span> email = <span style=color:#00afaf>&#39;phughes5m@nbcnews.com&#39;</span>;
</code></pre></td></tr></table></div></div><p>The query will return the user whose email is <code>phughes5m@nbcnews.com</code> . Perfect.
Let&rsquo;s <code>EXPLAIN</code> the query, and see its query plan:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>EXPLAIN</span> <span style=color:#5f8700>SELECT</span> * <span style=color:#5f8700>FROM</span> users <span style=color:#5f8700>WHERE</span> email = <span style=color:#00afaf>&#39;phughes5m@nbcnews.com&#39;</span>;
</code></pre></td></tr></table></div></div><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>                          QUERY PLAN
----------------------------------------------------------
 Seq Scan on users  (cost=0.00..22.50 rows=1 width=48)
   Filter: ((email)::text = &#39;phughes5m@nbcnews.com&#39;::text)
</code></pre></td></tr></table></div></div><p>As you can see, although the <code>WHERE</code> clause was added, and the result set was
reduced to only one row, the time didn&rsquo;t go down. Actually, it increased. This
happens because the query will issue a <strong>Seq</strong>uential <strong>Scan</strong> on the table.
Let&rsquo;s see if adding an index to the <code>email</code> column will decrease the cost of
the query.</p><h3 id=adding-an-index>Adding an Index<a hidden class=anchor aria-hidden=true href=#adding-an-index>#</a></h3><p>Adding an index in PostgreSQL is done via the <code>CREATE INDEX</code> command:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>CREATE</span> <span style=color:#5f8700>INDEX</span> &lt;<span style=color:#5f8700>index</span> name&gt; <span style=color:#5f8700>ON</span> &lt;<span style=color:#5f8700>table</span> name&gt; <span style=color:#5f8700>USING</span> &lt;<span style=color:#5f8700>method</span>&gt;(&lt;<span style=color:#5f8700>column</span> name&gt;);
</code></pre></td></tr></table></div></div><p>Or, in our specific case:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>CREATE</span> <span style=color:#5f8700>INDEX</span> email_idx <span style=color:#5f8700>ON</span> users <span style=color:#5f8700>USING</span> btree(email);
</code></pre></td></tr></table></div></div><p>After we run this command, let&rsquo;s see a description of the table:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>              Table &#34;public.users&#34;
   Column   |          Type          | Modifiers
------------+------------------------+-----------
 id         | integer                | not null
 first_name | character varying(60)  |
 last_name  | character varying(60)  |
 email      | character varying(120) |
 gender     | character varying(6)   |
 created_at | date                   |
Indexes:
    &#34;users_pkey&#34; PRIMARY KEY, btree (id)
    &#34;email_idx&#34; btree (email)
</code></pre></td></tr></table></div></div><p>You can see in the &ldquo;Indexes&rdquo; section, the new index appears. After we added the
index, let&rsquo;s see the query plan for the <code>SELECT</code> query:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>EXPLAIN</span> <span style=color:#5f8700>SELECT</span> * <span style=color:#5f8700>FROM</span> users <span style=color:#5f8700>WHERE</span> email = <span style=color:#00afaf>&#39;phughes5m@nbcnews.com&#39;</span>;
</code></pre></td></tr></table></div></div><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>                              QUERY PLAN
----------------------------------------------------------------------
Index Scan using email_idx on users  (cost=0.28..8.29 rows=1 width=48)
  Index Cond: ((email)::text = &#39;phughes5m@nbcnews.com&#39;::text)
</code></pre></td></tr></table></div></div><p>Whoa! The projected query cost dropped from the original 22.50 to 8.29. So,
what changed? As you can notice, instead of a Sequential Scan, now PostgreSQL
will issue a <strong>Index Scan</strong>. We won&rsquo;t go into details here, because types and
approaches of scanning is topic for another blogpost. Simply said, Postgres
will issue a scan based on the indexes, therefore finding the exact location of
the user that we are looking for and returning it. This is a much cheaper
operation then using a sequential scan.</p><h2 id=sequential-isnt-always-the-worst>Sequential isn&rsquo;t Always the Worst<a hidden class=anchor aria-hidden=true href=#sequential-isnt-always-the-worst>#</a></h2><p>Let&rsquo;s see a different example. Let&rsquo;s say, we want to return all of the users
that have the <code>id</code> between 100 and 200:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>EXPLAIN</span> <span style=color:#5f8700>SELECT</span> * <span style=color:#5f8700>FROM</span> users <span style=color:#5f8700>WHERE</span> id &gt; <span style=color:#00afaf>100</span> <span style=color:#5f8700>AND</span> id &lt; <span style=color:#00afaf>200</span>;
</code></pre></td></tr></table></div></div><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>                          QUERY PLAN
----------------------------------------------------------------------
Index Scan using users_pkey on users (cost=0.28..11.28 rows=100 width=48)
  Index Cond: ((id &gt; 100) AND (id &lt; 200))
(2 rows)
</code></pre></td></tr></table></div></div><p>Looks about right, right? It uses a Index Scan, with an Index Cond(itional)
searching for all <code>id</code>s between 100 and 200. Good enough.</p><p>How about we try to return all users with <code>id</code>s between 200 and 800?</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#5f8700>EXPLAIN</span> <span style=color:#5f8700>SELECT</span> * <span style=color:#5f8700>FROM</span> users <span style=color:#5f8700>WHERE</span> id &gt; <span style=color:#00afaf>200</span> <span style=color:#5f8700>AND</span> id &lt; <span style=color:#00afaf>800</span>;
</code></pre></td></tr></table></div></div><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>                          QUERY PLAN
-------------------------------------------------------
Seq Scan on users  (cost=0.00..25.00 rows=600 width=48)
  Filter: ((id &gt; 200) AND (id &lt; 800))
(2 rows)
</code></pre></td></tr></table></div></div><p>Hold on, what happened here? Although there is an index on the primary key
column, PostgreSQL decides that doing a sequential scan on the <code>user</code> table is
more performant than an index scan. An index scan would require finding 600
indexes and returning each and every one of those records whose index were
found. On the other hand, a sequential scan would just go over each of the
records and filter out the unwanted rows.</p><p>So, although this is a contrived example, you can see in some situations an
index scan will not be as performant as a sequential scan.</p><h2 id=careful-usage>Careful Usage<a hidden class=anchor aria-hidden=true href=#careful-usage>#</a></h2><p>Indexes are a powerful way to improve the performance of your tables, but they
have to be used carefully. Often, indexes can actually stand in the way of your
queries, if not used properly.</p><p>Next time we will see what are the index types in PostgreSQL and how we can
leverage them.</p><section class=subscribe><b>Liked this article?</b>
You can <a href=https://www.buymeacoffee.com/ieftimov>buy me a coffee</a>.
Or simply <a href=/newsletter>subscribe to my
newsletter</a> and get my fresh posts in your inbox. It's short and sweet,
going out monthly to over 1,000 subscribers.</section></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/first-principles/>first principles</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/postgresql-indexes-btree/><span class=title>« Prev Page</span><br><span>PostgreSQL Indexes: B-Tree</span></a>
<a class=next href=https://ieftimov.com/post/build-weather-widget-rxjs/><span class=title>Next Page »</span><br><span>Building a Weather Widget using RxJS</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: First Principles on twitter" href="https://twitter.com/intent/tweet/?text=PostgreSQL%20Indexes%3a%20First%20Principles&url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-first-principles%2f&hashtags=firstprinciples"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: First Principles on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-first-principles%2f&title=PostgreSQL%20Indexes%3a%20First%20Principles&summary=PostgreSQL%20Indexes%3a%20First%20Principles&source=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-first-principles%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: First Principles on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-first-principles%2f&title=PostgreSQL%20Indexes%3a%20First%20Principles"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: First Principles on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-first-principles%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: First Principles on whatsapp" href="https://api.whatsapp.com/send?text=PostgreSQL%20Indexes%3a%20First%20Principles%20-%20https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-first-principles%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share PostgreSQL Indexes: First Principles on telegram" href="https://telegram.me/share/url?text=PostgreSQL%20Indexes%3a%20First%20Principles&url=https%3a%2f%2fieftimov.com%2fpost%2fpostgresql-indexes-first-principles%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>