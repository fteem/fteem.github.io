<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Create and manage MacOS LaunchAgents using Go | Ilija Eftimov ⚡️</title><meta name=keywords content="launchagent,launchd,launchctl,lpc,signals"><meta name=description content="If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don&rsquo;t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.
For those unfamiliar, a daemon is a program running in the background without requiring user input. A typical daemon might, for instance, perform daily maintenance tasks or scan a device for malware when connected."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Create and manage MacOS LaunchAgents using Go"><meta property="og:description" content="If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don&rsquo;t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.
For those unfamiliar, a daemon is a program running in the background without requiring user input. A typical daemon might, for instance, perform daily maintenance tasks or scan a device for malware when connected."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/"><meta property="og:image" content="https://ieftimov.com/cards/create-manage-macos-launchd-agents-golang.png"><meta property="article:section" content="posts"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/create-manage-macos-launchd-agents-golang.png"><meta name=twitter:title content="Create and manage MacOS LaunchAgents using Go"><meta name=twitter:description content="If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don&rsquo;t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.
For those unfamiliar, a daemon is a program running in the background without requiring user input. A typical daemon might, for instance, perform daily maintenance tasks or scan a device for malware when connected."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Create and manage MacOS LaunchAgents using Go","item":"https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Create and manage MacOS LaunchAgents using Go","name":"Create and manage MacOS LaunchAgents using Go","description":"If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don\u0026rsquo;t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.\nFor those unfamiliar, a daemon is a program running in the background without requiring user input. A typical daemon might, for instance, perform daily maintenance tasks or scan a device for malware when connected.","keywords":["launchagent","launchd","launchctl","lpc","signals"],"articleBody":"If you have ever tried writing a daemon for MacOS you have met with launchd. For those that don’t have the experience, think of it as a framework for starting, stopping and managing daemons, applications, processes, and scripts. If you have any *nix experience the word daemon should not be too alien to you.\nFor those unfamiliar, a daemon is a program running in the background without requiring user input. A typical daemon might, for instance, perform daily maintenance tasks or scan a device for malware when connected.\nThis post is aimed at folks that know a little bit about what daemons are, what is the common way of using them and know a bit about Go. Also, if you have ever written a daemon for any other *nix system, you will have a good idea of what we are going to talk here. If you are an absolute beginner in Go or systems this might prove to be an overwhelming article. Still, feel free to give it a shot and let me know how it goes.\nIf you ever find yourself wanting to write a MacOS daemon with Go you would like to know most of the stuff we are going to talk about in this article. Without further ado, let’s dive in.\nWhat is launchd and how it works? launchd is a unified service-management framework, that starts, stops and manages daemons, applications, processes, and scripts in MacOS.\nOne of its key features is that it differentiates between agents and daemons. In launchd land, an agent runs on behalf of the logged in user while a daemon runs on behalf of the root user or any specified user.\nDefining agents and daemons An agent/daemon is defined in an XML file, which states the properties of the program that will execute, among a list of other properties. Another aspect to keep in mind is that launchd decides if a program will be treated as a daemon or an agent by where the program XML is located.\nOver at launchd.info, there’s a simple table that shows where you would (or not) place your program’s XML:\n+----------------+-------------------------------+----------------------------------------------------+ | Type | Location | Run on behalf of | +----------------+-------------------------------+----------------------------------------------------+ | User Agents | ~/Library/LaunchAgents | Currently logged in user | | Global Agents | /Library/LaunchAgents | Currently logged in user | | Global Daemons | /Library/LaunchDaemons | root or the user specified with the key 'UserName' | | System Agents | /System/Library/LaunchAgents | Currently logged in user | | System Daemons | /System/Library/LaunchDaemons | root or the user specified with the key 'UserName' | +----------------+-------------------------------+----------------------------------------------------+ This means that when we set our XML file in, for example, the /Library/LaunchAgents path our process will be treated as a global agent. The main difference between the daemons and agents is that LaunchDaemons will run as root, and are generally background processes. On the other hand, LaunchAgents are jobs that will run as a user or in the context of userland. These may be scripts or other foreground items and they also have access to the MacOS UI (e.g. you can send notifications, control the windows, etc.)\nSo, how do we define an agent? Let’s take a look at a simple XML file that launchd understands:\n    version=\"1.0\"  Label com.example.app Program /Users/Me/Scripts/cleanup.sh RunAtLoad    The XML is quite self-explanatory, unless it’s the first time you are seeing an XML file. The file has three main properties, with values. In fact, if you take a better look you will see the dict keyword which means dictionary. This actually means that the XML represents a key-value structure, so in Go it would look like:\nmap[string]string{ \"Label\": \"com.example.app\", \"Program\": \"/Users/Me/Scripts/cleanup.sh\", \"RunAtLoad\": \"true\", } Let’s look at each of the keys:\n Label - The job definition or the name of the job. This is the unique identifier for the job within the launchd instance. Usually, the label (and hence the name) is written in Reverse domain name notation. Program - This key defines what the job should start, in our case a script with the path /Users/Me/Scripts/cleanup.sh. RunAtLoad - This key specifies when the job should be run, in this case right after it’s loaded.  As you can see, the keys used in this XML file are quite self-explanatory. This is the case for the remaining 30-40 keys that launchd supports. Last but not least these files although have an XML syntax, in fact, they have a .plist extension (which means Property List). Makes a lot of sense, right?\nlaunchd v.s. launchctl Before we continue with our little exercise of creating daemons/agents with Go, let’s first see how launchd allows us to control these jobs. While launchd’s job is to boot the system and to load and maintain services, there is a different command used for jobs management - launchctl. With launchd facilitating jobs, the control of services is centralized in the launchctl command.\nlaunchctl has a long list of subcommands that we can use. For example, loading or unloading a job is done via:\nlaunchctl unload/load ~/Library/LaunchAgents/com.example.app.plist Or, starting/stopping a job is done via:\nlaunchctl start/stop ~/Library/LaunchAgents/com.example.app.plist To get any confusion out of the way, load and start are different. While start only starts the agent/daemon, load loads the job and it might also start it if the job is configured to run on load. This is achieved by setting the RunAtLoad property in the property list XML of the job:\n    version=\"1.0\"  Label com.example.app Program /Users/Me/Scripts/cleanup.sh RunAtLoad   If you would like to see what other commands launchctl supports, you can run man launchctl in your terminal and see the options in detail.\nAutomating with Go After getting the basics of launchd and launctl out of the way, why don’t we see how we can add an agent to any Go package? For our example, we are going to write a simple way of plugging in a launchd agent for any of your Go packages.\nAs we already established before, launchd speaks in XML. Or, rather, it understands XML files, called property lists (or .plist). This means, for our Go package to have an agent running on MacOS, it will need to tell launchd “hey, launchd, run this thing!”. And since launch speaks only in .plist, that means our package needs to be capable of generating XML files.\nTemplates in Go While one could have a hardcoded .plist file in their project and copy it across to the ~/Library/LaunchAgents path, a more programmatical way to do this would be to use a template to generate these XML files. The good thing is Go’s standard library has us covered - the text/template package (docs) does exactly what we need.\nIn a nutshell, text/template implements data-driven templates for generating textual output. Or in other words, you give it a template and a data structure, it will mash them up together and produce a nice and clean text file. Perfect.\nLet’s say the .plist we need to generate in our case is the following:\n   version='1.0'  LabelTicker Program/usr/local/bin/ticker StandardOutPath/tmp/ticker.out.log StandardErrorPath/tmp/ticker.err.log KeepAlive RunAtLoad   We want to keep it quite simple in our little exercise. It will contain only six properties: Label, Program, StandardOutPath, StandardErrorPath, KeepAlive and RunAtLoad. To generate such a XML, its template would look something like this:\n   version='1.0'  Label{{.Label}} Program{{.Program}} StandardOutPath/tmp/{{.Label}}.out.log StandardErrorPath/tmp/{{.Label}}.err.log KeepAlive RunAtLoad   As you can see, the difference between the two XMLs is that the second one has the double curly braces with expressions in them in places where the first XML has some sort of a value. These are called “actions”, which can be data evaluations or control structures and are delimited by “{{” and “}}”. Any of the text outside actions is copied to the output untouched.\nInjecting your data Now that we have our template with its glorious XML and curly braces (or actions), let’s see how we can inject our data into it. Since things are generally simple in Go, especially when it comes to its standard library, you should not worry - this will be easy!\nTo keep thing simple, we will store the whole XML template in a plain old string. Yes, weird, I know. The best way would be to store it in a file and read it from there, or embed it in the binary itself, but in our little example let’s keep it simple:\n// template.go package main func Template() string { return `    version='1.0'  Label{{.Label}} Program{{.Program}} StandardOutPath/tmp/{{.Label}}.out.log StandardErrorPath/tmp/{{.Label}}.err.log KeepAlive RunAtLoad   ` } And the program that will use our little template function:\n// main.go package main import ( \"log\" \"os\" \"text/template\" ) func main() { data := struct { Label string Program string KeepAlive bool RunAtLoad bool }{ Label: \"ticker\", Program: \"/usr/local/bin/ticker\", KeepAlive: true, RunAtLoad: true, } t := template.Must(template.New(\"launchdConfig\").Parse(Template())) err := t.Execute(os.Stdout, data) if err != nil { log.Fatalf(\"Template generation failed: %s\", err) } } So, what happens there, in the main function? It’s actually quite simple:\n We declare a small struct, which has only the properties that will be needed in the template, and we immediately initialize it with the values for our program. We build a new template, using the template.New function, with the name launchdConfig. Then, we invoke the Parse function on it, which takes the XML template as an argument. We invoke the template.Must function, which takes our built template as argument. From the documentation, template.Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. Actually, template.Must is built to, in a way, validate if the template can be understood by the text/template package. Finally, we invoke Execute on our built template, which takes a data structure and applies its attributes to the actions in the template. Then it sends the output to os.Stdout, which does the trick for our example. Of course, the output can be sent to any struct that implements the io.Writer interface, like a file (os.File).  Make and load my .plist Instead of sending all this nice XML to standard out, let’s throw in an open file descriptor to the Execute function and finally save our .plist file in ~/Library/LaunchAgents. There are a couple of main points we need to change.\nFirst, getting the location of the binary. Since it’s a Go binary, and we will install it via go install, we can assume that the path will be at $GOPATH/bin. Second, since we don’t know the actual $HOME of the current user, we will have to get it through the environment. Both of these can be done via os.Getenv (docs) which takes a variable name and returns its value.\n// main.go package main import ( \"log\" \"os\" \"text/template\" ) func main() { data := struct { Label string Program string KeepAlive bool RunAtLoad bool }{ Label: \"com.ieftimov.ticker\", // Reverse-DNS naming convention \tProgram: fmt.Sprintf(\"%s/bin/ticker\", os.Getenv(\"GOPATH\")), KeepAlive: true, RunAtLoad: true, } plistPath := fmt.Sprintf(\"%s/Library/LaunchAgents/%s.plist\", os.Getenv(\"HOME\"), data.Label) f, err := os.Open(plistPath) t := template.Must(template.New(\"launchdConfig\").Parse(Template())) err := t.Execute(f, data) if err != nil { log.Fatalf(\"Template generation failed: %s\", err) } } That’s about it. The first part, about setting the correct Program property, is done by concatenating the name of the program and $GOPATH:\nfmt.Sprintf(\"%s/bin/ticker\", os.Getenv(\"GOPATH\")) // Output: /Users//go/bin/ticker  The second part is slightly more complex, and it’s done by concatenating three strings, the $HOME environment variable, the Label property of the program and the /Library/LaunchAgents string:\nfmt.Sprintf(\"%s/Library/LaunchAgents/%s.plist\", os.Getenv(\"HOME\"), data.Label) // Output: /Users//Library/LaunchAgents/com.ieftimov.ticker.plist  By having these two paths, opening the file and writing to it is very trivial - we open the file via os.Open and we pass in the os.File structure to t.Execute which writes to the file descriptor.\nWhat about the Launch Agent? We will keep this one simple as well. Let’s throw in a command to our package, make it installable via go install (not that there’s much to it) and make it runnable by our .plist file:\n// cmd/ticker/main.go package ticker import ( \"time\" \"fmt\" ) func main() { for range time.Tick(30 * time.Second) { fmt.Println(\"tick!\") } } This the ticker program will use time.Tick, to execute an action every 30 seconds. Since this will be an infinite loop, launchd will kick off the program on boot (because RunAtLoad is set to true in the .plist file) and will keep it running. But, to make the program controllable from the operating system, we need to make the program react to some OS signals, like SIGINT or SIGTERM.\nUnderstanding and handling OS signals While there’s quite a bit to be learned about OS signals, in our example we will scratch a bit off the surface. (If you know a lot about inter-process communication this might be too much of an oversimplification to you - and I apologize up front. Feel free to drop some links on the topic in the comments so others can learn more!)\nThe best way to think about a signal is that it’s a message from the operating system or another process, to a process. It is an asynchronous notification sent to a process or to a specific thread within the same process to notify it of an event that occurred.\nThere are quite a bit of various signals that can be sent to a process (or a thread), like SIGKILL (which kills a process), SIGSTOP (stop), SIGTERM (termination), SIGILL and so on and so forth. There’s an exhaustive list of signal types on Wikipedia’s page on signals.\nTo get back to launchd, if we look at its documentation about stopping a job we will notice the following:\n Stopping a job will send the signal SIGTERM to the process. Should this not stop the process launchd will wait ExitTimeOut seconds (20 seconds by default) before sending SIGKILL.\n Pretty self-explanatory, right? We need to handle one signal - SIGTERM. Why not SIGKILL? Because SIGKILL is a special signal that cannot be caught - it kills the process without any chance for a graceful shutdown, no questions asked. That’s why there’s a termination signal and a “kill” signal.\nLet’s throw in a bit of signal handling in our code, so our program knows that it needs to exit when it gets told to do so:\npackage main import ( \"fmt\" \"os\" \"os/signal\" \"syscall\" \"time\" ) func main() { sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) go func() { sigs os.Exit(0) }() for range time.Tick(30 * time.Second) { fmt.Println(\"tick!\") } } In the new version, the agent program has two new packages imported: os/signal and syscall. os/signal implements access to incoming signals, that are primarily used on Unix-like systems. Since in this article we are specifically interested in MacOS, this is exactly what we need.\nPackage syscall contains an interface to the low-level operating system primitives. An important note about syscall is that it is locked down since Go v1.4. This means that any code outside of the standard library that uses the syscall package should be migrated to use the new golang.org/x/sys package. Since we are using only the signals constants of syscall we can get away with this.\n(If you want to read more about the package lockdown, you can see the rationale on locking it down by the Go team and the new golang.org/s/sys package.)\nHaving the basics of the packages out of the way, let’s go step by step through the new lines of code added:\n We make a buffered channel of type os.Signal, with a size of 1. os.Signal is a type that represents an operating system signal. We call signal.Notify with the new channel as an argument, plus syscall.SIGINT and syscall.SIGTERM. This function states “when the OS sends a SIGINT or a SIGTERM signal to this program, send the signal to the channel”. This allows us to somehow handle the sent OS signal. The new goroutine that we spawn waits for any of the signals to arrive through the channel. Since we know that any of the signals that will arrive are about shutting down the program, after receiving any signal we use os.Exit(0) (docs) to gracefully stop the program. One caveat here is that if we had any deferred calls they would not be run.  Now launchd can run the agent program and we can load and unload, start and stop it using launchctl.\nPutting it all together Now that we have all the pieces ready, we need to put them together to a good use. Our application will consist of two binaries - a CLI tool and an agent (daemon). Both of the programs will be stored in separate subdirectories of the cmd directory.\nThe CLI tool:\n// cmd/cli/main.go package main import ( \"log\" \"os\" \"text/template\" ) func main() { data := struct { Label string Program string KeepAlive bool RunAtLoad bool }{ Label: \"com.ieftimov.ticker\", // Reverse-DNS naming convention \tProgram: fmt.Sprintf(\"%s/bin/ticker\", os.Getenv(\"GOPATH\")), KeepAlive: true, RunAtLoad: true, } plistPath := fmt.Sprintf(\"%s/Library/LaunchAgents/%s.plist\", os.Getenv(\"HOME\"), data.Label) f, err := os.Open(plistPath) t := template.Must(template.New(\"launchdConfig\").Parse(Template())) err := t.Execute(f, data) if err != nil { log.Fatalf(\"Template generation failed: %s\", err) } } And the ticker program:\n// cmd/ticker/main.go package main import ( \"fmt\" \"os\" \"os/signal\" \"syscall\" \"time\" ) func main() { sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) go func() { sigs os.Exit(0) }() for range time.Tick(30 * time.Second) { fmt.Println(\"tick!\") } } To install them both, we need to run go install ./... in the project root. The command will install all the sub-packages that are located within the project. This will leave us with two available binaries, installed in the $GOPATH/bin path.\nTo install our launch agent, we need to run only the CLI tool, via the cli command. This will generate the .plist file and place it in the ~/Library/LaunchAgents path. We don’t need to touch the ticker binary - that one will be managed by launchd.\nTo load the newly created .plist file, we need to run:\nlaunchctl load ~/Library/LaunchAgents/com.ieftimov.ticker.plist When we run it, we will not see anything immediately, but after 30 seconds the ticker will add a tick! line in /tmp/ticker.out.log. We can tail the file to see the new lines being added. If we want to unload the agent, we can use:\nlaunchctl unload ~/Library/LaunchAgents/com.ieftimov.ticker.plist This will unload the launch agent and will stop the ticker from running. Remember the signal handling we added? This is the case where it’s being used! Also, we could have automated the (un)loading of the file via the CLI tool but for simplicity, we left it out. You can try to improve the CLI tool by making it a bit smarter with subcommands and flags, as a follow-up exercise from this tutorial.\nFinally, if you decide to completely delete the launch agent, you can remove the .plist file:\nrm ~/Library/LaunchAgents/com.ieftimov.ticker.plist In closing As part of this (quite long!) article, we saw how we can work with launchd and Golang. We took a detour, like learning about launchd and launchctl, generating XML files using the text/template package, we took a look at OS signals and how we can gracefully shutdown a Go program by handling the SIGINT and SIGTERM signals. There was quite a bit to learn and see, but we got to the end.\nOf course, we only scratched the surface with this article. For example, launchd is quite an interesting tool. You can use it also like crontab because it allows running programs at explicit time/date combinations or on specific days. Or, for example, the XML template can be embedded in the program binary using tools like go-bindata, instead of hardcoding it in a function. Also, you explore more about signals, how they work and how Go implements these low-level primitives so you can use them with ease in your programs. The options are plenty, feel free to explore!\nLiked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to +1000 of other engineers.\n    ","wordCount":"3384","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Create and manage MacOS LaunchAgents using Go</h1><div class=post-meta>January 30, 2018&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#what-is-launchd-and-how-it-works aria-label="What is launchd and how it works?">What is <code>launchd</code> and how it works?</a><ul><li><a href=#defining-agents-and-daemons aria-label="Defining agents and daemons">Defining agents and daemons</a></li></ul></li><li><a href=#launchd-vs-launchctl aria-label="launchd v.s. launchctl"><code>launchd</code> v.s. <code>launchctl</code></a></li><li><a href=#automating-with-go aria-label="Automating with Go">Automating with Go</a><ul><li><a href=#templates-in-go aria-label="Templates in Go">Templates in Go</a></li><li><a href=#injecting-your-data aria-label="Injecting your data">Injecting your data</a></li><li><a href=#make-and-load-my-plist aria-label="Make and load my .plist">Make and load my <code>.plist</code></a></li></ul></li><li><a href=#what-about-the-launch-agent aria-label="What about the Launch Agent?">What about the Launch Agent?</a><ul><li><a href=#understanding-and-handling-os-signals aria-label="Understanding and handling OS signals">Understanding and handling OS signals</a></li></ul></li><li><a href=#putting-it-all-together aria-label="Putting it all together">Putting it all together</a></li><li><a href=#in-closing aria-label="In closing">In closing</a></li></ul></div></details></div><div class=post-content><p>If you have ever tried writing a daemon for MacOS you have met with <code>launchd</code>.
For those that don&rsquo;t have the experience, think of it as a framework for
starting, stopping and managing daemons, applications, processes, and scripts.
If you have any *nix experience the word daemon should not be too alien to
you.</p><p>For those unfamiliar, a daemon is a program running in the background without
requiring user input. A typical daemon might, for instance, perform daily
maintenance tasks or scan a device for malware when connected.</p><p>This post is aimed at folks that know a little bit about what daemons are, what
is the common way of using them and know a bit about Go. Also, if you have ever
written a daemon for any other *nix system, you will have a good idea of what
we are going to talk here. If you are an absolute beginner in Go or systems
this might prove to be an overwhelming article. Still, feel free to give it a
shot and let me know how it goes.</p><p>If you ever find yourself wanting to write a MacOS daemon with Go you would
like to know most of the stuff we are going to talk about in this article.
Without further ado, let&rsquo;s dive in.</p><h2 id=what-is-launchd-and-how-it-works>What is <code>launchd</code> and how it works?<a hidden class=anchor aria-hidden=true href=#what-is-launchd-and-how-it-works>#</a></h2><p><code>launchd</code> is a unified service-management framework, that starts, stops and
manages daemons, applications, processes, and scripts in MacOS.</p><p>One of its key features is that it differentiates between agents and daemons.
In <code>launchd</code> land, an agent runs on behalf of the logged in user while a daemon
runs on behalf of the root user or any specified user.</p><h3 id=defining-agents-and-daemons>Defining agents and daemons<a hidden class=anchor aria-hidden=true href=#defining-agents-and-daemons>#</a></h3><p>An agent/daemon is defined in an XML file, which states the properties of the
program that will execute, among a list of other properties. Another aspect to
keep in mind is that <code>launchd</code> decides if a program will be treated as a daemon
or an agent by where the program XML is located.</p><p>Over at <a href=https://launchd.info>launchd.info</a>, there&rsquo;s a simple table that shows
where you would (or not) place your program&rsquo;s XML:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>+----------------+-------------------------------+----------------------------------------------------+
| Type           | Location                      | Run on behalf of                                   |
+----------------+-------------------------------+----------------------------------------------------+
| User Agents    | ~/Library/LaunchAgents        | Currently logged in user                           |
| Global Agents  | /Library/LaunchAgents         | Currently logged in user                           |
| Global Daemons | /Library/LaunchDaemons        | root or the user specified with the key &#39;UserName&#39; |
| System Agents  | /System/Library/LaunchAgents  | Currently logged in user                           |
| System Daemons | /System/Library/LaunchDaemons | root or the user specified with the key &#39;UserName&#39; |
+----------------+-------------------------------+----------------------------------------------------+</code></pre></div><p>This means that when we set our XML file in, for example, the
<code>/Library/LaunchAgents</code> path our process will be treated as a global agent. The
main difference between the daemons and agents is that LaunchDaemons will run
as root, and are generally background processes. On the other hand,
LaunchAgents are jobs that will run as a user or in the context of userland.
These may be scripts or other foreground items and they also have access to the
MacOS UI (e.g. you can send notifications, control the windows, etc.)</p><p>So, how do we define an agent? Let&rsquo;s take a look at a simple XML file that
<code>launchd</code> understands:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#586e75>&lt;!--- Example blatantly ripped off from http://www.launchd.info/ --&gt;</span>
<span style=color:#719e07>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style=color:#719e07>&lt;!DOCTYPE plist PUBLIC &#34;-//Apple//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&gt;</span>
<span style=color:#268bd2>&lt;plist</span> version=<span style=color:#2aa198>&#34;1.0&#34;</span><span style=color:#268bd2>&gt;</span>
	<span style=color:#268bd2>&lt;dict&gt;</span>
		<span style=color:#268bd2>&lt;key&gt;</span>Label<span style=color:#268bd2>&lt;/key&gt;</span>
		<span style=color:#268bd2>&lt;string&gt;</span>com.example.app<span style=color:#268bd2>&lt;/string&gt;</span>
		<span style=color:#268bd2>&lt;key&gt;</span>Program<span style=color:#268bd2>&lt;/key&gt;</span>
		<span style=color:#268bd2>&lt;string&gt;</span>/Users/Me/Scripts/cleanup.sh<span style=color:#268bd2>&lt;/string&gt;</span>
		<span style=color:#268bd2>&lt;key&gt;</span>RunAtLoad<span style=color:#268bd2>&lt;/key&gt;</span>
		<span style=color:#268bd2>&lt;true/&gt;</span>
	<span style=color:#268bd2>&lt;/dict&gt;</span>
<span style=color:#268bd2>&lt;/plist&gt;</span></code></pre></div><p>The XML is quite self-explanatory, unless it&rsquo;s the first time you are seeing an
XML file. The file has three main properties, with values. In fact, if you take
a better look you will see the <code>dict</code> keyword which means <code>dictionary</code>. This
actually means that the XML represents a key-value structure, so in Go it would
look like:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>map</span>[<span style=color:#dc322f>string</span>]<span style=color:#dc322f>string</span>{
        <span style=color:#2aa198>&#34;Label&#34;</span>:     <span style=color:#2aa198>&#34;com.example.app&#34;</span>,
        <span style=color:#2aa198>&#34;Program&#34;</span>:   <span style=color:#2aa198>&#34;/Users/Me/Scripts/cleanup.sh&#34;</span>,
        <span style=color:#2aa198>&#34;RunAtLoad&#34;</span>: <span style=color:#2aa198>&#34;true&#34;</span>,
}</code></pre></div><p>Let’s look at each of the keys:</p><ol><li><code>Label</code> - The job definition or the name of the job. This is the unique
identifier for the job within the <code>launchd</code> instance. Usually, the label
(and hence the name) is written in <a href=en.wikipedia.org/wiki/Reverse_domain_name_notation>Reverse domain name
notation</a>.</li><li><code>Program</code> - This key defines what the job should start, in our case a script
with the path <code>/Users/Me/Scripts/cleanup.sh</code>.</li><li><code>RunAtLoad</code> - This key specifies when the job should be run, in this case
right after it&rsquo;s loaded.</li></ol><p>As you can see, the keys used in this XML file are quite self-explanatory. This
is the case for the remaining 30-40 keys that <code>launchd</code> supports. Last but not
least these files although have an XML syntax, in fact, they have a <code>.plist</code>
extension (which means <code>Property List</code>). Makes a lot of sense, right?</p><h2 id=launchd-vs-launchctl><code>launchd</code> v.s. <code>launchctl</code><a hidden class=anchor aria-hidden=true href=#launchd-vs-launchctl>#</a></h2><p>Before we continue with our little exercise of creating daemons/agents with Go,
let&rsquo;s first see how <code>launchd</code> allows us to control these jobs. While
<code>launchd</code>&rsquo;s job is to boot the system and to load and maintain services, there
is a different command used for jobs management - <code>launchctl</code>. With <code>launchd</code>
facilitating jobs, the control of services is centralized in the <code>launchctl</code>
command.</p><p><code>launchctl</code> has a long list of subcommands that we can use. For example,
loading or unloading a job is done via:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>launchctl unload/load ~/Library/LaunchAgents/com.example.app.plist</code></pre></div><p>Or, starting/stopping a job is done via:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>launchctl start/stop ~/Library/LaunchAgents/com.example.app.plist</code></pre></div><p>To get any confusion out of the way, <code>load</code> and <code>start</code> are different. While
<code>start</code> only starts the agent/daemon, <code>load</code> loads the job and it might also
start it if the job is configured to run on load. This is achieved by setting
the <code>RunAtLoad</code> property in the property list XML of the job:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#586e75>&lt;!--- Example blatantly ripped off from http://www.launchd.info/ --&gt;</span>
<span style=color:#719e07>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style=color:#719e07>&lt;!DOCTYPE plist PUBLIC &#34;-//Apple//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&gt;</span>
<span style=color:#268bd2>&lt;plist</span> version=<span style=color:#2aa198>&#34;1.0&#34;</span><span style=color:#268bd2>&gt;</span>
	<span style=color:#268bd2>&lt;dict&gt;</span>
		<span style=color:#268bd2>&lt;key&gt;</span>Label<span style=color:#268bd2>&lt;/key&gt;</span>
		<span style=color:#268bd2>&lt;string&gt;</span>com.example.app<span style=color:#268bd2>&lt;/string&gt;</span>
		<span style=color:#268bd2>&lt;key&gt;</span>Program<span style=color:#268bd2>&lt;/key&gt;</span>
		<span style=color:#268bd2>&lt;string&gt;</span>/Users/Me/Scripts/cleanup.sh<span style=color:#268bd2>&lt;/string&gt;</span>

		<span style=color:#268bd2>&lt;key&gt;</span>RunAtLoad<span style=color:#268bd2>&lt;/key&gt;&lt;true/&gt;</span>

	<span style=color:#268bd2>&lt;/dict&gt;</span>
<span style=color:#268bd2>&lt;/plist&gt;</span></code></pre></div><p>If you would like to see what other commands <code>launchctl</code> supports, you can run
<code>man launchctl</code> in your terminal and see the options in detail.</p><h2 id=automating-with-go>Automating with Go<a hidden class=anchor aria-hidden=true href=#automating-with-go>#</a></h2><p>After getting the basics of <code>launchd</code> and <code>launctl</code> out of the way, why don&rsquo;t
we see how we can add an agent to any Go package? For our example, we are going
to write a simple way of plugging in a <code>launchd</code> agent for any of your Go
packages.</p><p>As we already established before, <code>launchd</code> speaks in XML. Or, rather, it
understands XML files, called <em>property lists</em> (or <code>.plist</code>). This means, for
our Go package to have an agent running on MacOS, it will need to tell
<code>launchd</code> &ldquo;hey, <code>launchd</code>, run this thing!&rdquo;. And since <code>launch</code> speaks only in
<code>.plist</code>, that means our package needs to be capable of generating XML files.</p><h3 id=templates-in-go>Templates in Go<a hidden class=anchor aria-hidden=true href=#templates-in-go>#</a></h3><p>While one could have a hardcoded <code>.plist</code> file in their project and copy it
across to the <code>~/Library/LaunchAgents</code> path, a more programmatical way to do
this would be to use a template to generate these XML files. The good thing is
Go&rsquo;s standard library has us covered - the <code>text/template</code> package
(<a href=https://godoc.org/text/template>docs</a>) does exactly what we need.</p><p>In a nutshell, <code>text/template</code> implements data-driven templates for generating
textual output. Or in other words, you give it a template and a data structure,
it will mash them up together and produce a nice and clean text file. Perfect.</p><p>Let&rsquo;s say the <code>.plist</code> we need to generate in our case is the following:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#719e07>&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span>
<span style=color:#719e07>&lt;!DOCTYPE plist PUBLIC \&#34;-//Apple Computer//DTD PLIST 1.0//EN\&#34; \&#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\&#34; &gt;</span>
<span style=color:#268bd2>&lt;plist</span> version=<span style=color:#2aa198>&#39;1.0&#39;</span><span style=color:#268bd2>&gt;</span>
  <span style=color:#268bd2>&lt;dict&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>Label<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>Ticker<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>Program<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>/usr/local/bin/ticker<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>StandardOutPath<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>/tmp/ticker.out.log<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>StandardErrorPath<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>/tmp/ticker.err.log<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>KeepAlive<span style=color:#268bd2>&lt;/key&gt;&lt;true/&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>RunAtLoad<span style=color:#268bd2>&lt;/key&gt;&lt;true/&gt;</span>
  <span style=color:#268bd2>&lt;/dict&gt;</span>
<span style=color:#268bd2>&lt;/plist&gt;</span></code></pre></div><p>We want to keep it quite simple in our little exercise. It will contain only
six properties: <code>Label</code>, <code>Program</code>, <code>StandardOutPath</code>, <code>StandardErrorPath</code>,
<code>KeepAlive</code> and <code>RunAtLoad</code>. To generate such a XML, its template would look
something like this:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#719e07>&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span>
<span style=color:#719e07>&lt;!DOCTYPE plist PUBLIC \&#34;-//Apple Computer//DTD PLIST 1.0//EN\&#34; \&#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\&#34; &gt;</span>
<span style=color:#268bd2>&lt;plist</span> version=<span style=color:#2aa198>&#39;1.0&#39;</span><span style=color:#268bd2>&gt;</span>
  <span style=color:#268bd2>&lt;dict&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>Label<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>{{.Label}}<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>Program<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>{{.Program}}<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>StandardOutPath<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>/tmp/{{.Label}}.out.log<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>StandardErrorPath<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>/tmp/{{.Label}}.err.log<span style=color:#268bd2>&lt;/string&gt;</span>
    <span style=color:#268bd2>&lt;key&gt;</span>KeepAlive<span style=color:#268bd2>&lt;/key&gt;</span>&lt;{{.KeepAlive}}/&gt;
    <span style=color:#268bd2>&lt;key&gt;</span>RunAtLoad<span style=color:#268bd2>&lt;/key&gt;</span>&lt;{{.RunAtLoad}}/&gt;
  <span style=color:#268bd2>&lt;/dict&gt;</span>
<span style=color:#268bd2>&lt;/plist&gt;</span></code></pre></div><p>As you can see, the difference between the two XMLs is that the second one has
the double curly braces with expressions in them in places where the first XML
has some sort of a value. These are called &ldquo;actions&rdquo;, which can be data
evaluations or control structures and are delimited by &ldquo;{{&rdquo; and &ldquo;}}&rdquo;. Any of the
text outside actions is copied to the output untouched.</p><h3 id=injecting-your-data>Injecting your data<a hidden class=anchor aria-hidden=true href=#injecting-your-data>#</a></h3><p>Now that we have our template with its glorious XML and curly braces
(or actions), let&rsquo;s see how we can inject our data into it. Since things are
generally simple in Go, especially when it comes to its standard library, you
should not worry - this will be easy!</p><p>To keep thing simple, we will store the whole XML template in a plain old string.
Yes, weird, I know. The best way would be to store it in a file and
read it from there, or embed it in the binary itself, but in our little example
let&rsquo;s keep it simple:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml>// template.go
package main

func Template() string {
	return `
<span style=color:#719e07>&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span>
 <span style=color:#719e07>&lt;!DOCTYPE plist PUBLIC \&#34;-//Apple Computer//DTD PLIST 1.0//EN\&#34; \&#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\&#34; &gt;</span>
 <span style=color:#268bd2>&lt;plist</span> version=<span style=color:#2aa198>&#39;1.0&#39;</span><span style=color:#268bd2>&gt;</span>
   <span style=color:#268bd2>&lt;dict&gt;</span>
     <span style=color:#268bd2>&lt;key&gt;</span>Label<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>{{.Label}}<span style=color:#268bd2>&lt;/string&gt;</span>
     <span style=color:#268bd2>&lt;key&gt;</span>Program<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>{{.Program}}<span style=color:#268bd2>&lt;/string&gt;</span>
     <span style=color:#268bd2>&lt;key&gt;</span>StandardOutPath<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>/tmp/{{.Label}}.out.log<span style=color:#268bd2>&lt;/string&gt;</span>
     <span style=color:#268bd2>&lt;key&gt;</span>StandardErrorPath<span style=color:#268bd2>&lt;/key&gt;&lt;string&gt;</span>/tmp/{{.Label}}.err.log<span style=color:#268bd2>&lt;/string&gt;</span>
     <span style=color:#268bd2>&lt;key&gt;</span>KeepAlive<span style=color:#268bd2>&lt;/key&gt;</span>&lt;{{.KeepAlive}}/&gt;
     <span style=color:#268bd2>&lt;key&gt;</span>RunAtLoad<span style=color:#268bd2>&lt;/key&gt;</span>&lt;{{.RunAtLoad}}/&gt;
   <span style=color:#268bd2>&lt;/dict&gt;</span>
<span style=color:#268bd2>&lt;/plist&gt;</span>
`
}</code></pre></div><p>And the program that will use our little template function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// main.go
</span><span style=color:#586e75></span><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;log&#34;</span>
	<span style=color:#2aa198>&#34;os&#34;</span>
	<span style=color:#2aa198>&#34;text/template&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	data <span style=color:#719e07>:=</span> <span style=color:#268bd2>struct</span> {
		Label     <span style=color:#dc322f>string</span>
		Program   <span style=color:#dc322f>string</span>
		KeepAlive <span style=color:#dc322f>bool</span>
		RunAtLoad <span style=color:#dc322f>bool</span>
	}{
		Label:     <span style=color:#2aa198>&#34;ticker&#34;</span>,
		Program:   <span style=color:#2aa198>&#34;/usr/local/bin/ticker&#34;</span>,
		KeepAlive: <span style=color:#cb4b16>true</span>,
		RunAtLoad: <span style=color:#cb4b16>true</span>,
	}
	t <span style=color:#719e07>:=</span> template.<span style=color:#268bd2>Must</span>(template.<span style=color:#268bd2>New</span>(<span style=color:#2aa198>&#34;launchdConfig&#34;</span>).<span style=color:#268bd2>Parse</span>(<span style=color:#268bd2>Template</span>()))
	err <span style=color:#719e07>:=</span> t.<span style=color:#268bd2>Execute</span>(os.Stdout, data)
	<span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
		log.<span style=color:#268bd2>Fatalf</span>(<span style=color:#2aa198>&#34;Template generation failed: %s&#34;</span>, err)
	}
}</code></pre></div><p>So, what happens there, in the <code>main</code> function? It&rsquo;s actually quite simple:</p><ol><li>We declare a small <code>struct</code>, which has only the properties that will be needed
in the template, and we immediately initialize it with the values for our program.</li><li>We build a new template, using the <code>template.New</code> function, with the name
<code>launchdConfig</code>. Then, we invoke the <code>Parse</code> function on it, which takes the
XML template as an argument.</li><li>We invoke the <code>template.Must</code> function, which takes our built template as
argument. From the documentation, <code>template.Must</code> is a helper that wraps a call
to a function returning <code>(*Template, error)</code> and panics if the error is non-<code>nil</code>.
Actually, <code>template.Must</code> is built to, in a way, validate if the template can be
understood by the <code>text/template</code> package.</li><li>Finally, we invoke <code>Execute</code> on our built template, which takes a data structure
and applies its attributes to the actions in the template. Then it sends the
output to <code>os.Stdout</code>, which does the trick for our example. Of course, the
output can be sent to any struct that implements the <code>io.Writer</code> interface, like
a file (<code>os.File</code>).</li></ol><h3 id=make-and-load-my-plist>Make and load my <code>.plist</code><a hidden class=anchor aria-hidden=true href=#make-and-load-my-plist>#</a></h3><p>Instead of sending all this nice XML to standard out, let&rsquo;s throw in an open
file descriptor to the <code>Execute</code> function and finally save our <code>.plist</code> file in
<code>~/Library/LaunchAgents</code>. There are a couple of main points we need to change.</p><p>First, getting the location of the binary. Since it&rsquo;s a Go binary, and we will
install it via <code>go install</code>, we can assume that the path will be at <code>$GOPATH/bin</code>.
Second, since we don&rsquo;t know the actual <code>$HOME</code> of the current user, we will have
to get it through the environment. Both of these can be done via <code>os.Getenv</code>
(<a href=https://godoc.org/os#Getenv>docs</a>) which takes a variable name and returns
its value.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// main.go
</span><span style=color:#586e75></span><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;log&#34;</span>
	<span style=color:#2aa198>&#34;os&#34;</span>
	<span style=color:#2aa198>&#34;text/template&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	data <span style=color:#719e07>:=</span> <span style=color:#268bd2>struct</span> {
		Label     <span style=color:#dc322f>string</span>
		Program   <span style=color:#dc322f>string</span>
		KeepAlive <span style=color:#dc322f>bool</span>
		RunAtLoad <span style=color:#dc322f>bool</span>
	}{
		Label:     <span style=color:#2aa198>&#34;com.ieftimov.ticker&#34;</span>, <span style=color:#586e75>// Reverse-DNS naming convention
</span><span style=color:#586e75></span>		Program:   fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;%s/bin/ticker&#34;</span>, os.<span style=color:#268bd2>Getenv</span>(<span style=color:#2aa198>&#34;GOPATH&#34;</span>)),
		KeepAlive: <span style=color:#cb4b16>true</span>,
		RunAtLoad: <span style=color:#cb4b16>true</span>,
	}

        plistPath <span style=color:#719e07>:=</span> fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;%s/Library/LaunchAgents/%s.plist&#34;</span>, os.<span style=color:#268bd2>Getenv</span>(<span style=color:#2aa198>&#34;HOME&#34;</span>), data.Label)
        f, err <span style=color:#719e07>:=</span> os.<span style=color:#268bd2>Open</span>(plistPath)
        t <span style=color:#719e07>:=</span> template.<span style=color:#268bd2>Must</span>(template.<span style=color:#268bd2>New</span>(<span style=color:#2aa198>&#34;launchdConfig&#34;</span>).<span style=color:#268bd2>Parse</span>(<span style=color:#268bd2>Template</span>()))
        err <span style=color:#719e07>:=</span> t.<span style=color:#268bd2>Execute</span>(f, data)
        <span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
                log.<span style=color:#268bd2>Fatalf</span>(<span style=color:#2aa198>&#34;Template generation failed: %s&#34;</span>, err)
        }
}</code></pre></div><p>That&rsquo;s about it. The first part, about setting the correct <code>Program</code> property,
is done by concatenating the name of the program and <code>$GOPATH</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;%s/bin/ticker&#34;</span>, os.<span style=color:#268bd2>Getenv</span>(<span style=color:#2aa198>&#34;GOPATH&#34;</span>))
<span style=color:#586e75>// Output: /Users/&lt;username&gt;/go/bin/ticker
</span></code></pre></div><p>The second part is slightly more complex, and it&rsquo;s done by concatenating three
strings, the <code>$HOME</code> environment variable, the <code>Label</code> property of the program
and the <code>/Library/LaunchAgents</code> string:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;%s/Library/LaunchAgents/%s.plist&#34;</span>, os.<span style=color:#268bd2>Getenv</span>(<span style=color:#2aa198>&#34;HOME&#34;</span>), data.Label)
<span style=color:#586e75>// Output: /Users/&lt;username&gt;/Library/LaunchAgents/com.ieftimov.ticker.plist
</span></code></pre></div><p>By having these two paths, opening the file and writing to it is very trivial -
we open the file via <code>os.Open</code> and we pass in the <code>os.File</code> structure to
<code>t.Execute</code> which writes to the file descriptor.</p><h2 id=what-about-the-launch-agent>What about the Launch Agent?<a hidden class=anchor aria-hidden=true href=#what-about-the-launch-agent>#</a></h2><p>We will keep this one simple as well. Let&rsquo;s throw in a command to our package,
make it installable via <code>go install</code> (not that there&rsquo;s much to it) and make it
runnable by our <code>.plist</code> file:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// cmd/ticker/main.go
</span><span style=color:#586e75></span><span style=color:#719e07>package</span> ticker

<span style=color:#719e07>import</span> (
  <span style=color:#2aa198>&#34;time&#34;</span>
  <span style=color:#2aa198>&#34;fmt&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
    <span style=color:#719e07>for</span> <span style=color:#719e07>range</span> time.<span style=color:#268bd2>Tick</span>(<span style=color:#2aa198>30</span> <span style=color:#719e07>*</span> time.Second) {
            fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;tick!&#34;</span>)
    }
}</code></pre></div><p>This the <code>ticker</code> program will use <code>time.Tick</code>, to execute an action every 30
seconds. Since this will be an infinite loop, <code>launchd</code> will kick off the program
on boot (because <code>RunAtLoad</code> is set to <code>true</code> in the <code>.plist</code> file) and will
keep it running. But, to make the program controllable from the operating system,
we need to make the program react to some OS signals, like <code>SIGINT</code> or <code>SIGTERM</code>.</p><h3 id=understanding-and-handling-os-signals>Understanding and handling OS signals<a hidden class=anchor aria-hidden=true href=#understanding-and-handling-os-signals>#</a></h3><p>While there&rsquo;s quite a bit to be learned about OS signals, in our
example we will scratch a bit off the surface. (If you know a lot about
inter-process communication this might be too much of an oversimplification to
you - and I apologize up front. Feel free to drop some links on the topic in the
comments so others can learn more!)</p><p>The best way to think about a signal is that it&rsquo;s a message from the operating
system or another process, to a process. It is an asynchronous notification sent
to a process or to a specific thread within the same process to notify it of an
event that occurred.</p><p>There are quite a bit of various signals that can be sent to a process
(or a thread), like <code>SIGKILL</code> (which kills a process), <code>SIGSTOP</code> (stop), <code>SIGTERM</code>
(termination), <code>SIGILL</code> and so on and so forth. There&rsquo;s an exhaustive list of
signal types on <a href=https://en.wikipedia.org/wiki/Signal_(IPC)>Wikipedia&rsquo;s page</a>
on signals.</p><p>To get back to <code>launchd</code>, if we look at its documentation about stopping a job
we will notice the following:</p><blockquote><p>Stopping a job will send the signal <code>SIGTERM</code> to the process. Should this not
stop the process launchd will wait <code>ExitTimeOut</code> seconds (20 seconds by default)
before sending <code>SIGKILL</code>.</p></blockquote><p>Pretty self-explanatory, right? We need to handle one signal - <code>SIGTERM</code>.
Why not <code>SIGKILL</code>? Because <code>SIGKILL</code> is a special signal that cannot be caught -
it kills the process without any chance for a graceful shutdown, no questions
asked. That&rsquo;s why there&rsquo;s a termination signal and a &ldquo;kill&rdquo; signal.</p><p>Let&rsquo;s throw in a bit of signal handling in our code, so our program knows that
it needs to exit when it gets told to do so:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;fmt&#34;</span>
	<span style=color:#2aa198>&#34;os&#34;</span>
	<span style=color:#2aa198>&#34;os/signal&#34;</span>
	<span style=color:#2aa198>&#34;syscall&#34;</span>
	<span style=color:#2aa198>&#34;time&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	sigs <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>(<span style=color:#268bd2>chan</span> os.Signal, <span style=color:#2aa198>1</span>)
	signal.<span style=color:#268bd2>Notify</span>(sigs, syscall.SIGINT, syscall.SIGTERM)

	<span style=color:#719e07>go</span> <span style=color:#268bd2>func</span>() {
		<span style=color:#719e07>&lt;-</span>sigs
		os.<span style=color:#268bd2>Exit</span>(<span style=color:#2aa198>0</span>)
	}()

	<span style=color:#719e07>for</span> <span style=color:#719e07>range</span> time.<span style=color:#268bd2>Tick</span>(<span style=color:#2aa198>30</span> <span style=color:#719e07>*</span> time.Second) {
		fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;tick!&#34;</span>)
	}
}</code></pre></div><p>In the new version, the agent program has two new packages imported: <code>os/signal</code>
and <code>syscall</code>. <code>os/signal</code> implements access to incoming signals, that are
primarily used on Unix-like systems. Since in this article we are specifically
interested in MacOS, this is exactly what we need.</p><p>Package <code>syscall</code> contains an interface to the low-level operating system
primitives. An important note about <code>syscall</code> is that it is locked down since
Go v1.4. This means that any code outside of the standard library that uses
the <code>syscall</code> package should be migrated to use the new <code>golang.org/x/sys</code>
<a href=https://golang.org/x/sys>package</a>. Since we are using <strong>only</strong> the signals constants of
<code>syscall</code> we can get away with this.</p><p>(If you want to read more about the package lockdown, you can see
<a href=https://docs.google.com/document/d/1QXzI9I1pOfZPujQzxhyRy6EeHYTQitKKjHfpq0zpxZs/edit>the rationale on locking it down</a>
by the Go team and the new <a href=https://golang.org/x/sys>golang.org/s/sys</a> package.)</p><p>Having the basics of the packages out of the way, let&rsquo;s go step by step through
the new lines of code added:</p><ol><li>We make a buffered channel of type <code>os.Signal</code>, with a size of <code>1</code>. <code>os.Signal</code>
is a type that represents an operating system signal.</li><li>We call <code>signal.Notify</code> with the new channel as an argument, plus
<code>syscall.SIGINT</code> and <code>syscall.SIGTERM</code>. This function states &ldquo;when the OS sends
a <code>SIGINT</code> or a <code>SIGTERM</code> signal to this program, send the signal to the
channel&rdquo;. This allows us to somehow handle the sent OS signal.</li><li>The new goroutine that we spawn waits for any of the signals to arrive through
the channel. Since we know that any of the signals that will arrive are about
shutting down the program, after receiving any signal we use <code>os.Exit(0)</code>
(<a href=https://godoc.org/os#Exit>docs</a>) to gracefully stop the program. One caveat
here is that if we had any <code>defer</code>red calls they would not be run.</li></ol><p>Now <code>launchd</code> can run the agent program and we can <code>load</code> and <code>unload</code>,
<code>start</code> and <code>stop</code> it using <code>launchctl</code>.</p><h2 id=putting-it-all-together>Putting it all together<a hidden class=anchor aria-hidden=true href=#putting-it-all-together>#</a></h2><p>Now that we have all the pieces ready, we need to put them together to a
good use. Our application will consist of two binaries - a CLI tool and an
agent (daemon). Both of the programs will be stored in separate subdirectories
of the <code>cmd</code> directory.</p><p>The CLI tool:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// cmd/cli/main.go
</span><span style=color:#586e75></span><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;log&#34;</span>
	<span style=color:#2aa198>&#34;os&#34;</span>
	<span style=color:#2aa198>&#34;text/template&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	data <span style=color:#719e07>:=</span> <span style=color:#268bd2>struct</span> {
		Label     <span style=color:#dc322f>string</span>
		Program   <span style=color:#dc322f>string</span>
		KeepAlive <span style=color:#dc322f>bool</span>
		RunAtLoad <span style=color:#dc322f>bool</span>
	}{
		Label:     <span style=color:#2aa198>&#34;com.ieftimov.ticker&#34;</span>, <span style=color:#586e75>// Reverse-DNS naming convention
</span><span style=color:#586e75></span>		Program:   fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;%s/bin/ticker&#34;</span>, os.<span style=color:#268bd2>Getenv</span>(<span style=color:#2aa198>&#34;GOPATH&#34;</span>)),
		KeepAlive: <span style=color:#cb4b16>true</span>,
		RunAtLoad: <span style=color:#cb4b16>true</span>,
	}

        plistPath <span style=color:#719e07>:=</span> fmt.<span style=color:#268bd2>Sprintf</span>(<span style=color:#2aa198>&#34;%s/Library/LaunchAgents/%s.plist&#34;</span>, os.<span style=color:#268bd2>Getenv</span>(<span style=color:#2aa198>&#34;HOME&#34;</span>), data.Label)
        f, err <span style=color:#719e07>:=</span> os.<span style=color:#268bd2>Open</span>(plistPath)
        t <span style=color:#719e07>:=</span> template.<span style=color:#268bd2>Must</span>(template.<span style=color:#268bd2>New</span>(<span style=color:#2aa198>&#34;launchdConfig&#34;</span>).<span style=color:#268bd2>Parse</span>(<span style=color:#268bd2>Template</span>()))
        err <span style=color:#719e07>:=</span> t.<span style=color:#268bd2>Execute</span>(f, data)
        <span style=color:#719e07>if</span> err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
                log.<span style=color:#268bd2>Fatalf</span>(<span style=color:#2aa198>&#34;Template generation failed: %s&#34;</span>, err)
        }
}</code></pre></div><p>And the ticker program:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// cmd/ticker/main.go
</span><span style=color:#586e75></span><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;fmt&#34;</span>
	<span style=color:#2aa198>&#34;os&#34;</span>
	<span style=color:#2aa198>&#34;os/signal&#34;</span>
	<span style=color:#2aa198>&#34;syscall&#34;</span>
	<span style=color:#2aa198>&#34;time&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	sigs <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>(<span style=color:#268bd2>chan</span> os.Signal, <span style=color:#2aa198>1</span>)
	signal.<span style=color:#268bd2>Notify</span>(sigs, syscall.SIGINT, syscall.SIGTERM)

	<span style=color:#719e07>go</span> <span style=color:#268bd2>func</span>() {
		<span style=color:#719e07>&lt;-</span>sigs
		os.<span style=color:#268bd2>Exit</span>(<span style=color:#2aa198>0</span>)
	}()

	<span style=color:#719e07>for</span> <span style=color:#719e07>range</span> time.<span style=color:#268bd2>Tick</span>(<span style=color:#2aa198>30</span> <span style=color:#719e07>*</span> time.Second) {
		fmt.<span style=color:#268bd2>Println</span>(<span style=color:#2aa198>&#34;tick!&#34;</span>)
	}
}</code></pre></div><p>To install them both, we need to run <code>go install ./...</code> in the project root.
The command will install all the sub-packages that are located within the
project. This will leave us with two available binaries, installed in the
<code>$GOPATH/bin</code> path.</p><p>To install our launch agent, we need to run only the CLI tool, via the <code>cli</code>
command. This will generate the <code>.plist</code> file and place it in the
<code>~/Library/LaunchAgents</code> path. We don&rsquo;t need to touch the <code>ticker</code> binary -
that one will be managed by <code>launchd</code>.</p><p>To load the newly created <code>.plist</code> file, we need to run:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>launchctl load ~/Library/LaunchAgents/com.ieftimov.ticker.plist</code></pre></div><p>When we run it, we will not see anything immediately, but after 30 seconds
the ticker will add a <code>tick!</code> line in <code>/tmp/ticker.out.log</code>. We can <code>tail</code>
the file to see the new lines being added. If we want to unload the agent, we
can use:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>launchctl unload ~/Library/LaunchAgents/com.ieftimov.ticker.plist</code></pre></div><p>This will unload the launch agent and will stop the ticker from running.
Remember the signal handling we added? This is the case where it&rsquo;s being used!
Also, we could have automated the (un)loading of the file via the CLI tool but
for simplicity, we left it out. You can try to improve the CLI tool by making
it a bit smarter with subcommands and flags, as a follow-up exercise from this
tutorial.</p><p>Finally, if you decide to completely delete the launch agent, you can remove
the <code>.plist</code> file:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>rm ~/Library/LaunchAgents/com.ieftimov.ticker.plist</code></pre></div><h2 id=in-closing>In closing<a hidden class=anchor aria-hidden=true href=#in-closing>#</a></h2><p>As part of this (quite long!) article, we saw how we can work with <code>launchd</code>
and Golang. We took a detour, like learning about <code>launchd</code> and <code>launchctl</code>,
generating XML files using the <code>text/template</code> package, we took a look at OS
signals and how we can gracefully shutdown a Go program by handling the
<code>SIGINT</code> and <code>SIGTERM</code> signals. There was quite a bit to learn and see, but we
got to the end.</p><p>Of course, we only scratched the surface with this article. For example,
<code>launchd</code> is quite an interesting tool. You can use it also like <code>crontab</code>
because it allows running programs at explicit time/date combinations or on
specific days. Or, for example, the XML template can be embedded in the program
binary using tools like <a href=https://github.com/jteeuwen/go-bindata><code>go-bindata</code></a>,
instead of hardcoding it in a function. Also, you explore more about signals,
how they work and how Go implements these low-level primitives so you can use
them with ease in your programs. The options are plenty, feel free to explore!</p><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to +1000 of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/launchagent/>launchagent</a></li><li><a href=https://ieftimov.com/tags/launchd/>launchd</a></li><li><a href=https://ieftimov.com/tags/launchctl/>launchctl</a></li><li><a href=https://ieftimov.com/tags/lpc/>lpc</a></li><li><a href=https://ieftimov.com/tags/signals/>signals</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/golang-datastructures-linked-lists/><span class=title>« Prev Page</span><br><span>Data structures in Go: Linked lists</span></a>
<a class=next href=https://ieftimov.com/post/golang-package-multiple-binaries/><span class=title>Next Page »</span><br><span>Packing multiple binaries in a Golang package</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Create and manage MacOS LaunchAgents using Go on twitter" href="https://twitter.com/intent/tweet/?text=Create%20and%20manage%20MacOS%20LaunchAgents%20using%20Go&url=https%3a%2f%2fieftimov.com%2fpost%2fcreate-manage-macos-launchd-agents-golang%2f&hashtags=launchagent%2claunchd%2claunchctl%2clpc%2csignals"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Create and manage MacOS LaunchAgents using Go on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fcreate-manage-macos-launchd-agents-golang%2f&title=Create%20and%20manage%20MacOS%20LaunchAgents%20using%20Go&summary=Create%20and%20manage%20MacOS%20LaunchAgents%20using%20Go&source=https%3a%2f%2fieftimov.com%2fpost%2fcreate-manage-macos-launchd-agents-golang%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Create and manage MacOS LaunchAgents using Go on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fcreate-manage-macos-launchd-agents-golang%2f&title=Create%20and%20manage%20MacOS%20LaunchAgents%20using%20Go"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Create and manage MacOS LaunchAgents using Go on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fcreate-manage-macos-launchd-agents-golang%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Create and manage MacOS LaunchAgents using Go on whatsapp" href="https://api.whatsapp.com/send?text=Create%20and%20manage%20MacOS%20LaunchAgents%20using%20Go%20-%20https%3a%2f%2fieftimov.com%2fpost%2fcreate-manage-macos-launchd-agents-golang%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Create and manage MacOS LaunchAgents using Go on telegram" href="https://telegram.me/share/url?text=Create%20and%20manage%20MacOS%20LaunchAgents%20using%20Go&url=https%3a%2f%2fieftimov.com%2fpost%2fcreate-manage-macos-launchd-agents-golang%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>