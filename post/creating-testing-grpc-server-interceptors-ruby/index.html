<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Creating and testing gRPC server interceptors in Ruby | Ilija Eftimov ⚡️</title><meta name=keywords content><meta name=description content="If your experience is rooted in HTTP-land, then you are probably familiar with the concept of server middleware. Interceptors are analogous, but in gRPC land. When first building gRPC interceptors, I had trouble figuring out how to do it in Ruby. gRPC is not that widely used in the Ruby ecosystem, and there are not many resources on how to properly do it.
Also, my experience with writing unit and integration tests for interceptors were that there is even less documentation on the topic."><meta name=author content="Ilija Eftimov"><link rel=canonical href=https://ieftimov.com/post/creating-testing-grpc-server-interceptors-ruby/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Creating and testing gRPC server interceptors in Ruby"><meta property="og:description" content="If your experience is rooted in HTTP-land, then you are probably familiar with the concept of server middleware. Interceptors are analogous, but in gRPC land. When first building gRPC interceptors, I had trouble figuring out how to do it in Ruby. gRPC is not that widely used in the Ruby ecosystem, and there are not many resources on how to properly do it.
Also, my experience with writing unit and integration tests for interceptors were that there is even less documentation on the topic."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/creating-testing-grpc-server-interceptors-ruby/"><meta property="og:image" content="https://ieftimov.com/cards/creating-testing-grpc-server-interceptors-ruby.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-12T00:03:55+01:00"><meta property="article:modified_time" content="2021-12-12T00:03:55+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/creating-testing-grpc-server-interceptors-ruby.png"><meta name=twitter:title content="Creating and testing gRPC server interceptors in Ruby"><meta name=twitter:description content="If your experience is rooted in HTTP-land, then you are probably familiar with the concept of server middleware. Interceptors are analogous, but in gRPC land. When first building gRPC interceptors, I had trouble figuring out how to do it in Ruby. gRPC is not that widely used in the Ruby ecosystem, and there are not many resources on how to properly do it.
Also, my experience with writing unit and integration tests for interceptors were that there is even less documentation on the topic."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Creating and testing gRPC server interceptors in Ruby","item":"https://ieftimov.com/post/creating-testing-grpc-server-interceptors-ruby/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Creating and testing gRPC server interceptors in Ruby","name":"Creating and testing gRPC server interceptors in Ruby","description":"If your experience is rooted in HTTP-land, then you are probably familiar with the concept of server middleware. Interceptors are analogous, but in gRPC land. When first building gRPC interceptors, I had trouble figuring out how to do it in Ruby. gRPC is not that widely used in the Ruby ecosystem, and there are not many resources on how to properly do it.\nAlso, my experience with writing unit and integration tests for interceptors were that there is even less documentation on the topic.","keywords":[],"articleBody":"If your experience is rooted in HTTP-land, then you are probably familiar with the concept of server middleware. Interceptors are analogous, but in gRPC land. When first building gRPC interceptors, I had trouble figuring out how to do it in Ruby. gRPC is not that widely used in the Ruby ecosystem, and there are not many resources on how to properly do it.\nAlso, my experience with writing unit and integration tests for interceptors were that there is even less documentation on the topic. I was able to find almost no how-tos and tutorials, so the best bet was reading some open source code and putting pieces together from different repositories to come up with a sane approach to it.\nThe lack of documentation and tutorials made me document my experience and everything I have learned in this article.\nLet’s see how we can build an interceptor in Ruby and how we can test it, too.\nBuilding the logging payload Legit logging interceptors or middleware usually allow developers to set the format and the logger as they wish. While this is undoubtedly the best approach, we will only look into building an interceptor that logs in JSON format for our exercise here.\nTo get any JSON logs out, we will need to extract some information from the gRPC call during the execution of the interceptor. To avoid polluting the interceptor with code that builds the log payload, let’s first look at a class that will have that responsibility:\nmodule Grpclog class Payload CODES = { ::GRPC::Core::StatusCodes::OK = 'OK', ::GRPC::Core::StatusCodes::CANCELLED = 'Canceled', ::GRPC::Core::StatusCodes::UNKNOWN = 'Unknown', ::GRPC::Core::StatusCodes::INVALID_ARGUMENT = 'InvalidArgument', ::GRPC::Core::StatusCodes::DEADLINE_EXCEEDED = 'DeadlineExceeded', ::GRPC::Core::StatusCodes::NOT_FOUND = 'NotFound', ::GRPC::Core::StatusCodes::ALREADY_EXISTS = 'AlreadyExists', ::GRPC::Core::StatusCodes::PERMISSION_DENIED = 'PermissionDenied', ::GRPC::Core::StatusCodes::RESOURCE_EXHAUSTED = 'ResourceExhausted', ::GRPC::Core::StatusCodes::FAILED_PRECONDITION = 'FailedPrecondition', ::GRPC::Core::StatusCodes::ABORTED = 'Aborted', ::GRPC::Core::StatusCodes::OUT_OF_RANGE = 'OutOfRange', ::GRPC::Core::StatusCodes::UNIMPLEMENTED = 'Unimplemented', ::GRPC::Core::StatusCodes::INTERNAL = 'Internal', ::GRPC::Core::StatusCodes::UNAVAILABLE = 'Unavailable', ::GRPC::Core::StatusCodes::DATA_LOSS = 'DataLoss', ::GRPC::Core::StatusCodes::UNAUTHENTICATED = 'Unauthenticated' }.freeze attr_accessor :exception attr_reader :method, :service, :code, :start_time def initialize(method, code, start_time) @service = service_name(method) @method = method_name(method) @code = code @start_time = start_time end def to_h result = { 'grpc.service' = service, 'grpc.method' = method, 'grpc.code' = CODES.fetch(code, code.to_s), 'grpc.start_time' = start_time.utc, 'grpc.time_ms' = elapsed_milliseconds, 'pid' = Process.pid } result.merge!('exception' = exception) if exception result end private def elapsed_milliseconds (Time.now - start_time) * 1000.0 end def method_name(method) owner = method.owner method_name, = owner.rpc_descs.find do |k, _| ::GRPC::GenericService.underscore(k.to_s) == method.name.to_s end return '(unknown)' if method_name.nil? method_name.to_s end def service_name(method) method.owner.service_name end end end Payload is only a wrapper around the gRPC method object, the start time of the request, and the gRPC response code. Additionally, it can take an exception if our interceptor hits an error of sorts.\nLastly, in its to_h method, the Paylaod object creates a hash that we can use to send to our logger. Using this approach, all of the complexity related to extracting relevant data for logging responsibility of the Payload class, while the interceptor has to only care about logging the payload.\nThis way, we have separation of concerns, and each entity has single responsibility.\nLogging Interceptor Say we have an application that speaks gRPC, and we want each inbound request to emit a logline formatted as a valid JSON. You can imagine that we can send the logger’s output to STDOUT, and we can export it and index it for further exploration.\nA straightforward implementation of a server interceptor:\n# lib/grpclog/server_interceptor.rb module Grpclog class ServerInterceptor  ::GRPC::ServerInterceptor def initialize(logger, level = :info) @logger = logger @level = level super() end def request_response(_request: nil, call: nil, method: nil, \u0026block) log(method, call, \u0026block) end def server_streamer(_request: nil, call: nil, method: nil, \u0026block) log(method, call, \u0026block) end def client_streamer(call: nil, method: nil, \u0026block) log(method, call, \u0026block) end def bidi_streamer(_request: nil, call: nil, method: nil, \u0026block) log(method, call, \u0026block) end end end The interceptor will implement all four gRPC method types, where each of them will invoke the same method: log. The log method will take the method name and the call object as arguments, and the gRPC method will yield to the log method.\nLet’s look quickly at the log method:\ndef log(method, _call) start_time = Time.now code = ::GRPC::Core::StatusCodes::OK yield rescue StandardError = e code = e.is_a?(::GRPC::BadStatus) ? e.code : ::GRPC::Core::StatusCodes::UNKNOWN raise ensure payload = Grpclog::Payload.new(method, code, start_time) if e payload.exception = e.message @level = :error end @logger.formatter = method(:formatter) @logger.send(@level, payload.to_h) end While the method is a bit busy, it doesn’t do much:\n It records the start time of the request, so later we can see the time spent during the call, and we can log it It rescues any error, to find out the error type so we can log the error type It ensures to create a Payload, which is a PORO containing the data we want to log that packs it all in a hash, and then logging it using the interceptor’s logger  We can see here how the Payload class is incorporated – by adding the new object, we hide all of the complexity to building the log payload, and at the end, we invoke the to_h method.\nTesting the Payload class is straightforward; therefore, we will skip its test for brevity’s sake.\nLet’s look at how we can test our server interceptor.\nTesting interceptors To test our interceptor, we need to think about the various types of tests:\n Unit tests, where we invoke the methods in the test using doubles for dependencies, having isolation from the rest of the gRPC stack Integration tests, where we mount the request on a test gRPC server, and we send requests via the network  Before we begin, a fair warning: testing interceptors in Ruby is messy (as you are about to find out). If you have figured out a cleaner approach, please drop me a line and let me know!\nUnit testing intercetoprs When looking at the implementation of the interceptors, we can notice that to do any testing, we will need to mock out all gRPC-related dependencies:\nmodule Grpclog class ServerInterceptor  ::GRPC::ServerInterceptor # Snipped for brevity def request_response(request: nil, call: nil, method: nil, \u0026block) log(method, call, \u0026block) end # Snipped for brevity end end The request, call, and method objects are dependencies that the interceptor’s interface forces upon us during testing. Even though our log method does not use the request object, we will have to satisfy the interface of the interceptor.\nAdditionally, if we look at the log method, we will see that we do not use the _call object, but the method extensively uses the method object and the Payload object that we will create in it:\ndef log(method, _call) # Snipped for brevity yield rescue StandardError = e # Snipped for brevity ensure payload = Grpclog::Payload.new(method, code, start_time) # Snipped for brevity @logger.send(@level, payload.to_h) end And the Payload#method_name and Payload#service_name:\n# lib/grpclog/payload.rb def method_name(method) owner = method.owner method_name, = owner.rpc_descs.find do |k, _| ::GRPC::GenericService.underscore(k.to_s) == method.name.to_s end return '(unknown)' if method_name.nil? method_name.to_s end def service_name(method) method.owner.service_name end Given the extensive use of the method object, it’s clear that a simple double won’t do the trick.\nAdditionally, to unit test the service in isolation without extra dependencies, we would also have to define a gRPC service stub and implement it. That would allow us to have the test self-contained without the need for additional support files.\nWithout kicking the can down the road, let’s first see the setup that we will need for our unit tests:\nRSpec.describe Grpclog::ServerInterceptor do let(:rpc_class) { Class.new do include GRPC::GenericService self.marshal_class_method = :encode self.unmarshal_class_method = :decode self.service_name = 'test.Test' rpc :Greet, Google::Protobuf::StringValue, Google::Protobuf::Empty end } let(:service_class) { Class.new(rpc_class) do def greet(_msg, _call) # Do nothing end end } # Snipped for brevity end First, we will define the gRPC generic service class and the service class that implements the generic class. The service will have only one method – Greet - which will take a simple string value and return an empty value (i.e., Protobuf defined as Google::Protobuf::Empty).\nThe actual implementation of the greet method will be empty – in the spec, we will be testing the interceptor, not the real method, so we don’t care about its implementation.\nNow that we have these classes in place, let’s continue with the test setup:\nRSpec.describe Grpclog::ServerInterceptor do # Snipped for brevity let(:method) { service_class.new.method(:greet) } let(:request) { double } let(:call) { double(:call, peer: \"\", metadata: {}) } # Snipped for brevity end We have to create a few values that we will use in the specs:\n The gRPC method object The gRPC request – a blank double The gRPC call – a double with peer and metadata attributes  We do not need to set peer and metadata to any values for our specs. However, keep in mind that if your interceptor accesses these attributes, like if the interceptor extracts the User-agent from the call, you must set these attributes on the call object.\nNext, let’s look at the remainder of the spec setup:\nRSpec.describe Grpclog::ServerInterceptor do # Snipped for brevity let(:interceptor) { described_class.new(logger) } subject(:logger) { Logger.new(STDOUT) } # Snipped for brevity end Lastly, we create the interceptor object, and pass a logger to the constructor. The subject of our specs will be the logger object, as we will be asserting whether the interceptor invokes the correct methods on the logger (as seen in the implementation of the interceptor).\nLet’s finally look at the actual specs:\nRSpec.describe Grpclog::ServerInterceptor do # Snipped for brevity describe '#request_response_method' do before { allow(subject).to receive(:send) } context 'when no exception occurs' do before { interceptor.request_response(request: request, call: call, method: method) { } } it { is_expected.to have_received(:send).with(:info, Hash) } end context 'when a known exception occurs' do before do expect do interceptor.request_response(request: request, call: call, method: method) do raise GRPC::NotFound.new end end.to raise_error(GRPC::NotFound) end it { is_expected.to have_received(:send).with(:error, Hash) } end context 'when an unknown exception occurs' do before do expect do interceptor.request_response(request: request, call: call, method: method) { raise :unknown } end.to raise_error(StandardError) end it { is_expected.to have_received(:send).with(:error, Hash) } end end # Snipped for brevity end We are looking at three different tests here:\n Test the logging behavior when no errors occur Test the behavior when a known error occurs, and Test the behavior when an unknown error occurs  The core of the test is the expectation that the interceptor will call a method on the logger object, which will effectively log a line (which is the purpose of the interceptor).\nBefore we kick off the test, we set an RSpec spy, which will watch for any invocations of the send method on the logger object (i.e., the subject). This spy will allow us to assert later whether the code invoked send on the logger object, and with what arguments, too.\nWe will invoke the request_response method on the interceptor, with its required argument within each spec. In other words, the request_response method is the unit under test here. Hence, for every spec, we call the method in a before block.\nIn the first spec, we invoke the method with an empty body within the when no exception occurs context. The interceptor will take the empty block, evaluate it and log the request line. We set the expectation that when the interceptor hits no errors, the logger will receive send with the :info argument (i.e., the log level) and a Hash, which is the payload:\n# lib/grpclog/server_interceptor.rb @logger.send(@level, payload.to_h) In the second spec, within the when a known exception occurs context, we use the same approach as before with one key difference: the block evaluated by the interceptor will raise a (known) error. In such a case, we set the expectation that the logger will receive send with the :error argument (i.e., the log level) and the payload Hash.\nLastly, in the third spec, within the when an unknown exception occurs context, we follow a similar approach to the second spec, but we raise an unknown error this time. In such a case, we set the expectation that the logger will receive send with the :error argument (i.e., the log level) and the payload Hash – identical to the one above.\nGiven that our interceptor methods perform the same functionality for all request types, the other tests are similar to those above. To prove that the same test approach will work for the other method, here’s the bidi_streamer spec:\nRSpec.describe Grpclog::ServerInterceptor do # Snipped for brevity describe '#bidi_streamer' do before { allow(subject).to receive(:send) } context 'when no exception occurs' do before { interceptor.bidi_streamer(requests: [request], call: call, method: method) { } } it { is_expected.to have_received(:send).with(:info, Hash) } end context 'when a known exception occurs' do before do expect do interceptor.bidi_streamer(requests: [request], call: call, method: method) do raise GRPC::NotFound.new end end.to raise_error(GRPC::NotFound) end it { is_expected.to have_received(:send).with(:error, Hash) } end context 'when an unknown exception occurs' do before do expect do interceptor.bidi_streamer(requests: [request], call: call, method: method) { raise :unknown } end.to raise_error(StandardError) end it { is_expected.to have_received(:send).with(:error, Hash) } end end # Snipped for brevity end If we run the specs, this is the output we will get:\nroot@e4cdc18cf452:/app# bundle exec rspec --format documentation spec/grpclog/server_interceptor_spec.rb Grpclog::ServerInterceptor #request_response_method when no exception occurs is expected to have received send(:info, Hash) 1 time when a known exception occurs is expected to have received send(:error, Hash) 1 time when an unknown exception occurs is expected to have received send(:error, Hash) 1 time #server_streamer when no exception occurs is expected to have received send(:info, Hash) 1 time when a known exception occurs is expected to have received send(:error, Hash) 1 time when an unknown exception occurs is expected to have received send(:error, Hash) 1 time #client_streamer when no exception occurs is expected to have received send(:info, Hash) 1 time when a known exception occurs is expected to have received send(:error, Hash) 1 time when an unknown exception occurs is expected to have received send(:error, Hash) 1 time #bidi_streamer when no exception occurs is expected to have received send(:info, Hash) 1 time when a known exception occurs is expected to have received send(:error, Hash) 1 time when an unknown exception occurs is expected to have received send(:error, Hash) 1 time Finished in 0.02193 seconds (files took 0.16171 seconds to load) 12 examples, 0 failures One last note: while this approach works for my use case, remember that your tests can vary depending on how complicated / what kind of work your interceptors do. You might have to rely on more mocking, or you might need more (detailed) specs. Still, knowing the above setup, you are on an excellent path to start unit testing your interceptors.\nIntegration testing interceptors To begin integration testing the interceptor, we first need to add some supporting infrastructure. We first need to define a dummy gRPC service that will have an RPC method for each method type:\n Unary Server streaming Client streaming Bi-directional streaming  After the service is defined, we need to implement a skeleton service to return a simple response to the RPC call. Once these pieces are in place, we can mount our interceptor to the implementation and test that the server will correctly invoke it.\nService \u0026 message definitions First, let’s look at the Protobuf definition of the dummy service and its message:\n// spec/support/greeter.proto  syntax = \"proto3\"; package grpclog; service Greeter { rpc RequestResponseMethod(Hello) returns (Hello) {} rpc ServerStreamMethod(Hello) returns (stream Hello) {} rpc ClientStreamMethod(stream Hello) returns (Hello) {} rpc BidiStreamMethod(stream Hello) returns (stream Hello) {} } message Hello { string name = 1; int64 error_code = 2; } Each of the RPCs defined on the Greeter service will map to the respective method type, as supported by gRPC.\nNext, we can generate the server and client stubs from the Protobuf code. Let’s define a small rake command to aid us with this, as part of the project’s Rakefile:\n# Rakefile namespace :test do desc 'Generate test protobuf stubs' task :generate_proto do |_task, _args| system 'bundle exec grpc_tools_ruby_protoc --ruby_out=. --grpc_out=. spec/support/greeter/greeter.proto' end end Now that we have the rake test:generate_proto task, we can use it to generate the files (output shortened for brevity):\nroot@d20bd4fd8613:/app# rake test:generate_proto root@d20bd4fd8613:/app# ls -la spec/support/greeter/ -rw-r--r-- 1 root root 353 Nov 1 10:50 greeter.proto -rw-r--r-- 1 root root 482 Nov 2 20:54 greeter_pb.rb -rw-r--r-- 1 root root 739 Nov 2 20:54 greeter_services_pb.rb To be able to mount our server interceptor and test it, we will need to implement an actual server, using the newly created Greeter service. The server will have two parts: the service itself, with all its methods, and a controller piece which will be the actual gRPC over HTTP/2 server.\nService implementation First, let’s put together the service methods:\n# spec/support/greeter/server.rb module Grpclog module Greeter class Server  Grpclog::Greeter::Service def request_response_method(msg, _call) raise_exception(msg) Grpclog::Hello.new(name: \"Hello #{msg.name}\") end def server_stream_method(msg, _call) raise_exception(msg) [Grpclog::Hello.new(name: 'Hello!')] end def client_stream_method(call) call.each_remote_read do |msg| raise_exception(msg) end Grpclog::Hello.new(name: 'Hello!') end def bidi_stream_method(call, _view) call.each do |msg| raise_exception(msg) end [Grpclog::Hello.new(name: 'Hello!')] end def raise_exception(msg) code = msg.error_code raise ::GRPC::BadStatus.new_status_exception(code, 'test exception') if code  ::GRPC::Core::StatusCodes::OK raise code.to_s if code  ::GRPC::Core::StatusCodes::OK end end end end The Server implements the four methods, as defined in the Profobuf definition. We keep the implementations lightweight, where each RPC method will consume the request/stream and return a blank response. We leave the server as a “shell” because we will use it to mount our interceptor for testing and only that.\nThe raise_exception method is there to help us with raising an exception during testing. During testing, it allows us to send an error_code in the request and make the Server raise the exception. While we wouldn’t implement such a method in a real server, this is a neat trick for testing purposes.\nNow, to boot this server during testing, we will need a gRPC server implementation.\ngRPC Server Implementation Let’s introduce a Controller class, which will do a few things:\n Initialize a new gRPC server object, with a host and a port Set up the gRPC server: mount the service and add the interceptors Provide an interface to start the server by kicking off a server thread Provide an interface to stop the server by terminating the server thread  Let’s quickly see the Controller:\n# spec/support/greeter/controller.rb # rubocop:disable Style/ClassVars module Grpclog module Greeter class Controller @@port = 0 class  self def next_port @@port += 1 end end attr_reader :host def initialize(interceptors: [], service: Server) @host = \"0.0.0.0:8008#{self.class.next_port}\" @server = GRPC::RpcServer.new( poll_period: 1, pool_keep_alive: 1, interceptors: interceptors ) @server.add_http2_port(host, :this_port_is_insecure) @server.handle(service) end def start @server_thread = Thread.new { @server.run_till_terminated } end def stop @server.stop @server_thread.join @server_thread.terminate end end end end # rubocop:enable all We first establish a GRPC::RpcServer during the initialization phase, the actual gRPC server implementation, as provided by the grpc gem. We then set up the gRPC server by attaching a host:port that it will listen to, and we specify that the HTTP/2 connection will be insecure by using the :this_port_is_insecure option.\nWhen setting the port, we use a small trick. Namely, we have a next_port class method that keeps track of the number of servers we run concurrently. Then, every time we launch a new Controller, we increment the port number by one. This trick allows us to spin up multiple instances of the Controller without them trying to reuse the same port, giving us the ability to run our tests in parallel.\n(The trick is blatantly borrowed (or, rather, stolen) from the ruby-grpc-opentracing gem.)\nIn the start method, we create a new Thread and run the server. In the stop method, we shut down the GRPC::RpcServer instance, and we also terminate the server Thread that we start in the start method.\nNext, we need the test set up to plug in our new interceptor and test it.\nIntegration test setup We begin the test setup similarly to the unit test one, but with some crucial differences:\nRSpec.describe Grpclog::ServerInterceptor do let(:log) { StringIO.new } let(:logger) { Logger.new(log) } let(:interceptor) { described_class.new(logger) } let(:channel) { GRPC::Core::Channel.new(@server.host, nil, :this_channel_is_insecure) } let(:client) do Grpclog::Greeter::Stub.new( @server.host, :this_channel_is_insecure, channel_override: channel, interceptors: [] ) end subject(:message) { JSON.parse(log.string) } # Snipped for brevity end Setting up the interceptor object by passing in a logger that takes a log which is a StringIO, is very similar to what we saw before. Next, we create a gRPC channel that connects to a gRPC server on a specified host and port.\nWe use the new channel to establish a client object, which uses the generated Grpclog::Greeter::Stub class that we saw before. We will use the client in our specs to send actual gRPC requests to the gRPC server we implemented.\nLastly, the subject is the parsed JSON from the log buffer. We will use it to set expectations that the interceptor logged our messages correctly.\nLet’s continue with our spec:\nRSpec.describe Grpclog::ServerInterceptor do # Snipped for brevity before do @server = Grpclog::Greeter::Controller.new(interceptors: [interceptor]) @server.start end after do @server\u0026.stop end # Snipped for brevity end Here, we set the before and after blocks. In the before block, we initialize the new gRPC server by using the Grpclog::Greeter::Controller class. To it, we pass the interceptor object that we initialized before.\nIn the after block, we make sure to shut down the gRPC server if booted. We want to perform this cleanup, so we do not leave gRPC server threads running after our specs finish.\nLet’s look at a spec next:\nRSpec.describe Grpclog::ServerInterceptor do # Snipped for brevity subject(:logger) { Logger.new(STDOUT) } describe '#server_streamer_method' do context 'when no exceptions are raised' do before do enumerator = client.server_streamer_method(Grpclog::Hello.new) enumerator.each {} # Consume the stream end it { is_expected.to include('grpc.code' = 'OK') } end context 'when an exception is raised' do before do expect do enumerator = client.server_streamer_method( Grpclog::Hello.new(error_code: ::GRPC::Core::StatusCodes::UNKNOWN) ) enumerator.each {} # Consume the stream end.to raise_error(::GRPC::Unknown) end it { is_expected.to include('grpc.code' = 'Unknown') } end end # Snipped for brevity end We are looking at two different specs here: one where no exception is raised and one that raises a GRPC::Unknown.\nIn the first spec, we use the service client to invoke the server_streamer_method, passing in the argument the body of the request. Since its a streaming RPC, the returned value of the client call is an enumerator that allows us to consume the stream.\nWe consume the stream returned by the server, just by looping through the enumerator without acting on the response data itself. Next, we simply assert on the logged line expecting the logged grpc.code field to be OK.\nOn the next spec we use the trick allowing us to return an error from the server. As part of the request body, we send the error_code set as GRPC::Core::StatusCodes::UNKNOWN, which will make the server return the same error. The rest of the test setup is like the one before it: we consume the stream returned by the server, just by looping through the enumerator without acting on the response data itself.\nWhen it comes to the expectation itself, instead of asserting that the grpc.code be OK, we assert that the code is the error we passed as the error_code in the request - Unknown.\nIf we run the specs, we will see that they pass successfully:\nroot@e4cdc18cf452:/app# bundle exec rspec spec/grpclog/integration/server_interceptor_spec.rb Grpclog::ServerInterceptor #server_streamer_method when no exceptions are raised is expected to include {\"grpc.code\" = \"OK\"} when an exception is raised is expected to include {\"grpc.code\" = \"Unknown\"} Finished in 0.06014 seconds (files took 0.19803 seconds to load) 2 examples, 0 failures Evidently, the two types of specs are similar - this is mainly due to the nature of the interceptor under test. On the other hand, the setup for the two types of tests is different, with the integration specs being more involved and requiring additional support files.\nStill, the overhead can be worth it (depending on your case) as mounting the interceptor on an actual gRPC server gives us the confidence that our server interceptor will work correctly when mounted on a gRPC server in the wild.\nIf you would like to inspect the code for this article, head over to its repository. You can check out the implementation, and inspect the full list of specs, including the project setup.\nLiked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to hundreds of other engineers.\n    ","wordCount":"4020","inLanguage":"en","datePublished":"2021-12-12T00:03:55+01:00","dateModified":"2021-12-12T00:03:55+01:00","author":{"@type":"Person","name":"Ilija Eftimov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/creating-testing-grpc-server-interceptors-ruby/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Creating and testing gRPC server interceptors in Ruby</h1><div class=post-meta>December 12, 2021&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Ilija Eftimov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#building-the-logging-payload aria-label="Building the logging payload">Building the logging payload</a></li><li><a href=#logging-interceptor aria-label="Logging Interceptor">Logging Interceptor</a></li><li><a href=#testing-interceptors aria-label="Testing interceptors">Testing interceptors</a><ul><li><a href=#unit-testing-intercetoprs aria-label="Unit testing intercetoprs">Unit testing intercetoprs</a></li><li><a href=#integration-testing-interceptors aria-label="Integration testing interceptors">Integration testing interceptors</a><ul><li><a href=#service--message-definitions aria-label="Service &amp;amp; message definitions">Service & message definitions</a></li><li><a href=#service-implementation aria-label="Service implementation">Service implementation</a></li><li><a href=#grpc-server-implementation aria-label="gRPC Server Implementation">gRPC Server Implementation</a></li><li><a href=#integration-test-setup aria-label="Integration test setup">Integration test setup</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>If your experience is rooted in HTTP-land, then you are probably familiar with
the concept of server middleware. Interceptors are analogous, but in gRPC land.
When first building gRPC interceptors, I had trouble figuring out how to do it
in Ruby. gRPC is not that widely used in the Ruby ecosystem, and there are not
many resources on how to properly do it.</p><p>Also, my experience with writing unit and integration tests for interceptors
were that there is even less documentation on the topic. I was able to find
almost no how-tos and tutorials, so the best bet was reading some open source
code and putting pieces together from different repositories to come up with a
sane approach to it.</p><p>The lack of documentation and tutorials made me document my experience and
everything I have learned in this article.</p><p>Let&rsquo;s see how we can build an interceptor in Ruby and how we can test it, too.</p><h2 id=building-the-logging-payload>Building the logging payload<a hidden class=anchor aria-hidden=true href=#building-the-logging-payload>#</a></h2><p>Legit logging interceptors or middleware usually allow developers to set the
format and the logger as they wish. While this is undoubtedly the best
approach, we will only look into building an interceptor that logs in JSON
format for our exercise here.</p><p>To get any JSON logs out, we will need to extract some information from the
gRPC call during the execution of the interceptor. To avoid polluting the
interceptor with code that builds the log payload, let&rsquo;s first look at a class
that will have that responsibility:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#719e07>module</span> Grpclog
  <span style=color:#719e07>class</span> <span style=color:#268bd2>Payload</span>
    <span style=color:#cb4b16>CODES</span> <span style=color:#719e07>=</span> {
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>OK</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;OK&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>CANCELLED</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Canceled&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>UNKNOWN</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Unknown&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>INVALID_ARGUMENT</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;InvalidArgument&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>DEADLINE_EXCEEDED</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;DeadlineExceeded&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>NOT_FOUND</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;NotFound&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ALREADY_EXISTS</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;AlreadyExists&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>PERMISSION_DENIED</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;PermissionDenied&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>RESOURCE_EXHAUSTED</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;ResourceExhausted&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>FAILED_PRECONDITION</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;FailedPrecondition&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ABORTED</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Aborted&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>OUT_OF_RANGE</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;OutOfRange&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>UNIMPLEMENTED</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Unimplemented&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>INTERNAL</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Internal&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>UNAVAILABLE</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Unavailable&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>DATA_LOSS</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;DataLoss&#39;</span>,
      <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>UNAUTHENTICATED</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Unauthenticated&#39;</span>
    }<span style=color:#719e07>.</span>freeze

    <span style=color:#719e07>attr_accessor</span> <span style=color:#2aa198>:exception</span>
    <span style=color:#719e07>attr_reader</span> <span style=color:#2aa198>:method</span>, <span style=color:#2aa198>:service</span>, <span style=color:#2aa198>:code</span>, <span style=color:#2aa198>:start_time</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>(<span style=color:#b58900>method</span>, code, start_time)
      @service <span style=color:#719e07>=</span> service_name(<span style=color:#b58900>method</span>)
      @method <span style=color:#719e07>=</span> method_name(<span style=color:#b58900>method</span>)
      @code <span style=color:#719e07>=</span> code
      @start_time <span style=color:#719e07>=</span> start_time
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>to_h</span>
      result <span style=color:#719e07>=</span> {
        <span style=color:#2aa198>&#39;grpc.service&#39;</span> <span style=color:#719e07>=&gt;</span> service,
        <span style=color:#2aa198>&#39;grpc.method&#39;</span> <span style=color:#719e07>=&gt;</span> <span style=color:#b58900>method</span>,
        <span style=color:#2aa198>&#39;grpc.code&#39;</span> <span style=color:#719e07>=&gt;</span> <span style=color:#cb4b16>CODES</span><span style=color:#719e07>.</span>fetch(code, code<span style=color:#719e07>.</span>to_s),
        <span style=color:#2aa198>&#39;grpc.start_time&#39;</span> <span style=color:#719e07>=&gt;</span> start_time<span style=color:#719e07>.</span>utc,
        <span style=color:#2aa198>&#39;grpc.time_ms&#39;</span> <span style=color:#719e07>=&gt;</span> elapsed_milliseconds,
        <span style=color:#2aa198>&#39;pid&#39;</span> <span style=color:#719e07>=&gt;</span> <span style=color:#cb4b16>Process</span><span style=color:#719e07>.</span>pid
      }
      result<span style=color:#719e07>.</span>merge!(<span style=color:#2aa198>&#39;exception&#39;</span> <span style=color:#719e07>=&gt;</span> exception) <span style=color:#719e07>if</span> exception
      result
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>private</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>elapsed_milliseconds</span>
      (<span style=color:#cb4b16>Time</span><span style=color:#719e07>.</span>now <span style=color:#719e07>-</span> start_time) <span style=color:#719e07>*</span> <span style=color:#2aa198>1000</span><span style=color:#719e07>.</span><span style=color:#2aa198>0</span>
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>method_name</span>(<span style=color:#b58900>method</span>)
      owner <span style=color:#719e07>=</span> <span style=color:#b58900>method</span><span style=color:#719e07>.</span>owner
      method_name, <span style=color:#719e07>=</span> owner<span style=color:#719e07>.</span>rpc_descs<span style=color:#719e07>.</span>find <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>k, _<span style=color:#719e07>|</span>
        <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>GenericService</span><span style=color:#719e07>.</span>underscore(k<span style=color:#719e07>.</span>to_s) <span style=color:#719e07>==</span> <span style=color:#b58900>method</span><span style=color:#719e07>.</span>name<span style=color:#719e07>.</span>to_s
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>return</span> <span style=color:#2aa198>&#39;(unknown)&#39;</span> <span style=color:#719e07>if</span> method_name<span style=color:#719e07>.</span>nil?

      method_name<span style=color:#719e07>.</span>to_s
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>service_name</span>(<span style=color:#b58900>method</span>)
      <span style=color:#b58900>method</span><span style=color:#719e07>.</span>owner<span style=color:#719e07>.</span>service_name
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>
</code></pre></div><p><code>Payload</code> is only a wrapper around the gRPC <code>method</code> object, the start time of
the request, and the gRPC response code. Additionally, it can take an
<code>exception</code> if our interceptor hits an error of sorts.</p><p>Lastly, in its <code>to_h</code> method, the <code>Paylaod</code> object creates a hash that we can
use to send to our logger. Using this approach, all of the complexity related
to extracting relevant data for logging responsibility of the <code>Payload</code> class,
while the interceptor has to only care about logging the payload.</p><p>This way, we have separation of concerns, and each entity has single
responsibility.</p><h2 id=logging-interceptor>Logging Interceptor<a hidden class=anchor aria-hidden=true href=#logging-interceptor>#</a></h2><p>Say we have an application that speaks gRPC, and we want each inbound request
to emit a logline formatted as a valid JSON. You can imagine that we can send
the logger&rsquo;s output to STDOUT, and we can export it and index it for further
exploration.</p><p>A straightforward implementation of a server interceptor:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#586e75># lib/grpclog/server_interceptor.rb</span>

<span style=color:#719e07>module</span> Grpclog
  <span style=color:#719e07>class</span> <span style=color:#268bd2>ServerInterceptor</span> <span style=color:#719e07>&lt;</span> <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span>
    <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>(logger, level <span style=color:#719e07>=</span> <span style=color:#2aa198>:info</span>)
      @logger <span style=color:#719e07>=</span> logger
      @level <span style=color:#719e07>=</span> level

      <span style=color:#719e07>super</span>()
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>request_response</span>(<span style=color:#2aa198>_request</span>: <span style=color:#719e07>nil</span>, <span style=color:#2aa198>call</span>: <span style=color:#719e07>nil</span>, <span style=color:#b58900>method</span>: <span style=color:#719e07>nil</span>, <span style=color:#719e07>&amp;</span>block)
      log(<span style=color:#b58900>method</span>, call, <span style=color:#719e07>&amp;</span>block)
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>server_streamer</span>(<span style=color:#2aa198>_request</span>: <span style=color:#719e07>nil</span>, <span style=color:#2aa198>call</span>: <span style=color:#719e07>nil</span>, <span style=color:#b58900>method</span>: <span style=color:#719e07>nil</span>, <span style=color:#719e07>&amp;</span>block)
      log(<span style=color:#b58900>method</span>, call, <span style=color:#719e07>&amp;</span>block)
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>client_streamer</span>(<span style=color:#2aa198>call</span>: <span style=color:#719e07>nil</span>, <span style=color:#b58900>method</span>: <span style=color:#719e07>nil</span>, <span style=color:#719e07>&amp;</span>block)
      log(<span style=color:#b58900>method</span>, call, <span style=color:#719e07>&amp;</span>block)
    <span style=color:#719e07>end</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>bidi_streamer</span>(<span style=color:#2aa198>_request</span>: <span style=color:#719e07>nil</span>, <span style=color:#2aa198>call</span>: <span style=color:#719e07>nil</span>, <span style=color:#b58900>method</span>: <span style=color:#719e07>nil</span>, <span style=color:#719e07>&amp;</span>block)
      log(<span style=color:#b58900>method</span>, call, <span style=color:#719e07>&amp;</span>block)
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>The interceptor will implement all four gRPC method types, where each of them
will invoke the same method: <code>log</code>. The <code>log</code> method will take the method name
and the <code>call</code> object as arguments, and the gRPC method will <code>yield</code> to the
<code>log</code> method.</p><p>Let&rsquo;s look quickly at the <code>log</code> method:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#719e07>def</span> <span style=color:#268bd2>log</span>(<span style=color:#b58900>method</span>, _call)
  start_time <span style=color:#719e07>=</span> <span style=color:#cb4b16>Time</span><span style=color:#719e07>.</span>now
  code <span style=color:#719e07>=</span> <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>OK</span>

  <span style=color:#719e07>yield</span>
<span style=color:#719e07>rescue</span> <span style=color:#cb4b16>StandardError</span> <span style=color:#719e07>=&gt;</span> e
  code <span style=color:#719e07>=</span> e<span style=color:#719e07>.</span>is_a?(<span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>BadStatus</span>) ? e<span style=color:#719e07>.</span>code : <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>UNKNOWN</span>

  <span style=color:#719e07>raise</span>
<span style=color:#719e07>ensure</span>
  payload <span style=color:#719e07>=</span> <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Payload</span><span style=color:#719e07>.</span>new(<span style=color:#b58900>method</span>, code, start_time)

  <span style=color:#719e07>if</span> e
    payload<span style=color:#719e07>.</span>exception <span style=color:#719e07>=</span> e<span style=color:#719e07>.</span>message
    @level <span style=color:#719e07>=</span> <span style=color:#2aa198>:error</span>
  <span style=color:#719e07>end</span>

  @logger<span style=color:#719e07>.</span>formatter <span style=color:#719e07>=</span> <span style=color:#b58900>method</span>(<span style=color:#2aa198>:formatter</span>)
  @logger<span style=color:#719e07>.</span>send(@level, payload<span style=color:#719e07>.</span>to_h)
<span style=color:#719e07>end</span>
</code></pre></div><p>While the method is a bit busy, it doesn&rsquo;t do <em>much</em>:</p><ul><li>It records the <code>start</code> time of the request, so later we can see the time
spent during the call, and we can log it</li><li>It <code>rescue</code>s any error, to find out the error type so we can log the error
type</li><li>It <code>ensure</code>s to create a <code>Payload</code>, which is a PORO containing the data we
want to log that packs it all in a hash, and then logging it using the
interceptor&rsquo;s logger</li></ul><p>We can see here how the <code>Payload</code> class is incorporated – by adding the new
object, we hide all of the complexity to building the log payload, and at the
end, we invoke the <code>to_h</code> method.</p><p>Testing the <code>Payload</code> class is straightforward; therefore, we will skip its
test for brevity&rsquo;s sake.</p><p>Let&rsquo;s look at how we can test our server interceptor.</p><h2 id=testing-interceptors>Testing interceptors<a hidden class=anchor aria-hidden=true href=#testing-interceptors>#</a></h2><p>To test our interceptor, we need to think about the various types of tests:</p><ul><li><strong>Unit tests</strong>, where we invoke the methods in the test using doubles for
dependencies, having isolation from the rest of the gRPC stack</li><li><strong>Integration tests</strong>, where we mount the request on a test gRPC server, and
we send requests via the network</li></ul><p><strong>Before we begin</strong>, a fair warning: testing interceptors in Ruby is messy (as
you are about to find out). If you have figured out a cleaner approach, please
drop me a line and let me know!</p><h3 id=unit-testing-intercetoprs>Unit testing intercetoprs<a hidden class=anchor aria-hidden=true href=#unit-testing-intercetoprs>#</a></h3><p>When looking at the implementation of the interceptors, we can notice that to
do any testing, we will need to mock out all gRPC-related dependencies:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#719e07>module</span> Grpclog
  <span style=color:#719e07>class</span> <span style=color:#268bd2>ServerInterceptor</span> <span style=color:#719e07>&lt;</span> <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span>
    <span style=color:#586e75># Snipped for brevity</span>

    <span style=color:#719e07>def</span> <span style=color:#268bd2>request_response</span>(<span style=color:#2aa198>request</span>: <span style=color:#719e07>nil</span>, <span style=color:#2aa198>call</span>: <span style=color:#719e07>nil</span>, <span style=color:#b58900>method</span>: <span style=color:#719e07>nil</span>, <span style=color:#719e07>&amp;</span>block)
      log(<span style=color:#b58900>method</span>, call, <span style=color:#719e07>&amp;</span>block)
    <span style=color:#719e07>end</span>

    <span style=color:#586e75># Snipped for brevity</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>The <code>request</code>, <code>call</code>, and <code>method</code> objects are dependencies that the
interceptor&rsquo;s interface forces upon us during testing. Even though our <code>log</code>
method does not use the <code>request</code> object, we will have to satisfy the interface
of the interceptor.</p><p>Additionally, if we look at the <code>log</code> method, we will see that we do not use
the <code>_call</code> object, but the method extensively uses the <code>method</code> object and the
<code>Payload</code> object that we will create in it:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#719e07>def</span> <span style=color:#268bd2>log</span>(<span style=color:#b58900>method</span>, _call)
  <span style=color:#586e75># Snipped for brevity</span>

  <span style=color:#719e07>yield</span>
<span style=color:#719e07>rescue</span> <span style=color:#cb4b16>StandardError</span> <span style=color:#719e07>=&gt;</span> e
  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>ensure</span>
  payload <span style=color:#719e07>=</span> <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Payload</span><span style=color:#719e07>.</span>new(<span style=color:#b58900>method</span>, code, start_time)

  <span style=color:#586e75># Snipped for brevity</span>

  @logger<span style=color:#719e07>.</span>send(@level, payload<span style=color:#719e07>.</span>to_h)
<span style=color:#719e07>end</span>
</code></pre></div><p>And the <code>Payload#method_name</code> and <code>Payload#service_name</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#586e75># lib/grpclog/payload.rb</span>

<span style=color:#719e07>def</span> <span style=color:#268bd2>method_name</span>(<span style=color:#b58900>method</span>)
  owner <span style=color:#719e07>=</span> <span style=color:#b58900>method</span><span style=color:#719e07>.</span>owner
  method_name, <span style=color:#719e07>=</span> owner<span style=color:#719e07>.</span>rpc_descs<span style=color:#719e07>.</span>find <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>k, _<span style=color:#719e07>|</span>
    <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>GenericService</span><span style=color:#719e07>.</span>underscore(k<span style=color:#719e07>.</span>to_s) <span style=color:#719e07>==</span> <span style=color:#b58900>method</span><span style=color:#719e07>.</span>name<span style=color:#719e07>.</span>to_s
  <span style=color:#719e07>end</span>

  <span style=color:#719e07>return</span> <span style=color:#2aa198>&#39;(unknown)&#39;</span> <span style=color:#719e07>if</span> method_name<span style=color:#719e07>.</span>nil?

  method_name<span style=color:#719e07>.</span>to_s
<span style=color:#719e07>end</span>

<span style=color:#719e07>def</span> <span style=color:#268bd2>service_name</span>(<span style=color:#b58900>method</span>)
  <span style=color:#b58900>method</span><span style=color:#719e07>.</span>owner<span style=color:#719e07>.</span>service_name
<span style=color:#719e07>end</span>
</code></pre></div><p>Given the extensive use of the <code>method</code> object, it&rsquo;s clear that a simple
<code>double</code> won&rsquo;t do the trick.</p><p>Additionally, to unit test the service in isolation without extra dependencies,
we would also have to define a gRPC service stub and implement it. That would
allow us to have the test self-contained without the need for additional
support files.</p><p>Without kicking the can down the road, let&rsquo;s first see the setup that we
will need for our unit tests:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  let(<span style=color:#2aa198>:rpc_class</span>) {
    <span style=color:#cb4b16>Class</span><span style=color:#719e07>.</span>new <span style=color:#719e07>do</span>
      <span style=color:#719e07>include</span> <span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>GenericService</span>

      <span style=color:#b58900>self</span><span style=color:#719e07>.</span>marshal_class_method <span style=color:#719e07>=</span> <span style=color:#2aa198>:encode</span>
      <span style=color:#b58900>self</span><span style=color:#719e07>.</span>unmarshal_class_method <span style=color:#719e07>=</span> <span style=color:#2aa198>:decode</span>
      <span style=color:#b58900>self</span><span style=color:#719e07>.</span>service_name <span style=color:#719e07>=</span> <span style=color:#2aa198>&#39;test.Test&#39;</span>

      rpc <span style=color:#2aa198>:Greet</span>, <span style=color:#cb4b16>Google</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Protobuf</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StringValue</span>, <span style=color:#cb4b16>Google</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Protobuf</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Empty</span>
    <span style=color:#719e07>end</span>
  }

  let(<span style=color:#2aa198>:service_class</span>) {
    <span style=color:#cb4b16>Class</span><span style=color:#719e07>.</span>new(rpc_class) <span style=color:#719e07>do</span>
      <span style=color:#719e07>def</span> <span style=color:#268bd2>greet</span>(_msg, _call)
        <span style=color:#586e75># Do nothing</span>
      <span style=color:#719e07>end</span>
    <span style=color:#719e07>end</span>
  }

   <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>First, we will define the gRPC generic service class and the service class that
implements the generic class. The service will have only one method – <code>Greet</code>
- which will take a simple string value and return an empty value (i.e.,
Protobuf defined as <code>Google::Protobuf::Empty</code>).</p><p>The actual implementation of the <code>greet</code> method will be empty – in the spec, we
will be testing the interceptor, not the real method, so we don&rsquo;t care about
its implementation.</p><p>Now that we have these classes in place, let&rsquo;s continue with the test setup:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  <span style=color:#586e75># Snipped for brevity</span>

  let(<span style=color:#2aa198>:method</span>) { service_class<span style=color:#719e07>.</span>new<span style=color:#719e07>.</span>method(<span style=color:#2aa198>:greet</span>) }
  let(<span style=color:#2aa198>:request</span>) { double }
  let(<span style=color:#2aa198>:call</span>) { double(<span style=color:#2aa198>:call</span>, <span style=color:#2aa198>peer</span>: <span style=color:#2aa198>&#34;&#34;</span>, <span style=color:#2aa198>metadata</span>: {}) }

  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>We have to create a few values that we will use in the specs:</p><ul><li>The gRPC <code>method</code> object</li><li>The gRPC <code>request</code> – a blank double</li><li>The gRPC <code>call</code> – a double with <code>peer</code> and <code>metadata</code> attributes</li></ul><p>We do not need to set <code>peer</code> and <code>metadata</code> to any values for our specs.
However, keep in mind that if your interceptor accesses these attributes, like
if the interceptor extracts the <code>User-agent</code> from the call, you must set these
attributes on the <code>call</code> object.</p><p>Next, let&rsquo;s look at the remainder of the spec setup:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  <span style=color:#586e75># Snipped for brevity</span>

  let(<span style=color:#2aa198>:interceptor</span>) { described_class<span style=color:#719e07>.</span>new(logger) }

  subject(<span style=color:#2aa198>:logger</span>) { <span style=color:#cb4b16>Logger</span><span style=color:#719e07>.</span>new(<span style=color:#cb4b16>STDOUT</span>) }

  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>Lastly, we create the <code>interceptor</code> object, and pass a <code>logger</code> to the
constructor. The <code>subject</code> of our specs will be the <code>logger</code> object, as we
will be asserting whether the interceptor invokes the correct methods on the
<code>logger</code> (as seen in the implementation of the interceptor).</p><p>Let&rsquo;s finally look at the actual specs:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  <span style=color:#586e75># Snipped for brevity</span>

  describe <span style=color:#2aa198>&#39;#request_response_method&#39;</span> <span style=color:#719e07>do</span>
    before { allow(subject)<span style=color:#719e07>.</span>to receive(<span style=color:#2aa198>:send</span>) }

    context <span style=color:#2aa198>&#39;when no exception occurs&#39;</span> <span style=color:#719e07>do</span>
      before { interceptor<span style=color:#719e07>.</span>request_response(<span style=color:#2aa198>request</span>: request, <span style=color:#2aa198>call</span>: call, <span style=color:#b58900>method</span>: <span style=color:#b58900>method</span>) { } }

      it { is_expected<span style=color:#719e07>.</span>to have_received(<span style=color:#2aa198>:send</span>)<span style=color:#719e07>.</span>with(<span style=color:#2aa198>:info</span>, <span style=color:#cb4b16>Hash</span>) }
    <span style=color:#719e07>end</span>

    context <span style=color:#2aa198>&#39;when a known exception occurs&#39;</span> <span style=color:#719e07>do</span>
      before <span style=color:#719e07>do</span>
        expect <span style=color:#719e07>do</span>
          interceptor<span style=color:#719e07>.</span>request_response(<span style=color:#2aa198>request</span>: request, <span style=color:#2aa198>call</span>: call, <span style=color:#b58900>method</span>: <span style=color:#b58900>method</span>) <span style=color:#719e07>do</span>
            <span style=color:#719e07>raise</span> <span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>NotFound</span><span style=color:#719e07>.</span>new
          <span style=color:#719e07>end</span>
        <span style=color:#719e07>end</span><span style=color:#719e07>.</span>to raise_error(<span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>NotFound</span>)
      <span style=color:#719e07>end</span>

      it { is_expected<span style=color:#719e07>.</span>to have_received(<span style=color:#2aa198>:send</span>)<span style=color:#719e07>.</span>with(<span style=color:#2aa198>:error</span>, <span style=color:#cb4b16>Hash</span>) }
    <span style=color:#719e07>end</span>

    context <span style=color:#2aa198>&#39;when an unknown exception occurs&#39;</span> <span style=color:#719e07>do</span>
      before <span style=color:#719e07>do</span>
        expect <span style=color:#719e07>do</span>
          interceptor<span style=color:#719e07>.</span>request_response(<span style=color:#2aa198>request</span>: request, <span style=color:#2aa198>call</span>: call, <span style=color:#b58900>method</span>: <span style=color:#b58900>method</span>) { <span style=color:#719e07>raise</span> <span style=color:#2aa198>:unknown</span> }
        <span style=color:#719e07>end</span><span style=color:#719e07>.</span>to raise_error(<span style=color:#cb4b16>StandardError</span>)
      <span style=color:#719e07>end</span>

      it { is_expected<span style=color:#719e07>.</span>to have_received(<span style=color:#2aa198>:send</span>)<span style=color:#719e07>.</span>with(<span style=color:#2aa198>:error</span>, <span style=color:#cb4b16>Hash</span>) }
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>

  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>We are looking at three different tests here:</p><ol><li>Test the logging behavior when no errors occur</li><li>Test the behavior when a known error occurs, and</li><li>Test the behavior when an unknown error occurs</li></ol><p>The core of the test is the expectation that the interceptor will call a method
on the <code>logger</code> object, which will effectively log a line (which is the purpose
of the interceptor).</p><p>Before we kick off the test, we set an <a href=https://relishapp.com/rspec/rspec-mocks/docs/basics/spies>RSpec
spy</a>, which will
watch for any invocations of the <code>send</code> method on the <code>logger</code> object (i.e.,
the <code>subject</code>). This spy will allow us to assert later whether the code invoked
<code>send</code> on the <code>logger</code> object, and with what arguments, too.</p><p>We will invoke the <code>request_response</code> method on the interceptor, with its
required argument within each spec. In other words, the <code>request_response</code>
method is the unit under test here. Hence, for every spec, we call the method
in a <code>before</code> block.</p><p>In the first spec, we invoke the method with an empty body within the <code>when no exception occurs</code> context. The interceptor will take the empty block, evaluate
it and log the request line. We set the expectation that when the interceptor
hits no errors, the <code>logger</code> will receive <code>send</code> with the <code>:info</code> argument
(i.e., the log level) and a <code>Hash</code>, which is the payload:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#586e75># lib/grpclog/server_interceptor.rb</span>

@logger<span style=color:#719e07>.</span>send(@level, payload<span style=color:#719e07>.</span>to_h)
</code></pre></div><p>In the second spec, within the <code>when a known exception occurs</code> context, we use
the same approach as before with one key difference: the block evaluated by the
interceptor will raise a (known) error. In such a case, we set the expectation
that the <code>logger</code> will receive <code>send</code> with the <code>:error</code> argument (i.e., the log
level) and the payload <code>Hash</code>.</p><p>Lastly, in the third spec, within the <code>when an unknown exception occurs</code>
context, we follow a similar approach to the second spec, but we raise an
unknown error this time. In such a case, we set the expectation that the
<code>logger</code> will receive <code>send</code> with the <code>:error</code> argument (i.e., the log level)
and the payload <code>Hash</code> – identical to the one above.</p><p>Given that our interceptor methods perform the same functionality for all
request types, the other tests are similar to those above. To prove that the
same test approach will work for the other method, here&rsquo;s the <code>bidi_streamer</code>
spec:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  <span style=color:#586e75># Snipped for brevity</span>

  describe <span style=color:#2aa198>&#39;#bidi_streamer&#39;</span> <span style=color:#719e07>do</span>
    before { allow(subject)<span style=color:#719e07>.</span>to receive(<span style=color:#2aa198>:send</span>) }

    context <span style=color:#2aa198>&#39;when no exception occurs&#39;</span> <span style=color:#719e07>do</span>
      before { interceptor<span style=color:#719e07>.</span>bidi_streamer(<span style=color:#2aa198>requests</span>: <span style=color:#719e07>[</span>request<span style=color:#719e07>]</span>, <span style=color:#2aa198>call</span>: call, <span style=color:#b58900>method</span>: <span style=color:#b58900>method</span>) { } }

      it { is_expected<span style=color:#719e07>.</span>to have_received(<span style=color:#2aa198>:send</span>)<span style=color:#719e07>.</span>with(<span style=color:#2aa198>:info</span>, <span style=color:#cb4b16>Hash</span>) }
    <span style=color:#719e07>end</span>

    context <span style=color:#2aa198>&#39;when a known exception occurs&#39;</span> <span style=color:#719e07>do</span>
      before <span style=color:#719e07>do</span>
        expect <span style=color:#719e07>do</span>
          interceptor<span style=color:#719e07>.</span>bidi_streamer(<span style=color:#2aa198>requests</span>: <span style=color:#719e07>[</span>request<span style=color:#719e07>]</span>, <span style=color:#2aa198>call</span>: call, <span style=color:#b58900>method</span>: <span style=color:#b58900>method</span>) <span style=color:#719e07>do</span>
            <span style=color:#719e07>raise</span> <span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>NotFound</span><span style=color:#719e07>.</span>new
          <span style=color:#719e07>end</span>
        <span style=color:#719e07>end</span><span style=color:#719e07>.</span>to raise_error(<span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>NotFound</span>)
      <span style=color:#719e07>end</span>

      it { is_expected<span style=color:#719e07>.</span>to have_received(<span style=color:#2aa198>:send</span>)<span style=color:#719e07>.</span>with(<span style=color:#2aa198>:error</span>, <span style=color:#cb4b16>Hash</span>) }
    <span style=color:#719e07>end</span>

    context <span style=color:#2aa198>&#39;when an unknown exception occurs&#39;</span> <span style=color:#719e07>do</span>
      before <span style=color:#719e07>do</span>
        expect <span style=color:#719e07>do</span>
          interceptor<span style=color:#719e07>.</span>bidi_streamer(<span style=color:#2aa198>requests</span>: <span style=color:#719e07>[</span>request<span style=color:#719e07>]</span>, <span style=color:#2aa198>call</span>: call, <span style=color:#b58900>method</span>: <span style=color:#b58900>method</span>) { <span style=color:#719e07>raise</span> <span style=color:#2aa198>:unknown</span> }
        <span style=color:#719e07>end</span><span style=color:#719e07>.</span>to raise_error(<span style=color:#cb4b16>StandardError</span>)
      <span style=color:#719e07>end</span>

      it { is_expected<span style=color:#719e07>.</span>to have_received(<span style=color:#2aa198>:send</span>)<span style=color:#719e07>.</span>with(<span style=color:#2aa198>:error</span>, <span style=color:#cb4b16>Hash</span>) }
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>

  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>If we run the specs, this is the output we will get:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>root@e4cdc18cf452:/app# bundle <span style=color:#b58900>exec</span> rspec --format documentation spec/grpclog/server_interceptor_spec.rb

Grpclog::ServerInterceptor
  <span style=color:#586e75>#request_response_method</span>
    when no exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:info, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when a known exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when an unknown exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
  <span style=color:#586e75>#server_streamer</span>
    when no exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:info, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when a known exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when an unknown exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
  <span style=color:#586e75>#client_streamer</span>
    when no exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:info, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when a known exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when an unknown exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
  <span style=color:#586e75>#bidi_streamer</span>
    when no exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:info, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when a known exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>
    when an unknown exception occurs
      is expected to have received send<span style=color:#719e07>(</span>:error, Hash<span style=color:#719e07>)</span> <span style=color:#2aa198>1</span> <span style=color:#b58900>time</span>

Finished in 0.02193 seconds <span style=color:#719e07>(</span>files took 0.16171 seconds to load<span style=color:#719e07>)</span>
<span style=color:#2aa198>12</span> examples, <span style=color:#2aa198>0</span> failures
</code></pre></div><p>One last note: while this approach works for my use case, remember that your
tests can vary depending on how complicated / what kind of work your
interceptors do. You might have to rely on more mocking, or you might need
more (detailed) specs. Still, knowing the above setup, you are on an excellent
path to start unit testing your interceptors.</p><h3 id=integration-testing-interceptors>Integration testing interceptors<a hidden class=anchor aria-hidden=true href=#integration-testing-interceptors>#</a></h3><p>To begin integration testing the interceptor, we first need to add some
supporting infrastructure. We first need to define a dummy gRPC service that
will have an RPC method for each method type:</p><ul><li>Unary</li><li>Server streaming</li><li>Client streaming</li><li>Bi-directional streaming</li></ul><p>After the service is defined, we need to implement a skeleton service to return
a simple response to the RPC call. Once these pieces are in place, we can mount
our interceptor to the implementation and test that the server will correctly
invoke it.</p><h4 id=service--message-definitions>Service & message definitions<a hidden class=anchor aria-hidden=true href=#service--message-definitions>#</a></h4><p>First, let&rsquo;s look at the Protobuf definition of the dummy service and its
message:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=color:#586e75>// spec/support/greeter.proto
</span><span style=color:#586e75></span>
syntax <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;proto3&#34;</span>;

<span style=color:#719e07>package</span> grpclog;

<span style=color:#268bd2>service</span> Greeter {
  <span style=color:#719e07>rpc</span> RequestResponseMethod(Hello) <span style=color:#719e07>returns</span> (Hello) {}
  <span style=color:#719e07>rpc</span> ServerStreamMethod(Hello) <span style=color:#719e07>returns</span> (stream Hello) {}
  <span style=color:#719e07>rpc</span> ClientStreamMethod(stream Hello) <span style=color:#719e07>returns</span> (Hello) {}
  <span style=color:#719e07>rpc</span> BidiStreamMethod(stream Hello) <span style=color:#719e07>returns</span> (stream Hello) {}
}

<span style=color:#268bd2>message</span> <span style=color:#268bd2>Hello</span> {
  <span style=color:#dc322f>string</span> name <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
  <span style=color:#dc322f>int64</span> error_code <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span>;
}
</code></pre></div><p>Each of the RPCs defined on the <code>Greeter</code> service will map to the respective
method type, as supported by gRPC.</p><p>Next, we can generate the server and client stubs from the Protobuf code. Let&rsquo;s
define a small <code>rake</code> command to aid us with this, as part of the project&rsquo;s
<code>Rakefile</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#586e75># Rakefile</span>

namespace <span style=color:#2aa198>:test</span> <span style=color:#719e07>do</span>
  desc <span style=color:#2aa198>&#39;Generate test protobuf stubs&#39;</span>
  task <span style=color:#2aa198>:generate_proto</span> <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>_task, _args<span style=color:#719e07>|</span>
    <span style=color:#b58900>system</span> <span style=color:#2aa198>&#39;bundle exec grpc_tools_ruby_protoc --ruby_out=. --grpc_out=. spec/support/greeter/greeter.proto&#39;</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>Now that we have the <code>rake test:generate_proto</code> task, we can use it to generate
the files (output shortened for brevity):</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>root@d20bd4fd8613:/app# rake test:generate_proto
root@d20bd4fd8613:/app# ls -la spec/support/greeter/
-rw-r--r--  <span style=color:#2aa198>1</span> root root   <span style=color:#2aa198>353</span> Nov  <span style=color:#2aa198>1</span> 10:50 greeter.proto
-rw-r--r--  <span style=color:#2aa198>1</span> root root   <span style=color:#2aa198>482</span> Nov  <span style=color:#2aa198>2</span> 20:54 greeter_pb.rb
-rw-r--r--  <span style=color:#2aa198>1</span> root root   <span style=color:#2aa198>739</span> Nov  <span style=color:#2aa198>2</span> 20:54 greeter_services_pb.rb
</code></pre></div><p>To be able to mount our server interceptor and test it, we will need to
implement an actual server, using the newly created <code>Greeter</code> service. The
server will have two parts: the service itself, with all its methods, and a
controller piece which will be the actual gRPC over HTTP/2 server.</p><h4 id=service-implementation>Service implementation<a hidden class=anchor aria-hidden=true href=#service-implementation>#</a></h4><p>First, let&rsquo;s put together the service methods:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#586e75># spec/support/greeter/server.rb</span>

<span style=color:#719e07>module</span> Grpclog
  <span style=color:#719e07>module</span> Greeter
    <span style=color:#719e07>class</span> <span style=color:#268bd2>Server</span> <span style=color:#719e07>&lt;</span> <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Greeter</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Service</span>
      <span style=color:#719e07>def</span> <span style=color:#268bd2>request_response_method</span>(msg, _call)
        raise_exception(msg)

        <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Hello</span><span style=color:#719e07>.</span>new(<span style=color:#b58900>name</span>: <span style=color:#2aa198>&#34;Hello </span><span style=color:#2aa198>#{</span>msg<span style=color:#719e07>.</span>name<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>)
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>def</span> <span style=color:#268bd2>server_stream_method</span>(msg, _call)
        raise_exception(msg)

        <span style=color:#719e07>[</span><span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Hello</span><span style=color:#719e07>.</span>new(<span style=color:#b58900>name</span>: <span style=color:#2aa198>&#39;Hello!&#39;</span>)<span style=color:#719e07>]</span>
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>def</span> <span style=color:#268bd2>client_stream_method</span>(call)
        call<span style=color:#719e07>.</span>each_remote_read <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>msg<span style=color:#719e07>|</span>
          raise_exception(msg)
        <span style=color:#719e07>end</span>

        <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Hello</span><span style=color:#719e07>.</span>new(<span style=color:#b58900>name</span>: <span style=color:#2aa198>&#39;Hello!&#39;</span>)
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>def</span> <span style=color:#268bd2>bidi_stream_method</span>(call, _view)
        call<span style=color:#719e07>.</span>each <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>msg<span style=color:#719e07>|</span>
          raise_exception(msg)
        <span style=color:#719e07>end</span>

        <span style=color:#719e07>[</span><span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Hello</span><span style=color:#719e07>.</span>new(<span style=color:#b58900>name</span>: <span style=color:#2aa198>&#39;Hello!&#39;</span>)<span style=color:#719e07>]</span>
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>def</span> <span style=color:#268bd2>raise_exception</span>(msg)
        code <span style=color:#719e07>=</span> msg<span style=color:#719e07>.</span>error_code

        <span style=color:#719e07>raise</span> <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>BadStatus</span><span style=color:#719e07>.</span>new_status_exception(code, <span style=color:#2aa198>&#39;test exception&#39;</span>) <span style=color:#719e07>if</span> code <span style=color:#719e07>&gt;</span> <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>OK</span>
        <span style=color:#719e07>raise</span> code<span style=color:#719e07>.</span>to_s <span style=color:#719e07>if</span> code <span style=color:#719e07>&lt;</span> <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>OK</span>
      <span style=color:#719e07>end</span>
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>The <code>Server</code> implements the four methods, as defined in the Profobuf
definition. We keep the implementations lightweight, where each RPC method will
consume the request/stream and return a blank response. We leave the server as
a &ldquo;shell&rdquo; because we will use it to mount our interceptor for testing and only
that.</p><p>The <code>raise_exception</code> method is there to help us with raising an exception
during testing. During testing, it allows us to send an <code>error_code</code> in the
request and make the <code>Server</code> raise the exception. While we wouldn&rsquo;t implement
such a method in a real server, this is a neat trick for testing purposes.</p><p>Now, to boot this server during testing, we will need a gRPC server
implementation.</p><h4 id=grpc-server-implementation>gRPC Server Implementation<a hidden class=anchor aria-hidden=true href=#grpc-server-implementation>#</a></h4><p>Let&rsquo;s introduce a <code>Controller</code> class, which will do a few things:</p><ul><li>Initialize a new gRPC server object, with a host and a port</li><li>Set up the gRPC server: mount the service and add the interceptors</li><li>Provide an interface to start the server by kicking off a server thread</li><li>Provide an interface to stop the server by terminating the server thread</li></ul><p>Let&rsquo;s quickly see the <code>Controller</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#586e75># spec/support/greeter/controller.rb</span>

<span style=color:#586e75># rubocop:disable Style/ClassVars</span>
<span style=color:#719e07>module</span> Grpclog
  <span style=color:#719e07>module</span> Greeter
    <span style=color:#719e07>class</span> <span style=color:#268bd2>Controller</span>
      @@port <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>

      <span style=color:#719e07>class</span> <span style=color:#719e07>&lt;&lt;</span> <span style=color:#b58900>self</span>
        <span style=color:#719e07>def</span> <span style=color:#268bd2>next_port</span>
          @@port <span style=color:#719e07>+=</span> <span style=color:#2aa198>1</span>
        <span style=color:#719e07>end</span>
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>attr_reader</span> <span style=color:#2aa198>:host</span>

      <span style=color:#719e07>def</span> <span style=color:#268bd2>initialize</span>(<span style=color:#2aa198>interceptors</span>: <span style=color:#719e07>[]</span>, <span style=color:#2aa198>service</span>: <span style=color:#cb4b16>Server</span>)
        @host <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;0.0.0.0:8008</span><span style=color:#2aa198>#{</span><span style=color:#b58900>self</span><span style=color:#719e07>.</span>class<span style=color:#719e07>.</span>next_port<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>
        @server <span style=color:#719e07>=</span> <span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>RpcServer</span><span style=color:#719e07>.</span>new(
          <span style=color:#2aa198>poll_period</span>: <span style=color:#2aa198>1</span>,
          <span style=color:#2aa198>pool_keep_alive</span>: <span style=color:#2aa198>1</span>,
          <span style=color:#2aa198>interceptors</span>: interceptors
        )
        @server<span style=color:#719e07>.</span>add_http2_port(host, <span style=color:#2aa198>:this_port_is_insecure</span>)
        @server<span style=color:#719e07>.</span>handle(service)
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>def</span> <span style=color:#268bd2>start</span>
        @server_thread <span style=color:#719e07>=</span> <span style=color:#cb4b16>Thread</span><span style=color:#719e07>.</span>new { @server<span style=color:#719e07>.</span>run_till_terminated }
      <span style=color:#719e07>end</span>

      <span style=color:#719e07>def</span> <span style=color:#268bd2>stop</span>
        @server<span style=color:#719e07>.</span>stop
        @server_thread<span style=color:#719e07>.</span>join
        @server_thread<span style=color:#719e07>.</span>terminate
      <span style=color:#719e07>end</span>
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>
<span style=color:#586e75># rubocop:enable all</span>
</code></pre></div><p>We first establish a <code>GRPC::RpcServer</code> during the initialization phase, the
actual gRPC server implementation, as provided by the <code>grpc</code> gem. We then set
up the gRPC server by attaching a <code>host:port</code> that it will listen to, and we
specify that the HTTP/2 connection will be insecure by using the
<code>:this_port_is_insecure</code> option.</p><p>When setting the <code>port,</code> we use a small trick. Namely, we have a <code>next_port</code>
class method that keeps track of the number of servers we run concurrently.
Then, every time we launch a new <code>Controller</code>, we increment the port number by
one. This trick allows us to spin up multiple instances of the <code>Controller</code>
without them trying to reuse the same port, giving us the ability to run our
tests in parallel.</p><p>(The trick is blatantly borrowed (or, rather, stolen) from the
<a href=https://github.com/iaintshine/ruby-grpc-opentracing/><code>ruby-grpc-opentracing</code>
gem</a>.)</p><p>In the <code>start</code> method, we create a new <code>Thread</code> and run the server. In the
<code>stop</code> method, we shut down the <code>GRPC::RpcServer</code> instance, and we also
terminate the server <code>Thread</code> that we start in the <code>start</code> method.</p><p>Next, we need the test set up to plug in our new interceptor and test it.</p><h4 id=integration-test-setup>Integration test setup<a hidden class=anchor aria-hidden=true href=#integration-test-setup>#</a></h4><p>We begin the test setup similarly to the unit test one, but with some crucial
differences:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  let(<span style=color:#2aa198>:log</span>) { <span style=color:#cb4b16>StringIO</span><span style=color:#719e07>.</span>new }
  let(<span style=color:#2aa198>:logger</span>) { <span style=color:#cb4b16>Logger</span><span style=color:#719e07>.</span>new(log) }

  let(<span style=color:#2aa198>:interceptor</span>) { described_class<span style=color:#719e07>.</span>new(logger) }
  let(<span style=color:#2aa198>:channel</span>) {
    <span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Channel</span><span style=color:#719e07>.</span>new(@server<span style=color:#719e07>.</span>host, <span style=color:#719e07>nil</span>, <span style=color:#2aa198>:this_channel_is_insecure</span>)
  }

  let(<span style=color:#2aa198>:client</span>) <span style=color:#719e07>do</span>
    <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Greeter</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Stub</span><span style=color:#719e07>.</span>new(
      @server<span style=color:#719e07>.</span>host,
      <span style=color:#2aa198>:this_channel_is_insecure</span>,
      <span style=color:#2aa198>channel_override</span>: channel,
      <span style=color:#2aa198>interceptors</span>: <span style=color:#719e07>[]</span>
    )
  <span style=color:#719e07>end</span>

  subject(<span style=color:#2aa198>:message</span>) { <span style=color:#cb4b16>JSON</span><span style=color:#719e07>.</span>parse(log<span style=color:#719e07>.</span>string) }

  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>Setting up the <code>interceptor</code> object by passing in a <code>logger</code> that takes a <code>log</code>
which is a <code>StringIO</code>, is very similar to what we saw before. Next, we create a
gRPC channel that connects to a gRPC server on a specified host and port.</p><p>We use the new <code>channel</code> to establish a <code>client</code> object, which uses the
generated <code>Grpclog::Greeter::Stub</code> class that we saw before. We will use the
<code>client</code> in our specs to send actual gRPC requests to the gRPC server we
implemented.</p><p>Lastly, the <code>subject</code> is the parsed JSON from the <code>log</code> buffer. We will use it
to set expectations that the interceptor logged our messages correctly.</p><p>Let&rsquo;s continue with our spec:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  <span style=color:#586e75># Snipped for brevity</span>

  before <span style=color:#719e07>do</span>
    @server <span style=color:#719e07>=</span> <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Greeter</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Controller</span><span style=color:#719e07>.</span>new(<span style=color:#2aa198>interceptors</span>: <span style=color:#719e07>[</span>interceptor<span style=color:#719e07>]</span>)
    @server<span style=color:#719e07>.</span>start
  <span style=color:#719e07>end</span>

  after <span style=color:#719e07>do</span>
    @server<span style=color:#719e07>&amp;.</span>stop
  <span style=color:#719e07>end</span>

  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>Here, we set the <code>before</code> and <code>after</code> blocks. In the <code>before</code> block, we
initialize the new gRPC server by using the <code>Grpclog::Greeter::Controller</code>
class. To it, we pass the <code>interceptor</code> object that we initialized before.</p><p>In the <code>after</code> block, we make sure to shut down the gRPC server if booted. We
want to perform this cleanup, so we do not leave gRPC server threads running
after our specs finish.</p><p>Let&rsquo;s look at a spec next:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=color:#cb4b16>RSpec</span><span style=color:#719e07>.</span>describe <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>ServerInterceptor</span> <span style=color:#719e07>do</span>
  <span style=color:#586e75># Snipped for brevity</span>

  subject(<span style=color:#2aa198>:logger</span>) { <span style=color:#cb4b16>Logger</span><span style=color:#719e07>.</span>new(<span style=color:#cb4b16>STDOUT</span>) }

  describe <span style=color:#2aa198>&#39;#server_streamer_method&#39;</span> <span style=color:#719e07>do</span>
    context <span style=color:#2aa198>&#39;when no exceptions are raised&#39;</span> <span style=color:#719e07>do</span>
      before <span style=color:#719e07>do</span>
        enumerator <span style=color:#719e07>=</span> client<span style=color:#719e07>.</span>server_streamer_method(<span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Hello</span><span style=color:#719e07>.</span>new)
        enumerator<span style=color:#719e07>.</span>each {} <span style=color:#586e75># Consume the stream</span>
      <span style=color:#719e07>end</span>

      it { is_expected<span style=color:#719e07>.</span>to <span style=color:#719e07>include</span>(<span style=color:#2aa198>&#39;grpc.code&#39;</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;OK&#39;</span>) }
    <span style=color:#719e07>end</span>

    context <span style=color:#2aa198>&#39;when an exception is raised&#39;</span> <span style=color:#719e07>do</span>
      before <span style=color:#719e07>do</span>
        expect <span style=color:#719e07>do</span>
          enumerator <span style=color:#719e07>=</span> client<span style=color:#719e07>.</span>server_streamer_method(
            <span style=color:#cb4b16>Grpclog</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Hello</span><span style=color:#719e07>.</span>new(<span style=color:#2aa198>error_code</span>: <span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Core</span><span style=color:#719e07>::</span><span style=color:#cb4b16>StatusCodes</span><span style=color:#719e07>::</span><span style=color:#cb4b16>UNKNOWN</span>)
          )
          enumerator<span style=color:#719e07>.</span>each {} <span style=color:#586e75># Consume the stream</span>
        <span style=color:#719e07>end</span><span style=color:#719e07>.</span>to raise_error(<span style=color:#719e07>::</span><span style=color:#cb4b16>GRPC</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Unknown</span>)
      <span style=color:#719e07>end</span>

      it { is_expected<span style=color:#719e07>.</span>to <span style=color:#719e07>include</span>(<span style=color:#2aa198>&#39;grpc.code&#39;</span> <span style=color:#719e07>=&gt;</span> <span style=color:#2aa198>&#39;Unknown&#39;</span>) }
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>

  <span style=color:#586e75># Snipped for brevity</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>We are looking at two different specs here: one where no exception is raised
and one that raises a <code>GRPC::Unknown</code>.</p><p>In the first spec, we use the service <code>client</code> to invoke the
<code>server_streamer_method</code>, passing in the argument the body of the request.
Since its a streaming RPC, the returned value of the client call is an
enumerator that allows us to consume the stream.</p><p>We consume the stream returned by the server, just by looping through the
enumerator without acting on the response data itself. Next, we simply assert
on the logged line expecting the logged <code>grpc.code</code> field to be <code>OK</code>.</p><p>On the next spec we use the trick allowing us to return an error from the
server. As part of the request body, we send the <code>error_code</code> set as
<code>GRPC::Core::StatusCodes::UNKNOWN</code>, which will make the server return the same
error. The rest of the test setup is like the one before it: we consume the
stream returned by the server, just by looping through the enumerator without
acting on the response data itself.</p><p>When it comes to the expectation itself, instead of asserting that the
<code>grpc.code</code> be <code>OK</code>, we assert that the code is the error we passed as the
<code>error_code</code> in the request - <code>Unknown</code>.</p><p>If we run the specs, we will see that they pass successfully:</p><pre><code>root@e4cdc18cf452:/app# bundle exec rspec spec/grpclog/integration/server_interceptor_spec.rb

Grpclog::ServerInterceptor
  #server_streamer_method
    when no exceptions are raised
      is expected to include {&quot;grpc.code&quot; =&gt; &quot;OK&quot;}
    when an exception is raised
      is expected to include {&quot;grpc.code&quot; =&gt; &quot;Unknown&quot;}

Finished in 0.06014 seconds (files took 0.19803 seconds to load)
2 examples, 0 failures
</code></pre><p>Evidently, the two types of specs are similar - this is mainly due to the
nature of the interceptor under test. On the other hand, the setup for the two
types of tests is different, with the integration specs being more involved and
requiring additional support files.</p><p>Still, the overhead can be worth it (depending on your case) as mounting the
interceptor on an actual gRPC server gives us the confidence that our server
interceptor will work correctly when mounted on a gRPC server in the wild.</p><p>If you would like to inspect the code for this article, head over to <a href=https://github.com/fteem/grpclog>its
repository</a>. You can check out the
implementation, and inspect the full list of specs, including the project
setup.</p><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to hundreds of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://ieftimov.com/post/how-to-make-the-step-up-from-intermediate-to-senior-engineer/><span class=title>« Prev Page</span><br><span>How to Make the Step up From Intermediate to Senior Engineer</span></a>
<a class=next href=https://ieftimov.com/post/docker-compose-stray-pids-rails-beyond/><span class=title>Next Page »</span><br><span>Docker Compose, stray PID files, Rails and beyond</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Creating and testing gRPC server interceptors in Ruby on twitter" href="https://twitter.com/intent/tweet/?text=Creating%20and%20testing%20gRPC%20server%20interceptors%20in%20Ruby&url=https%3a%2f%2fieftimov.com%2fpost%2fcreating-testing-grpc-server-interceptors-ruby%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating and testing gRPC server interceptors in Ruby on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fcreating-testing-grpc-server-interceptors-ruby%2f&title=Creating%20and%20testing%20gRPC%20server%20interceptors%20in%20Ruby&summary=Creating%20and%20testing%20gRPC%20server%20interceptors%20in%20Ruby&source=https%3a%2f%2fieftimov.com%2fpost%2fcreating-testing-grpc-server-interceptors-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating and testing gRPC server interceptors in Ruby on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fcreating-testing-grpc-server-interceptors-ruby%2f&title=Creating%20and%20testing%20gRPC%20server%20interceptors%20in%20Ruby"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating and testing gRPC server interceptors in Ruby on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fcreating-testing-grpc-server-interceptors-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating and testing gRPC server interceptors in Ruby on whatsapp" href="https://api.whatsapp.com/send?text=Creating%20and%20testing%20gRPC%20server%20interceptors%20in%20Ruby%20-%20https%3a%2f%2fieftimov.com%2fpost%2fcreating-testing-grpc-server-interceptors-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating and testing gRPC server interceptors in Ruby on telegram" href="https://telegram.me/share/url?text=Creating%20and%20testing%20gRPC%20server%20interceptors%20in%20Ruby&url=https%3a%2f%2fieftimov.com%2fpost%2fcreating-testing-grpc-server-interceptors-ruby%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>