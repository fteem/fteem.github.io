<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing in Go: WebSockets | Ilija Eftimov ⚡️</title><meta name=keywords content="websockets"><meta name=description content="WebSockets offer duplex communication from a non-trusted source to a server that we own across a TCP socket connection. This means that, instead of continually polling the web server for updates and having to perform the whole TCP dance with each request, we can maintain a single TCP socket connection and then send and listen to messages on said connection.
In Go&rsquo;s ecosystem there are few different implementations of the WebSocket protocol."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/testing-in-go-websockets/><link href=/assets/css/stylesheet.min.0c016bf8df20af25fb1fecc0f0fe602e81ea9fd3d9f96c8995b7d48ec2a0b8a3.css integrity="sha256-DAFr+N8gryX7H+zA8P5gLoHqn9PZ+WyJlbfUjsKguKM=" rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="Testing in Go: WebSockets"><meta property="og:description" content="WebSockets offer duplex communication from a non-trusted source to a server that we own across a TCP socket connection. This means that, instead of continually polling the web server for updates and having to perform the whole TCP dance with each request, we can maintain a single TCP socket connection and then send and listen to messages on said connection.
In Go&rsquo;s ecosystem there are few different implementations of the WebSocket protocol."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/testing-in-go-websockets/"><meta property="og:image" content="https://ieftimov.com/cards/testing-in-go-websockets.gif"><meta property="article:published_time" content="2020-02-22T12:32:51+01:00"><meta property="article:modified_time" content="2020-02-22T12:32:51+01:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/testing-in-go-websockets.gif"><meta name=twitter:title content="Testing in Go: WebSockets"><meta name=twitter:description content="WebSockets offer duplex communication from a non-trusted source to a server that we own across a TCP socket connection. This means that, instead of continually polling the web server for updates and having to perform the whole TCP dance with each request, we can maintain a single TCP socket connection and then send and listen to messages on said connection.
In Go&rsquo;s ecosystem there are few different implementations of the WebSocket protocol."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Testing in Go: WebSockets","item":"https://ieftimov.com/post/testing-in-go-websockets/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing in Go: WebSockets","name":"Testing in Go: WebSockets","description":"WebSockets offer duplex communication from a non-trusted source to a server that we own across a TCP socket connection. This means that, instead of continually polling the web …","keywords":["websockets"],"articleBody":"WebSockets offer duplex communication from a non-trusted source to a server that we own across a TCP socket connection. This means that, instead of continually polling the web server for updates and having to perform the whole TCP dance with each request, we can maintain a single TCP socket connection and then send and listen to messages on said connection.\nIn Go’s ecosystem there are few different implementations of the WebSocket protocol. Some libraries are pure implementation of the protocol. Others though, have chosen to build on top of the WebSocket protocol to create better abstractions for their particular use-case.\nHere’s a non-exhaustive list of Go WebSocket protocol implementations:\n x/net/websocket (from Go sub-repository packages) gorilla/websocket nhooyr/websocket gobwas/ws sacOO7/gowebsocket  In this article we will use the excellent gorilla/websocket implementation of the WebSocket protocol, from the Gorilla Web Toolkit project. You will notice that testing WebSocket is not much different from testing HTTP servers. Still, there are aspects of WebSockets that we have to take into account while testing.\nAuctions One of the businesses whose backbone is real-time communication are online auction houses. During an auction, seconds make the difference between winning or losing a collectible item that you have been wanting for so long.\nLet’s use a simple auction application powered by gorilla/websocket as an example for this article.\nFirst, we will define two very simple entities Bid and Auction that we will use in our WebSocket handlers. The Auction will receive a Bid method that we will use to place a new bid on the Auction.\nEntities Let’s look at the Auction and Bid types, in all of their glory:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type Bid struct { UserID int `json:\"user_id\"` Amount float64 `json:\"amount\"` } type Auction struct { ItemID int `json:\"item_id\"` EndTime int64 `json:\"end_time\"` Bids []*Bid } func NewAuction(d time.Duration, itemID int, b []*Bid) Auction { return Auction{ ItemID: itemID, EndTime: time.Now().Add(d).Unix(), Bids: b, } }    Both of the types are fairly simple, encapsulating very little data. The NewAuction constructor function builds an auction with a duration, itemID and a slice of *Bids.\nBidding We will place a bid on an auction through the Bid method:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func (a *Auction) Bid(amount float64, userID int) (*Bid, error) { if len(a.Bids)  0 { largestBid := a.Bids[len(a.Bids)-1] if largestBid.Amount = amount { return nil, fmt.Errorf(\"amount must be larger than %.2f\", largestBid.Amount) } } if a.EndTime Now().Unix() { return nil, fmt.Errorf(\"auction already closed\") } bid := Bid{ Amount: amount, UserID: userID, } // Mutex lock \ta.Bids = append(a.Bids, \u0026bid) // Mutex unlock  return \u0026bid, nil }    The Auction’s Bid method is where the bidding magic happens. It takes an amount and a userID as arguments and adds a Bid to the Auction. Also, it checks if the Auction has already closed and that the new bid amount is larger than the amount of the largest bid. If any of these conditions are not true, it will return an appropriate error to the caller.\nHaving the types and the Bid method out of the way, let’s dive into the WebSockets mechanics.\nHandling WebSockets Imagine a web frontend that can place bids on an auction in real time. With every JSON message it sends over WebSockets it will supply the identifier of the user placing the bid (UserID) and the amount (Amount) of the bid. Once the server accepts the message, it will place the bid and reply with a meaningful answer to the client.\nOn the server side, this communication will be done by a net/http Handler. It will handle all of the WebSocket intricacies, with a few notable steps:\n Upgrade the incoming HTTP connection to a WebSocket one Accept incoming messages from a client Decode bid from the inbound message Place the bid Send an outbound message with the reply to the client  Let’s write such a handler.\nFirst, let’s define the inbound and outbound message types:\n1 2 3 4 5 6 7 8  type inbound struct { UserID int `json:\"user_id\"` Amount float64 `json:\"amount\"` } type outbound struct { Body string `json:\"body\"` }    Both of them represent the in/outbound messages respectively, which will be the data flowing between the client and the server. The inbound message will represent a bid, while the outbound type represents a simple message with some text in its Body.\nNext, let’s define the bidsHandler, including its ServeHTTP method containing the HTTP connection upgrade:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var upgrader = websocket.Upgrader{} type bidsHandler struct { auction *Auction } func (bh bidsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { upgrader.CheckOrigin = func(r *http.Request) bool { return true } ws, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Println(\"upgrade:\", err) return } defer ws.Close() // More to come... }    First, we define a websocket.Upgrader, which takes the http.ResponseWriter and the *http.Request from the handler and upgrades the connection. Because this is just an example application, the upgrader.CheckOrigin method will only return a true bool, without checking the origin of the incoming request.\nOnce the upgrader finishes with the connection upgrade, it returns a *websocket.Conn object, stored in the ws variable. The *websocket.Conn will receive all of the incoming messages, where our handler will be reading from. Also, the handler will be writing messages to the *websocket.Conn, which will send an outbound message to the client.\nLet’s add the message loop next:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func (bh bidsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { // Code from above...  for { _, m, err := ws.ReadMessage() if err != nil { if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) { log.Printf(\"error: %v\", err) } return } var in inbound err = json.Unmarshal(m, \u0026in) if err != nil { handleError(ws, err) continue } bid, err := bh.auction.Bid(in.Amount, in.UserID) if err != nil { handleError(ws, err) continue } out, err := json.Marshal(outbound{Body: fmt.Sprintf(\"Bid placed: %.2f\", bid.Amount)}) if err != nil { handleError(ws, err) continue } err = ws.WriteMessage(websocket.BinaryMessage, out) if err != nil { handleError(ws, err) continue } } }    This for loop does a few things. First, it reads a new WebSocket message using ws.ReadMessage(), which returns the type of the message (binary or text), the message itself (m) and a potential error (err). Then, it checks the error if the client has closed the connection unexpectedly.\nOnce the error handling is completed and the message is retrieved, we decode it using json.Unmarshal into the in inbound message. Once in is available, we invoke bh.auction.Bid which places a bid on the auction, using the amount of the bid (in.Amount) and the ID of the bidder (in.UserID) as arguments. The Bid method returns a bid (bid) and an error (err).\nAfter the bid is placed, we use json.Marshal to convert an outbound message with the bid confirmation message encapsulated to slice of bytes ([]byte). Then we send the bytes to the client using the ws.WriteMessage method, which concludes the request-response server loop.\nWe can ignore the client side for now. Let’s now see how we can test this WebSockets handler code.\nTesting WebSockets handlers Although writing WebSocket handlers is more involved relative to ordinary HTTP handlers, testing them is simple. In fact, testing WebSockets handlers is as simple as testing HTTP handlers. This is because WebSockets are built on HTTP, so testing WebSockets is done using the same tools that testing HTTP servers is done with.\nWe will begin by adding the test setup:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  func TestBidsHandler(t *testing.T) { tcs := []struct { name string bids []*Bid duration time.Duration message inbound reply outbound }{ { name: \"with good bid\", bids: []*Bid{}, duration: time.Hour * 1, message: inbound{UserID: 1, Amount: 10}, reply: outbound{Body: \"Bid placed: 10.00\"}, }, { name: \"with bad bid\", bids: []*Bid{ \u0026Bid{ UserID: 1, Amount: 20, }, }, duration: time.Hour * 1, message: inbound{UserID: 1, Amount: 10}, reply: outbound{Body: \"amount must be larger than 20.00\"}, }, { name: \"good bid on expired auction\", bids: []*Bid{ \u0026Bid{ UserID: 1, Amount: 20, }, }, duration: time.Hour * -1, message: inbound{UserID: 1, Amount: 30}, reply: outbound{Body: \"auction already closed\"}, }, } for _, tt := range tcs { t.Run(tt.name, func(t *testing.T) { a := NewAuction(tt.duration, 1, tt.bids) h := bidsHandler{\u0026a} // To be added... \t}) } }    First, we begin by defining the testcase type. It has a name, which is the human-readable name of the test case. Also, each testcase has a bids slice and a duration which will be used to create a test Auction with. The testcase also has an inbound message and an outbound reply - which is what the test case will send to and expect in return from the handler.\nAfter, in the TestBidsHandler we add three different test cases – one where the client wants to place a bad bid, that is lower than the largest bid, another test case where the client adds a good bid and a third one where the client bids on an expired auction.\nIn the for loop, for each of the test cases, we create a subtest which uses the NewAuction constructor to create a new test auction. We also create a bidsHandler that takes the newly created Auction as an attribute.\nLet’s finish off the subtest function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func TestBidsHandler(t *testing.T) { // Test cases and other setup from above...  for _, tt := range tcs { t.Run(tt.name, func(t *testing.T) { a := NewAuction(tt.duration, 1, tt.bids) h := bidsHandler{\u0026a} s, ws := newWSServer(t, h) defer s.Close() defer ws.Close() sendMessage(t, ws, tt.message) reply := receiveWSMessage(t, ws) if reply != tt.reply { t.Fatalf(\"Expected '%+v', got '%+v'\", tt.reply, reply) } }) } }   \nWe added few new functions to the subtest function body. The newWSServer will create a test server and upgrade it to a WebSocket connection, returning both the server and the WebSocket connections. Then, the sendMessage function will send the message from the test case to the test server throught the WebSocket connection. After that, through the receiveWSMessage we will retrieve the reply from the server and assert for its correctness by comparing it to the reply of the test case.\nSo, what do each of these small functions do? Let’s break them down one by one.\n1 2 3 4 5 6 7 8 9 10 11 12 13  func newWSServer(t *testing.T, h http.Handler) (*httptest.Server, *websocket.Conn) { t.Helper() s := httptest.NewServer(h) wsURL := httpToWs(t, s.URL) ws, _, err := websocket.DefaultDialer.Dial(wsURL, nil) if err != nil { t.Fatal(err) } return s, ws }    The newWSServer function will use the httptest.NewServer function to mount the handler on a test HTTP server. Once that is done, it will convert the server’s URL to a WebSocket URL through the httpToWS function. (It simply replaces the http protocol to a ws, or https to wss, protocol in the URL.`)\nTo establish a WebSocket connection, we use the websocket.DefaultDialer which is a dialer with all fields set to the default values. We invoke the Dial method on the dialer, with the WebSocket server URL (wsURL) which returns the WebSocket connection.\n1 2 3 4 5 6 7 8 9 10 11 12  func sendMessage(t *testing.T, ws *websocket.Conn, msg inbound) { t.Helper() m, err := json.Marshal(msg) if err != nil { t.Fatal(err) } if err := ws.WriteMessage(websocket.BinaryMessage, m); err != nil { t.Fatalf(\"%v\", err) } }    The sendMessage function takes an inbound message as argument with the WebSocket connection (ws). It marshals the message into a JSON and it sends it over the WebSocket connection as a binary message.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func receiveWSMessage(t *testing.T, ws *websocket.Conn) outbound { t.Helper() _, m, err := ws.ReadMessage() if err != nil { t.Fatalf(\"%v\", err) } var reply outbound err = json.Unmarshal(m, \u0026reply) if err != nil { t.Fatal(err) } return reply }    receiveWSMessage takes the WebSocket connection (ws) as argument and it fetches a message using ws.ReadMessage(). Once the message is successfully retrieved, it unmarshals it into a outbound message using json.Unmarshal. As a last step, receiveWSMessage returns the outbound message to the test, so the test can continue with its assertions.\nIf we would run the tests, we will see them passing:\n1 2 3 4 5 6 7 8 9 10 11  $ go test ./... -v === RUN TestBidsHandler === RUN TestBidsHandler/with_good_bid === RUN TestBidsHandler/with_bad_bid === RUN TestBidsHandler/good_bid_on_expired_auction --- PASS: TestBidsHandler (0.00s) --- PASS: TestBidsHandler/with_good_bid (0.00s) --- PASS: TestBidsHandler/with_bad_bid (0.00s) --- PASS: TestBidsHandler/good_bid_on_expired_auction (0.00s) PASS ok github.com/fteem/go-playground/testing-in-go-web-sockets\t0.013s   You can see the example code on Github.\nAlso, to see another approach at testing WebSockets in Go, you can head over to the WebSockets chapter from the book “Learn Go with tests”.\nMore WebSockets reading If you would like to learn more about the details of the WebSocket protocol, I recommend reading RFC 6455 which defines the protocol itself. In addition, you can read more in follow-up RFCs regarding the WebSocket protocol:\n Clarifying Registry Procedures for the WebSocket Subprotocol Name Registry Well-Known URIs for the WebSocket Protocol Bootstrapping WebSockets with HTTP/2  Liked this article? Subscribe to my newsletter and get my fresh posts in your inbox. It's short and sweet, going out monthly to over 1,000 subscribers.  ","wordCount":"2325","inLanguage":"en","datePublished":"2020-02-22T12:32:51+01:00","dateModified":"2020-02-22T12:32:51+01:00","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/testing-in-go-websockets/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://ieftimov.com/posts title=Archive><span>Archive</span></a></li><li><a href=https://ieftimov.com/about title=About><span>About</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testing in Go: WebSockets</h1><div class=post-meta>March 13, 2020&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#auctions aria-label=Auctions>Auctions</a><ul><li><a href=#entities aria-label=Entities>Entities</a></li><li><a href=#bidding aria-label=Bidding>Bidding</a></li></ul></li><li><a href=#handling-websockets aria-label="Handling WebSockets">Handling WebSockets</a></li><li><a href=#testing-websockets-handlers aria-label="Testing WebSockets handlers">Testing WebSockets handlers</a></li><li><a href=#more-websockets-reading aria-label="More WebSockets reading">More WebSockets reading</a></li></ul></div></details></div><div class=post-content><p>WebSockets offer duplex communication from a non-trusted source to a server
that we own across a TCP socket connection. This means that, instead of
continually polling the web server for updates and having to perform the whole
TCP dance with each request, we can maintain a single TCP socket connection and
then send and listen to messages on said connection.</p><p>In Go&rsquo;s ecosystem there are few different implementations of <a href=https://tools.ietf.org/html/rfc6455>the WebSocket
protocol</a>. Some libraries are pure
implementation of the protocol. Others though, have chosen to build on top of
the WebSocket protocol to create better abstractions for their particular
use-case.</p><p>Here&rsquo;s a non-exhaustive list of Go WebSocket protocol implementations:</p><ul><li><a href=https://pkg.go.dev/golang.org/x/net/websocket><code>x/net/websocket</code></a> (from
<a href=https://godoc.org/-/subrepo>Go sub-repository packages</a>)</li><li><a href=https://github.com/gorilla/websocket><code>gorilla/websocket</code></a></li><li><a href=https://github.com/nhooyr/websocket><code>nhooyr/websocket</code></a></li><li><a href=https://github.com/gobwas/ws><code>gobwas/ws</code></a></li><li><a href=https://github.com/sacOO7/gowebsocket><code>sacOO7/gowebsocket</code></a></li></ul><p>In this article we will use the excellent <code>gorilla/websocket</code> implementation of
the WebSocket protocol, from the <a href=https://github.com/gorilla/websocket>Gorilla Web
Toolkit</a> project. You will notice that
testing WebSocket is not much different from <a href=/post/testing-in-go-testing-http-servers>testing HTTP
servers</a>. Still, there are aspects of
WebSockets that we have to take into account while testing.</p><h2 id=auctions>Auctions<a hidden class=anchor aria-hidden=true href=#auctions>#</a></h2><p>One of the businesses whose backbone is real-time communication are online
auction houses. During an auction, seconds make the difference between winning
or losing a collectible item that you have been wanting for so long.</p><p>Let&rsquo;s use a simple auction application powered by <code>gorilla/websocket</code> as an
example for this article.</p><p>First, we will define two very simple entities <code>Bid</code> and <code>Auction</code> that we will
use in our WebSocket handlers. The <code>Auction</code> will receive a <code>Bid</code> method that
we will use to place a new bid on the <code>Auction</code>.</p><h3 id=entities>Entities<a hidden class=anchor aria-hidden=true href=#entities>#</a></h3><p>Let&rsquo;s look at the <code>Auction</code> and <code>Bid</code> types, in all of their glory:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> Bid <span style=color:#0087ff>struct</span> {
	UserID <span style=color:#af0000>int</span>     <span style=color:#00afaf>`json:&#34;user_id&#34;`</span>
	Amount <span style=color:#af0000>float64</span> <span style=color:#00afaf>`json:&#34;amount&#34;`</span>
}

<span style=color:#0087ff>type</span> Auction <span style=color:#0087ff>struct</span> {
	ItemID  <span style=color:#af0000>int</span>   <span style=color:#00afaf>`json:&#34;item_id&#34;`</span>
	EndTime <span style=color:#af0000>int64</span> <span style=color:#00afaf>`json:&#34;end_time&#34;`</span>
	Bids    []*Bid
}

<span style=color:#0087ff>func</span> <span style=color:#0087ff>NewAuction</span>(d time.Duration, itemID <span style=color:#af0000>int</span>, b []*Bid) Auction {
	<span style=color:#5f8700>return</span> Auction{
		ItemID:  itemID,
		EndTime: time.<span style=color:#0087ff>Now</span>().<span style=color:#0087ff>Add</span>(d).<span style=color:#0087ff>Unix</span>(),
		Bids:    b,
	}
}
</code></pre></td></tr></table></div></div><p>Both of the types are fairly simple, encapsulating very little data. The
<code>NewAuction</code> constructor function builds an auction with a duration, <code>itemID</code>
and a slice of <code>*Bid</code>s.</p><h3 id=bidding>Bidding<a hidden class=anchor aria-hidden=true href=#bidding>#</a></h3><p>We will place a bid on an auction through the <code>Bid</code> method:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (a *Auction) <span style=color:#0087ff>Bid</span>(amount <span style=color:#af0000>float64</span>, userID <span style=color:#af0000>int</span>) (*Bid, <span style=color:#af0000>error</span>) {
	<span style=color:#5f8700>if</span> <span style=color:#0087ff>len</span>(a.Bids) &gt; <span style=color:#00afaf>0</span> {
		largestBid := a.Bids[<span style=color:#0087ff>len</span>(a.Bids)-<span style=color:#00afaf>1</span>]
		<span style=color:#5f8700>if</span> largestBid.Amount &gt;= amount {
			<span style=color:#5f8700>return</span> <span style=color:#d75f00>nil</span>, fmt.<span style=color:#0087ff>Errorf</span>(<span style=color:#00afaf>&#34;amount must be larger than %.2f&#34;</span>, largestBid.Amount)
		}
	}

	<span style=color:#5f8700>if</span> a.EndTime &lt; time.<span style=color:#0087ff>Now</span>().<span style=color:#0087ff>Unix</span>() {
		<span style=color:#5f8700>return</span> <span style=color:#d75f00>nil</span>, fmt.<span style=color:#0087ff>Errorf</span>(<span style=color:#00afaf>&#34;auction already closed&#34;</span>)
	}

	bid := Bid{
		Amount: amount,
		UserID: userID,
	}

	<span style=color:#4e4e4e>// Mutex lock
</span><span style=color:#4e4e4e></span>	a.Bids = <span style=color:#0087ff>append</span>(a.Bids, &amp;bid)
	<span style=color:#4e4e4e>// Mutex unlock
</span><span style=color:#4e4e4e></span>
	<span style=color:#5f8700>return</span> &amp;bid, <span style=color:#d75f00>nil</span>
}
</code></pre></td></tr></table></div></div><p>The <code>Auction</code>&rsquo;s <code>Bid</code> method is where the bidding magic happens. It takes an
<code>amount</code> and a <code>userID</code> as arguments and adds a <code>Bid</code> to the <code>Auction</code>. Also,
it checks if the <code>Auction</code> has already closed and that the new bid <code>amount</code> is
larger than the <code>amount</code> of the largest bid. If any of these conditions are not
true, it will return an appropriate error to the caller.</p><p>Having the types and the <code>Bid</code> method out of the way, let&rsquo;s dive into the
WebSockets mechanics.</p><h2 id=handling-websockets>Handling WebSockets<a hidden class=anchor aria-hidden=true href=#handling-websockets>#</a></h2><p>Imagine a web frontend that can place bids on an auction in real time. With
every JSON message it sends over WebSockets it will supply the identifier of
the user placing the bid (<code>UserID</code>) and the amount (<code>Amount</code>) of the bid. Once
the server accepts the message, it will place the bid and reply with a
meaningful answer to the client.</p><p>On the server side, this communication will be done by a <code>net/http</code> <code>Handler</code>.
It will handle all of the WebSocket intricacies, with a few notable steps:</p><ol><li>Upgrade the incoming HTTP connection to a WebSocket one</li><li>Accept incoming messages from a client</li><li>Decode bid from the inbound message</li><li>Place the bid</li><li>Send an outbound message with the reply to the client</li></ol><p>Let&rsquo;s write such a handler.</p><p>First, let&rsquo;s define the <code>inbound</code> and <code>outbound</code> message types:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> inbound <span style=color:#0087ff>struct</span> {
	UserID <span style=color:#af0000>int</span>     <span style=color:#00afaf>`json:&#34;user_id&#34;`</span>
	Amount <span style=color:#af0000>float64</span> <span style=color:#00afaf>`json:&#34;amount&#34;`</span>
}

<span style=color:#0087ff>type</span> outbound <span style=color:#0087ff>struct</span> {
	Body <span style=color:#af0000>string</span> <span style=color:#00afaf>`json:&#34;body&#34;`</span>
}
</code></pre></td></tr></table></div></div><p>Both of them represent the in/outbound messages respectively, which will be the
data flowing between the client and the server. The <code>inbound</code> message will
represent a bid, while the <code>outbound</code> type represents a simple message with
some text in its <code>Body</code>.</p><p>Next, let&rsquo;s define the <code>bidsHandler</code>, including its <code>ServeHTTP</code> method
containing the HTTP connection upgrade:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>var</span> upgrader = websocket.Upgrader{}

<span style=color:#0087ff>type</span> bidsHandler <span style=color:#0087ff>struct</span> {
	auction *Auction
}

<span style=color:#0087ff>func</span> (bh bidsHandler) <span style=color:#0087ff>ServeHTTP</span>(w http.ResponseWriter, r *http.Request) {
	upgrader.CheckOrigin = <span style=color:#0087ff>func</span>(r *http.Request) <span style=color:#af0000>bool</span> { <span style=color:#5f8700>return</span> <span style=color:#d75f00>true</span> }
	ws, err := upgrader.<span style=color:#0087ff>Upgrade</span>(w, r, <span style=color:#d75f00>nil</span>)
	<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
		log.<span style=color:#0087ff>Println</span>(<span style=color:#00afaf>&#34;upgrade:&#34;</span>, err)
		<span style=color:#5f8700>return</span>
	}
	<span style=color:#5f8700>defer</span> ws.<span style=color:#0087ff>Close</span>()

	<span style=color:#4e4e4e>// More to come...
</span><span style=color:#4e4e4e></span>}
</code></pre></td></tr></table></div></div><p>First, we define a <code>websocket.Upgrader</code>, which takes the <code>http.ResponseWriter</code>
and the <code>*http.Request</code> from the handler and upgrades the connection. Because
this is just an example application, the <code>upgrader.CheckOrigin</code> method will
only return a <code>true</code> bool, without checking the origin of the incoming request.</p><p>Once the <code>upgrader</code> finishes with the connection upgrade, it returns a
<code>*websocket.Conn</code> object, stored in the <code>ws</code> variable. The <code>*websocket.Conn</code>
will receive all of the incoming messages, where our handler will be reading
from. Also, the handler will be writing messages to the <code>*websocket.Conn</code>,
which will send an outbound message to the client.</p><p>Let&rsquo;s add the message loop next:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">38
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (bh bidsHandler) <span style=color:#0087ff>ServeHTTP</span>(w http.ResponseWriter, r *http.Request) {
	<span style=color:#4e4e4e>// Code from above...
</span><span style=color:#4e4e4e></span>
	<span style=color:#5f8700>for</span> {
		_, m, err := ws.<span style=color:#0087ff>ReadMessage</span>()
		<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
			<span style=color:#5f8700>if</span> websocket.<span style=color:#0087ff>IsUnexpectedCloseError</span>(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.<span style=color:#0087ff>Printf</span>(<span style=color:#00afaf>&#34;error: %v&#34;</span>, err)
			}
			<span style=color:#5f8700>return</span>
		}

		<span style=color:#0087ff>var</span> in inbound
		err = json.<span style=color:#0087ff>Unmarshal</span>(m, &amp;in)
		<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
			<span style=color:#0087ff>handleError</span>(ws, err)
			<span style=color:#5f8700>continue</span>
		}

		bid, err := bh.auction.<span style=color:#0087ff>Bid</span>(in.Amount, in.UserID)
		<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
			<span style=color:#0087ff>handleError</span>(ws, err)
			<span style=color:#5f8700>continue</span>
		}

		out, err := json.<span style=color:#0087ff>Marshal</span>(outbound{Body: fmt.<span style=color:#0087ff>Sprintf</span>(<span style=color:#00afaf>&#34;Bid placed: %.2f&#34;</span>, bid.Amount)})
		<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
			<span style=color:#0087ff>handleError</span>(ws, err)
			<span style=color:#5f8700>continue</span>
		}

		err = ws.<span style=color:#0087ff>WriteMessage</span>(websocket.BinaryMessage, out)
		<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
			<span style=color:#0087ff>handleError</span>(ws, err)
			<span style=color:#5f8700>continue</span>
		}
	}
}
</code></pre></td></tr></table></div></div><p>This <code>for</code> loop does a few things. First, it reads a new WebSocket message
using <code>ws.ReadMessage()</code>, which returns the type of the message (binary or
text), the message itself (<code>m</code>) and a potential error (<code>err</code>). Then, it checks
the error if the client has closed the connection unexpectedly.</p><p>Once the error handling is completed and the message is retrieved, we decode it
using <code>json.Unmarshal</code> into the <code>in</code> inbound message. Once <code>in</code> is available,
we invoke <code>bh.auction.Bid</code> which places a bid on the auction, using the amount
of the bid (<code>in.Amount</code>) and the ID of the bidder (<code>in.UserID</code>) as arguments.
The <code>Bid</code> method returns a bid (<code>bid</code>) and an error (<code>err</code>).</p><p>After the bid is placed, we use <code>json.Marshal</code> to convert an <code>outbound</code> message
with the bid confirmation message encapsulated to slice of bytes (<code>[]byte</code>).
Then we send the bytes to the client using the <code>ws.WriteMessage</code> method, which
concludes the request-response server loop.</p><p>We can ignore the client side for now. Let&rsquo;s now see how we can test this
WebSockets handler code.</p><h2 id=testing-websockets-handlers>Testing WebSockets handlers<a hidden class=anchor aria-hidden=true href=#testing-websockets-handlers>#</a></h2><p>Although writing WebSocket handlers is more involved relative to ordinary HTTP
handlers, testing them is simple. In fact, testing WebSockets handlers is as
simple as testing HTTP handlers. This is because WebSockets are built on HTTP,
so testing WebSockets is done using the same tools that <a href=/post/testing-in-go-testing-http-servers>testing HTTP
servers</a> is done with.</p><p>We will begin by adding the test setup:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">51
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>TestBidsHandler</span>(t *testing.T) {
	tcs := []<span style=color:#0087ff>struct</span> {
		name     <span style=color:#af0000>string</span>
		bids     []*Bid
		duration time.Duration
		message  inbound
		reply    outbound
	}{
		{
			name:     <span style=color:#00afaf>&#34;with good bid&#34;</span>,
			bids:     []*Bid{},
			duration: time.Hour * <span style=color:#00afaf>1</span>,
			message:  inbound{UserID: <span style=color:#00afaf>1</span>, Amount: <span style=color:#00afaf>10</span>},
			reply:    outbound{Body: <span style=color:#00afaf>&#34;Bid placed: 10.00&#34;</span>},
		},
		{
			name: <span style=color:#00afaf>&#34;with bad bid&#34;</span>,
			bids: []*Bid{
				&amp;Bid{
					UserID: <span style=color:#00afaf>1</span>,
					Amount: <span style=color:#00afaf>20</span>,
				},
			},
			duration: time.Hour * <span style=color:#00afaf>1</span>,
			message:  inbound{UserID: <span style=color:#00afaf>1</span>, Amount: <span style=color:#00afaf>10</span>},
			reply:    outbound{Body: <span style=color:#00afaf>&#34;amount must be larger than 20.00&#34;</span>},
		},
		{

			name: <span style=color:#00afaf>&#34;good bid on expired auction&#34;</span>,
			bids: []*Bid{
				&amp;Bid{
					UserID: <span style=color:#00afaf>1</span>,
					Amount: <span style=color:#00afaf>20</span>,
				},
			},
			duration: time.Hour * -<span style=color:#00afaf>1</span>,
			message:  inbound{UserID: <span style=color:#00afaf>1</span>, Amount: <span style=color:#00afaf>30</span>},
			reply:    outbound{Body: <span style=color:#00afaf>&#34;auction already closed&#34;</span>},
		},
	}

	<span style=color:#5f8700>for</span> _, tt := <span style=color:#5f8700>range</span> tcs {
		t.<span style=color:#0087ff>Run</span>(tt.name, <span style=color:#0087ff>func</span>(t *testing.T) {
			a := <span style=color:#0087ff>NewAuction</span>(tt.duration, <span style=color:#00afaf>1</span>, tt.bids)
			h := bidsHandler{&amp;a}

			<span style=color:#4e4e4e>// To be added...
</span><span style=color:#4e4e4e></span>		})
	}
}
</code></pre></td></tr></table></div></div><p>First, we begin by defining the testcase type. It has a <code>name</code>, which is the
human-readable name of the test case. Also, each testcase has a <code>bids</code> slice
and a <code>duration</code> which will be used to create a test <code>Auction</code> with. The
testcase also has an <code>inbound</code> <code>message</code> and an <code>outbound</code> <code>reply</code> - which is
what the test case will send to and expect in return from the handler.</p><p>After, in the <code>TestBidsHandler</code> we add three different test cases – one where
the client wants to place a bad bid, that is lower than the largest bid,
another test case where the client adds a good bid and a third one where the
client bids on an expired auction.</p><p>In the <code>for</code> loop, for each of the test cases, we create a subtest which uses
the <code>NewAuction</code> constructor to create a new test auction. We also create a
<code>bidsHandler</code> that takes the newly created <code>Auction</code> as an attribute.</p><p>Let&rsquo;s finish off the subtest function:<div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>TestBidsHandler</span>(t *testing.T) {
	<span style=color:#4e4e4e>// Test cases and other setup from above...
</span><span style=color:#4e4e4e></span>
	<span style=color:#5f8700>for</span> _, tt := <span style=color:#5f8700>range</span> tcs {
		t.<span style=color:#0087ff>Run</span>(tt.name, <span style=color:#0087ff>func</span>(t *testing.T) {
			a := <span style=color:#0087ff>NewAuction</span>(tt.duration, <span style=color:#00afaf>1</span>, tt.bids)
			h := bidsHandler{&amp;a}

			s, ws := <span style=color:#0087ff>newWSServer</span>(t, h)
			<span style=color:#5f8700>defer</span> s.<span style=color:#0087ff>Close</span>()
			<span style=color:#5f8700>defer</span> ws.<span style=color:#0087ff>Close</span>()

			<span style=color:#0087ff>sendMessage</span>(t, ws, tt.message)

			reply := <span style=color:#0087ff>receiveWSMessage</span>(t, ws)

			<span style=color:#5f8700>if</span> reply != tt.reply {
				t.<span style=color:#0087ff>Fatalf</span>(<span style=color:#00afaf>&#34;Expected &#39;%+v&#39;, got &#39;%+v&#39;&#34;</span>, tt.reply, reply)
			}
		})
	}
}
</code></pre></td></tr></table></div></div></p><p>We added few new functions to the subtest function body. The <code>newWSServer</code> will
create a test server and upgrade it to a WebSocket connection, returning both
the server and the WebSocket connections. Then, the <code>sendMessage</code> function will
send the message from the test case to the test server throught the WebSocket
connection. After that, through the <code>receiveWSMessage</code> we will retrieve the
reply from the server and assert for its correctness by comparing it to the
<code>reply</code> of the test case.</p><p>So, what do each of these small functions do? Let&rsquo;s break them down one by one.</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>newWSServer</span>(t *testing.T, h http.Handler) (*httptest.Server, *websocket.Conn) {
	t.<span style=color:#0087ff>Helper</span>()

	s := httptest.<span style=color:#0087ff>NewServer</span>(h)
	wsURL := <span style=color:#0087ff>httpToWs</span>(t, s.URL)

	ws, _, err := websocket.DefaultDialer.<span style=color:#0087ff>Dial</span>(wsURL, <span style=color:#d75f00>nil</span>)
	<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
		t.<span style=color:#0087ff>Fatal</span>(err)
	}

	<span style=color:#5f8700>return</span> s, ws
}
</code></pre></td></tr></table></div></div><p>The <code>newWSServer</code> function will use the
<a href=https://golang.org/pkg/net/http/httptest/#NewServer><code>httptest.NewServer</code></a>
function to mount the handler on a test HTTP server. Once that is done, it will
convert the server&rsquo;s <code>URL</code> to a WebSocket URL through the <code>httpToWS</code> function.
(It simply replaces the <code>http</code> protocol to a <code>ws</code>, or <code>https</code> to <code>wss</code>, protocol
in the URL.`)</p><p>To establish a WebSocket connection, we use the
<a href=https://godoc.org/github.com/gorilla/websocket#pkg-variables><code>websocket.DefaultDialer</code></a>
which is a dialer with all fields set to the default values. We invoke the
<code>Dial</code> method on the dialer, with the WebSocket server URL (<code>wsURL</code>) which
returns the WebSocket connection.</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>sendMessage</span>(t *testing.T, ws *websocket.Conn, msg inbound) {
	t.<span style=color:#0087ff>Helper</span>()

	m, err := json.<span style=color:#0087ff>Marshal</span>(msg)
	<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
		t.<span style=color:#0087ff>Fatal</span>(err)
	}

	<span style=color:#5f8700>if</span> err := ws.<span style=color:#0087ff>WriteMessage</span>(websocket.BinaryMessage, m); err != <span style=color:#d75f00>nil</span> {
		t.<span style=color:#0087ff>Fatalf</span>(<span style=color:#00afaf>&#34;%v&#34;</span>, err)
	}
}
</code></pre></td></tr></table></div></div><p>The <code>sendMessage</code> function takes an <code>inbound</code> message as argument with the WebSocket
connection (<code>ws</code>). It marshals the message into a JSON and it sends it over the
WebSocket connection as a binary message.</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>receiveWSMessage</span>(t *testing.T, ws *websocket.Conn) outbound {
	t.<span style=color:#0087ff>Helper</span>()

	_, m, err := ws.<span style=color:#0087ff>ReadMessage</span>()
	<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
		t.<span style=color:#0087ff>Fatalf</span>(<span style=color:#00afaf>&#34;%v&#34;</span>, err)
	}

	<span style=color:#0087ff>var</span> reply outbound
	err = json.<span style=color:#0087ff>Unmarshal</span>(m, &amp;reply)
	<span style=color:#5f8700>if</span> err != <span style=color:#d75f00>nil</span> {
		t.<span style=color:#0087ff>Fatal</span>(err)
	}

	<span style=color:#5f8700>return</span> reply
}
</code></pre></td></tr></table></div></div><p><code>receiveWSMessage</code> takes the WebSocket connection (<code>ws</code>) as argument and it
fetches a message using <code>ws.ReadMessage()</code>. Once the message is successfully
retrieved, it unmarshals it into a <code>outbound</code> message using <code>json.Unmarshal</code>.
As a last step, <code>receiveWSMessage</code> returns the <code>outbound</code> message to the test,
so the test can continue with its assertions.</p><p>If we would run the tests, we will see them passing:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go <span style=color:#0087ff>test</span> ./... -v
=== RUN   <span style=color:#0087ff>TestBidsHandler</span>
=== RUN   TestBidsHandler/with_good_bid
=== RUN   TestBidsHandler/with_bad_bid
=== RUN   TestBidsHandler/good_bid_on_expired_auction
--- PASS: TestBidsHandler (0.00s)
    --- PASS: TestBidsHandler/with_good_bid (0.00s)
    --- PASS: TestBidsHandler/with_bad_bid (0.00s)
    --- PASS: TestBidsHandler/good_bid_on_expired_auction (0.00s)
PASS
ok  	github.com/fteem/go-playground/testing-in-go-web-sockets	0.013s</code></pre></td></tr></table></div></div><p>You can see the example code <a href=https://github.com/fteem/go-playground/tree/master/testing-in-go-web-sockets>on
Github</a>.</p><p>Also, to see another approach at testing WebSockets in Go, you can head over to
<a href=https://quii.gitbook.io/learn-go-with-tests/build-an-application/websockets>the WebSockets
chapter</a>
from the book <a href=https://quii.gitbook.io/learn-go-with-tests/>&ldquo;Learn Go with
tests&rdquo;</a>.</p><h2 id=more-websockets-reading>More WebSockets reading<a hidden class=anchor aria-hidden=true href=#more-websockets-reading>#</a></h2><p>If you would like to learn more about the details of the WebSocket protocol,
I recommend reading <a href=https://tools.ietf.org/html/rfc6455><code>RFC 6455</code></a> which defines
the protocol itself. In addition, you can read more in follow-up RFCs regarding
the WebSocket protocol:</p><ul><li><a href=https://tools.ietf.org/html/rfc7936>Clarifying Registry Procedures for the WebSocket Subprotocol Name Registry</a></li><li><a href=https://tools.ietf.org/html/rfc8307>Well-Known URIs for the WebSocket Protocol</a></li><li><a href=https://tools.ietf.org/html/rfc8441>Bootstrapping WebSockets with HTTP/2</a></li></ul><section class=subscribe><b>Liked this article?</b> <a href=/newsletter>Subscribe to my
newsletter</a> and get my fresh posts in your inbox. It's short and sweet,
going out monthly to over 1,000 subscribers.</section></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/websockets/>websockets</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/understanding-bytes-golang-build-tcp-protocol/><span class=title>« Prev Page</span><br><span>Understanding bytes in Go by building a TCP protocol</span></a>
<a class=next href=https://ieftimov.com/post/testing-in-go-testing-http-servers/><span class=title>Next Page »</span><br><span>Testing in Go: HTTP Servers</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: WebSockets on twitter" href="https://twitter.com/intent/tweet/?text=Testing%20in%20Go%3a%20WebSockets&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-websockets%2f&hashtags=websockets"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: WebSockets on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-websockets%2f&title=Testing%20in%20Go%3a%20WebSockets&summary=Testing%20in%20Go%3a%20WebSockets&source=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-websockets%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: WebSockets on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-websockets%2f&title=Testing%20in%20Go%3a%20WebSockets"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: WebSockets on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-websockets%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: WebSockets on whatsapp" href="https://api.whatsapp.com/send?text=Testing%20in%20Go%3a%20WebSockets%20-%20https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-websockets%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: WebSockets on telegram" href="https://telegram.me/share/url?text=Testing%20in%20Go%3a%20WebSockets&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-websockets%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>