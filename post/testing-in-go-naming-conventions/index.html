<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing in Go: Naming Conventions | Ilija Eftimov ⚡️</title><meta name=keywords content><meta name=description content="Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when it comes to testing. Some are defined in the language itself (official), while others are coined by community members (unofficial).
In this article we will look at the naming conventions for files, functions and variables separately.
  File and package naming conventions Go&rsquo;s testing package comes with an expectation that any test file must have a _test."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/testing-in-go-naming-conventions/><link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="Testing in Go: Naming Conventions"><meta property="og:description" content="Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when it comes to testing. Some are defined in the language itself (official), while others are coined by community members (unofficial).
In this article we will look at the naming conventions for files, functions and variables separately.
  File and package naming conventions Go&rsquo;s testing package comes with an expectation that any test file must have a _test."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/testing-in-go-naming-conventions/"><meta property="og:image" content="https://ieftimov.com/cards/testing-in-go-naming-conventions.png"><meta property="article:published_time" content="2019-06-24T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-24T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/testing-in-go-naming-conventions.png"><meta name=twitter:title content="Testing in Go: Naming Conventions"><meta name=twitter:description content="Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when it comes to testing. Some are defined in the language itself (official), while others are coined by community members (unofficial).
In this article we will look at the naming conventions for files, functions and variables separately.
  File and package naming conventions Go&rsquo;s testing package comes with an expectation that any test file must have a _test."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Testing in Go: Naming Conventions","item":"https://ieftimov.com/post/testing-in-go-naming-conventions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing in Go: Naming Conventions","name":"Testing in Go: Naming Conventions","description":"Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when …","keywords":[],"articleBody":"Programming languages and tools often have conventions. These conventions help make our work more straightforward. Just like all tools out there, Go also has some conventions when it comes to testing. Some are defined in the language itself (official), while others are coined by community members (unofficial).\nIn this article we will look at the naming conventions for files, functions and variables separately.\n  File and package naming conventions Go’s testing package comes with an expectation that any test file must have a _test.go suffix. For example, if we would have a file called person.go its test file must be named person_test.go. This is due to the package building process, where Go knows to ignore these files when building the package due to their naming. Simply, it ignores test files as they are not needed for the program to run.\nAdditionally, Go ships with a command line tool called go test. This tool automates testing the packages named by the import paths. It recompiles each package along with any files with names that match the file pattern *_test.go. This means that go test recognizes these files as special and compiles them as a separate package, and then links and runs them with the main test binary.\nWhen it comes to packages, Go by default expects that all test files are part of the same package that they test. For example, if person.go defines a person package, the respective person_test.go should also be part of the person package. This also means that both, the person.go and person_test.go files should be placed in the same directory - we let Go worry what files should be loaded depending on what go command we run.\nLooking at Golang’s source code oddly I found some disregard for these rules. For example, the tests for the fmt package in the standard library, belong to a fmt_test package, instead of the fmt package.\nAt first, my observation was that this is wrong and for some reason it is not fixed yet. After a more thorough research it was obvious that this is an intentional approach and not a mistake. As explained in this Stack Overflow answer, the best way to look at this is to differentiate the two approaches as “black box” and “white box” testing.\nThe black box approach, where the test and the production code are in separate packages, allows us to test only the exported identifiers of a package. This means that our test package will not have access to any of the internal functions, variables or constants that are in the production code.\nThe white box approach, where the test and the production code are in the same package, allows us to test both the non-exported and expored identifiers of the package. This is the preferrable approach when writing unit tests that require access to non-exported variables, functions, and methods.\nI personally find the white box approach preferrable, because this is the default behaviour of the tooling that ships with the language. We as users of said tooling should employ good judgement and conventions to write code that is testable and avoid touching non-exported identifiers in the tests. In other words, we should adhere to the defaults, unless we have a really good reason not to.\nIn any case, if you would like to learn how to idiomatic Go and how to organise your packages properly, the source code of the language is the best place to learn from.\n  Function naming conventions While the file naming convention is enforced by the language and its toolkit, test function naming conventions are loosely enforced by Go, but are community driven.\nIn Go, each test file is composed of one or many test functions. Each test function has the following signature structure:\n1  func TestXxx(*testing.T)    What’s important to notice is that Xxx does not start with a lowercase letter. The function name serves to identify the test routine. A simple test function looks like this (stolen from here):\n1 2 3 4 5 6  func TestAbs(t *testing.T) { got := Abs(-1) if got != 1 { t.Errorf(\"Abs(-1) = %d; want 1\", got) } }    And that’s all that’s enforced by Go and it’s toolkit. Still, there are a few common ways to name your test functions. For example, we have a simple type Person with age attribute. It receives a function older which checks what if one Person is older than another Person, by comparing their age attributes.\n1 2 3 4 5 6 7 8 9  package main type Person struct { age int64 } func (p *Person) older(other *Person) bool { return p.age  other.age }    We would write a test function for older, looking like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import ( \"fmt\" \"testing\" ) func TestOlder(t *testing.T) { p1 := \u0026Person{21} p2 := \u0026Person{22} if !p1.older(p2) { t.Fatalf(fmt.Sprintf(\"Expected %d  %d\", p1.age, p2.age)) } }    Here we name our test function TestOlder, which clearly states the function under test - older. This is in line with what the testing package expects - a PascalCased function name, starting with Test. What comes after is up to us.\nIn our small example, calling the test function TestOlder is the most common approach that you will see in the wild. But, what if we want to test the same function (older) in more test functions? Do we use TestOlder1, TestOlder2, etc. as test function names? Or is there a better way?\nFor such scenarios, I have found a few approaches in the wild:\nThe Golang source code itself has a naming convention. If we zero in on an example, like the test where the strings.Compare function is tested, we can see the convention in action:\n The base test function follows the format of Test + the name of the function under test. For example TestCompare, which tests the Compare function. More specific tests, for example a test that compares two idential strings, is called TestCompareIndentialStrings. Tests that are more specific express that in the name, using the PascalCase naming scheme.  We can see the same pattern in other files, for example in flag_test.go, where the functionality of the flags package is tested. Notable examples there are the TestUserDefined and TestUserDefinedForCommandLine test functions:\n1 2 3 4 5 6 7  func TestUserDefined(t *testing.T) { // Snipped... } func TestUserDefinedForCommandLine(t *testing.T) { // Snipped... }    Moving on to another popular Golang project, consul by HashiCorp, we can see a different test functions naming convention. If we look at the api_test.go file, where the API client is tested, we can see that the project uses a naming convention where:\n The base test function follows the format of Test + the name of the package where the function is placed, with the function name appended after an underscore (_). For example, the API.Debug.Heap() function is tested in the TestAPI_DebugHeap test function. Similarly, the API.SetupTLSConfig is tested in TestAPI_SetupTLSConfig test function. There are functions like API.Agent.Services() that require more specific tests. That’s why, for example there are TestAPI_AgentServices and TestAPI_AgentServicesWithFilter, where in the latter there is more specific functionality being tested.  1 2 3 4 5 6 7  func TestAPI_AgentServices(t *testing.T) { // Snipped... } func TestAPI_AgentServicesWithFilter(t *testing.T) { // Snipped... }    These are just a few examples of test function naming conventions, so expect to find some others in the ecosystem. There are various conventions when it comes to naming testing functions, but all of them have to follow the basic format of TestXxx that the testing package enforces.\nVariable naming conventions While there is strict enforcement of the file name convention, and a loose enforcement of test function naming, things are very relaxed when it comes to variables naming. Basically, Golang does not enforce any conventions on the naming of the variables that we can use in our tests via the tooling.\nThis in theory means that everyone can come up with their own variable names. But, what does that mean in practice? What do popular open source projects do when it comes to naming variables?\nBefore we dive in any open source projects, we have to go back to the basics. I am not sure if this is well known (enough), as I have found it a bit too burried in the Github wiki, but Go has a nice “Go Code Review Comments” page where variable names are discussed.\nWhile the section is short, it says a lot about how we should be naming our variables:\n Variable names in Go should be short rather than long. This is especially true for local variables with limited scope. Prefer c to lineCount. Prefer i to sliceIndex.\n This part is self-explanatory. Go errs on the side of short variable names. In my personal opinion this does not make sense in a time of very powerful text editors that autocomplete our code. I prefer to be lazy and read what each variable means than figuring out what c, t or p mean. Still, if you believe in consistency, we should all follow the same guidelines when writing Go.\nFuther, it says:\n The basic rule: the further from its declaration that a name is used, the more descriptive the name must be.\n This is something I personally like as a rule – the cognitive weight should be small when regaining context of what a variable or concept means. In such cases, configuration (or conf) can do wonders compared to c.\nLastly, it states:\n Common variables such as loop indices and readers can be a single letter (i, r). More unusual things and global variables need more descriptive names.\n The i, j \u0026 k variable names for indices are very commonly used, especially in C-inspired languages, so if you are a little bit experienced (or been exposed) to them this will be expected.\nBut, are we bikeshedding here? Why are we discussing variable names, does it matter that much?\nWell, Go tests are just code. Being code, we should expect that all tests follow these guidelines just like all other code does. Also, we should write our tests using these guidelines so our tests feel familiar to others that will work with them. There shouldn’t be a major change of code style when switching between business logic and tests.\nNow, let’s go back to popular open source projects writen in Go:\nLooking at Terraform, another popular HashiCorp project, one thing that is ubiquitous about its test suite is that the project has both, the actual/expected and the got/want naming convention when it comes to test failures.\nBasically, the test case has an expected value, which is what we expect the function under test to return. The actual value is what the function under test returned. What is convenient about following that naming convention is that expected and actual clearly state that those are the values that will have to be compared with each other, which will drive the decision if the test will pass or not:\n1 2 3 4  // From: https://github.com/hashicorp/terraform/blob/250527d923f07130c36e65f9bb43b58fcbfe66cf/httpclient/useragent_test.go#L41-L43 if c.expected != actual { t.Fatalf(\"Expected User-Agent '%s' does not match '%s'\", c.expected, actual) }    Another way to achieve the same is the got/want naming, where the comparison looks like:\n1 2 3 4  // From: https://github.com/hashicorp/terraform/blob/250527d923f07130c36e65f9bb43b58fcbfe66cf/backend/unparsed_value_test.go#L34-L45 if got, want := diags[3].Description().Summary, undeclPlural; got != want { t.Errorf(\"wrong summary for diagnostic 3\\ngot: %s\\nwant: %s\", got, want) }    The idea behind the naming is the same, but the goal is to fail with a practical message to whoever’s debugging your code in the future.\nFrom here on, delving in the variables conventions further would not prove to be productive, yet following the naming conventions that we discussed above is good enough for your tests. If you would like to read more on the topic, I suggest reading the “Names” section of Effective Go and “Variable Names” section of the Go Code Review Comments wiki page.\n  Making things boring Probably you now:\n Why do you bother me with these rules and conventions? go fmt takes care of my code, isn’t that enough?\n I hear you and I get your point.\nHere’s how I look at it: easy conventions to follow diminish entropy, which makes for simpler and predictable code. The less cognitive load we have to absorb when working with a piece of code – the better.\nIn other words: I like boring code. Boring code is good. I like code that will dully adhere to Go’s naming conventions, regardless if I find them appealing or not. Conventions are put in place to make our lives easier, by not having to think if it should be i or index, and knowing that conf will always mean configuration.\nAnd I hope that you will find the boringness of such conventions liberating and empowering over time.\nLiked this article? Subscribe to my newsletter and get my fresh posts in your inbox. It's short and sweet, going out monthly to over 1,000 subscribers.  ","wordCount":"2160","inLanguage":"en","datePublished":"2019-06-24T00:00:00Z","dateModified":"2019-06-24T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/testing-in-go-naming-conventions/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://ieftimov.com/posts title=Archive><span>Archive</span></a></li><li><a href=https://ieftimov.com/about title=About><span>About</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testing in Go: Naming Conventions</h1><div class=post-meta>June 24, 2019&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#file-and-package-naming-conventions aria-label="File and package naming conventions">File and package naming conventions</a></li><li><a href=#function-naming-conventions aria-label="Function naming conventions">Function naming conventions</a></li><li><a href=#variable-naming-conventions aria-label="Variable naming conventions">Variable naming conventions</a></li><li><a href=#making-things-boring aria-label="Making things boring">Making things boring</a></li></ul></div></details></div><div class=post-content><p>Programming languages and tools often have conventions. These conventions help
make our work more straightforward. Just like all tools out there, Go also has
some conventions when it comes to testing. Some are defined in the language
itself (official), while others are coined by community members (unofficial).</p><p>In this article we will look at the naming conventions for files, functions and
variables separately.</p><figure class=imagecaption><img class=caption src=/testing-in-go-naming-conventions/unboxing.png caption alt="Two people opening a disproportionately big box">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=file-and-package-naming-conventions>File and package naming conventions<a hidden class=anchor aria-hidden=true href=#file-and-package-naming-conventions>#</a></h2><p>Go&rsquo;s <a href=https://golang.org/pkg/testing/><code>testing</code> package</a> comes with an
expectation that any test file must have a <code>_test.go</code> suffix. For example, if
we would have a file called <code>person.go</code> its test file must be named
<code>person_test.go</code>. This is due to the package building process, where Go knows
to ignore these files when building the package due to their naming. Simply,
it ignores test files as they are not needed for the program to run.</p><p>Additionally, Go ships with a command line tool called <code>go test</code>. This tool
automates testing the packages named by the import paths. It recompiles each
package along with any files with names that match the file pattern
<code>*_test.go</code>. This means that <code>go test</code> recognizes these files as special and
compiles them as a separate package, and then links and runs them with the main
test binary.</p><p>When it comes to packages, Go by default expects that all test files are part
of the same package that they test. For example, if <code>person.go</code> defines a
<code>person</code> package, the respective <code>person_test.go</code> should also be part of the
<code>person</code> package. This also means that both, the <code>person.go</code> and
<code>person_test.go</code> files should be placed in the same directory - we let Go worry
what files should be loaded depending on what <code>go</code> command we run.</p><p>Looking at Golang&rsquo;s source code oddly I found some disregard for these rules.
For example, the tests for the <code>fmt</code> package in the standard library, belong to
a <a href=https://github.com/golang/go/blob/e9188d1d18040bc6cb46065b2474664b8728a6df/src/fmt/stringer_test.go#L5><code>fmt_test</code>
package</a>,
instead of the <code>fmt</code> package.</p><p>At first, my observation was that this is wrong and for some reason it is not
fixed yet. After a more thorough research it was obvious that this is an
intentional approach and not a mistake. As explained in
<a href=https://stackoverflow.com/a/31443271/601555>this</a> Stack Overflow answer, the
best way to look at this is to differentiate the two approaches as &ldquo;black box&rdquo;
and &ldquo;white box&rdquo; testing.</p><p>The <strong>black box approach</strong>, where the test and the production code are in
separate packages, allows us to test only the <a href=https://golang.org/ref/spec#Exported_identifiers>exported
identifiers</a> of a package.
This means that our test package will not have access to any of the internal
functions, variables or constants that are in the production code.</p><p>The <strong>white box approach</strong>, where the test and the production code are in the same
package, allows us to test both the non-exported and expored identifiers of the
package. This is the preferrable approach when writing unit tests that require
access to non-exported variables, functions, and methods.</p><p>I personally find the white box approach preferrable, because this is the
default behaviour of the tooling that ships with the language. We as users of
said tooling should employ good judgement and conventions to write code that is
testable and avoid touching non-exported identifiers in the tests. In other
words, we should adhere to the defaults, unless we have a really good reason
not to.</p><p>In any case, if you would like to learn how to idiomatic Go and how to organise
your packages properly, the source code of the language is the best place to
learn from.</p><figure class=imagecaption><img class=caption src=/testing-in-go-naming-conventions/design_thinking.png caption alt="Person thinking about shapes">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=function-naming-conventions>Function naming conventions<a hidden class=anchor aria-hidden=true href=#function-naming-conventions>#</a></h2><p>While the file naming convention is enforced by the language and its toolkit,
test function naming conventions are loosely enforced by Go, but are community
driven.</p><p>In Go, each test file is composed of one or many test functions. Each test
function has the following signature structure:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>TestXxx</span>(*testing.T)
</code></pre></td></tr></table></div></div><p>What&rsquo;s important to notice is that <code>Xxx</code> does not start with a lowercase
letter. The function name serves to identify the test routine. A simple test
function looks like this (stolen from <a href=https://golang.org/pkg/testing/>here</a>):</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>TestAbs</span>(t *testing.T) {
    got := <span style=color:#0087ff>Abs</span>(-<span style=color:#00afaf>1</span>)
    <span style=color:#5f8700>if</span> got != <span style=color:#00afaf>1</span> {
        t.<span style=color:#0087ff>Errorf</span>(<span style=color:#00afaf>&#34;Abs(-1) = %d; want 1&#34;</span>, got)
    }
}
</code></pre></td></tr></table></div></div><p>And that&rsquo;s all that&rsquo;s enforced by Go and it&rsquo;s toolkit. Still, there are a few
common ways to name your test functions. For example, we have a simple type
<code>Person</code> with <code>age</code> attribute. It receives a function <code>older</code> which checks what
if one <code>Person</code> is older than another <code>Person</code>, by comparing their <code>age</code>
attributes.</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#d75f00>package</span> main

<span style=color:#0087ff>type</span> Person <span style=color:#0087ff>struct</span> {
	age  <span style=color:#af0000>int64</span>
}

<span style=color:#0087ff>func</span> (p *Person) <span style=color:#0087ff>older</span>(other *Person) <span style=color:#af0000>bool</span> {
	<span style=color:#5f8700>return</span> p.age &gt; other.age
}
</code></pre></td></tr></table></div></div><p>We would write a test function for <code>older</code>, looking like this:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#d75f00>package</span> main

<span style=color:#d75f00>import</span> (
	<span style=color:#00afaf>&#34;fmt&#34;</span>
	<span style=color:#00afaf>&#34;testing&#34;</span>
)

<span style=color:#0087ff>func</span> <span style=color:#0087ff>TestOlder</span>(t *testing.T) {
	p1 := &amp;Person{<span style=color:#00afaf>21</span>}
	p2 := &amp;Person{<span style=color:#00afaf>22</span>}

	<span style=color:#5f8700>if</span> !p1.<span style=color:#0087ff>older</span>(p2) {
		t.<span style=color:#0087ff>Fatalf</span>(fmt.<span style=color:#0087ff>Sprintf</span>(<span style=color:#00afaf>&#34;Expected %d &gt; %d&#34;</span>, p1.age, p2.age))
	}
}
</code></pre></td></tr></table></div></div><p>Here we name our test function <code>TestOlder</code>, which clearly states the function
under test - <code>older</code>. This is in line with what the <code>testing</code> package expects -
a <code>PascalCased</code> function name, starting with <code>Test</code>. What comes after is up to
us.</p><p>In our small example, calling the test function <code>TestOlder</code> is the most common
approach that you will see in the wild. But, what if we want to test the same
function (<code>older</code>) in more test functions? Do we use <code>TestOlder1</code>,
<code>TestOlder2</code>, etc. as test function names? Or is there a better way?</p><p>For such scenarios, I have found a few approaches in the wild:</p><p>The Golang source code itself has a naming convention. If we zero in on an
example, like <a href=https://github.com/golang/go/blob/master/src/strings/compare_test.go>the
test</a>
where the <code>strings.Compare</code> function is tested, we can see the convention in
action:</p><ol><li>The base test function follows the format of <code>Test</code> + the name of the
function under test. For example <code>TestCompare</code>, which tests the <code>Compare</code>
function.</li><li>More specific tests, for example a test that compares two idential strings,
is called <code>TestCompareIndentialStrings</code>. Tests that are more specific express
that in the name, using the <code>PascalCase</code> naming scheme.</li></ol><p>We can see the same pattern in other files, for example in
<a href=https://github.com/golang/go/blob/master/src/flag/flag_test.go><code>flag_test.go</code></a>,
where the functionality of the <code>flags</code> package is tested. Notable examples there
are the <code>TestUserDefined</code> and <code>TestUserDefinedForCommandLine</code> test functions:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>TestUserDefined</span>(t *testing.T) {
	<span style=color:#4e4e4e>// Snipped...
</span><span style=color:#4e4e4e></span>}

<span style=color:#0087ff>func</span> <span style=color:#0087ff>TestUserDefinedForCommandLine</span>(t *testing.T) {
	<span style=color:#4e4e4e>// Snipped...
</span><span style=color:#4e4e4e></span>}
</code></pre></td></tr></table></div></div><p>Moving on to another popular Golang project, <a href=https://www.consul.io/>consul</a>
by HashiCorp, we can see a different test functions naming convention. If we
look at the
<a href=https://github.com/hashicorp/consul/blob/master/api/api_test.go><code>api_test.go</code></a>
file, where the API client is tested, we can see that the project uses a naming
convention where:</p><ol><li>The base test function follows the format of <code>Test</code> + the name of the
package where the function is placed, with the function name appended after
an underscore (<code>_</code>). For example, the <code>API.Debug.Heap()</code> function is tested
in the <code>TestAPI_DebugHeap</code> test function. Similarly, the
<code>API.SetupTLSConfig</code> is tested in <code>TestAPI_SetupTLSConfig</code> test function.</li><li>There are functions like <code>API.Agent.Services()</code> that require more specific
tests. That&rsquo;s why, for example there are
<a href=https://github.com/hashicorp/consul/blob/master/api/agent_test.go#L170><code>TestAPI_AgentServices</code></a>
and
<a href=https://github.com/hashicorp/consul/blob/master/api/agent_test.go#L234><code>TestAPI_AgentServicesWithFilter</code></a>,
where in the latter there is more specific functionality being tested.</li></ol><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>TestAPI_AgentServices</span>(t *testing.T) {
	<span style=color:#4e4e4e>// Snipped...
</span><span style=color:#4e4e4e></span>}

<span style=color:#0087ff>func</span> <span style=color:#0087ff>TestAPI_AgentServicesWithFilter</span>(t *testing.T) {
	<span style=color:#4e4e4e>// Snipped...
</span><span style=color:#4e4e4e></span>}
</code></pre></td></tr></table></div></div><p>These are just a few examples of test function naming conventions, so expect
to find some others in the ecosystem. There are various conventions when it
comes to naming testing functions, but all of them have to follow the basic
format of <code>TestXxx</code> that the <code>testing</code> package enforces.</p><h2 id=variable-naming-conventions>Variable naming conventions<a hidden class=anchor aria-hidden=true href=#variable-naming-conventions>#</a></h2><p>While there is strict enforcement of the file name convention, and a loose
enforcement of test function naming, things are very relaxed when it comes to
variables naming. Basically, Golang does not enforce any conventions on the
naming of the variables that we can use in our tests via the tooling.</p><p>This in theory means that everyone can come up with their own variable names.
But, what does that mean in practice? What do popular open source projects do
when it comes to naming variables?</p><p>Before we dive in any open source projects, we have to go back to the basics.
I am not sure if this is well known (enough), as I have found it a bit too
burried in the Github wiki, but Go has a nice &ldquo;Go Code Review Comments&rdquo;
<a href=https://github.com/golang/go/wiki/CodeReviewComments>page</a> where variable
names are discussed.</p><p>While the section is short, it says a lot about how we should be naming our
variables:</p><blockquote><p>Variable names in Go should be short rather than long. This is especially
true for local variables with limited scope. Prefer <code>c</code> to <code>lineCount</code>.
Prefer <code>i</code> to <code>sliceIndex</code>.</p></blockquote><p>This part is self-explanatory. Go errs on the side of short variable names. In
my personal opinion this does not make sense in a time of very powerful text
editors that autocomplete our code. I prefer to be lazy and read what each
variable means than figuring out what <code>c</code>, <code>t</code> or <code>p</code> mean. Still, if you
believe in consistency, we should all follow the same guidelines when writing
Go.</p><p>Futher, it says:</p><blockquote><p>The basic rule: the further from its declaration that a name is used, the
more descriptive the name must be.</p></blockquote><p>This is something I personally like as a rule – the cognitive weight should be
small when regaining context of what a variable or concept means. In such
cases, <code>configuration</code> (or <code>conf</code>) can do wonders compared to <code>c</code>.</p><p>Lastly, it states:</p><blockquote><p>Common variables such as loop indices and readers can be a single letter
(<code>i</code>, <code>r</code>). More unusual things and global variables need more descriptive
names.</p></blockquote><p>The <code>i</code>, <code>j</code> & <code>k</code> variable names for indices are very commonly used, especially
in C-inspired languages, so if you are a little bit experienced (or been exposed)
to them this will be expected.</p><p>But, are we <a href=https://en.wikipedia.org/wiki/Law_of_triviality>bikeshedding</a>
here? Why are we discussing variable names, does it matter <strong>that much</strong>?</p><p>Well, Go tests are just code. Being code, we should expect that all tests
follow these guidelines just like all other code does. Also, we should write
our tests using these guidelines so our tests feel familiar to others that will
work with them. There shouldn&rsquo;t be a major change of code style when switching
between business logic and tests.</p><p>Now, let&rsquo;s go back to popular open source projects writen in Go:</p><p>Looking at <a href=https://www.terraform.io>Terraform</a>, another popular HashiCorp
project, one thing that is ubiquitous about its test suite is that the project
has both, the <code>actual</code>/<code>expected</code> and the <code>got</code>/<code>want</code> naming convention when
it comes to test failures.</p><p>Basically, the test case has an <code>expected</code> value, which is what we expect the
function under test to return. The <code>actual</code> value is what the function under
test returned. What is convenient about following that naming convention is
that <code>expected</code> and <code>actual</code> clearly state that those are the values that will
have to be compared with each other, which will drive the decision if the test
will pass or not:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#4e4e4e>// From: https://github.com/hashicorp/terraform/blob/250527d923f07130c36e65f9bb43b58fcbfe66cf/httpclient/useragent_test.go#L41-L43
</span><span style=color:#4e4e4e></span><span style=color:#5f8700>if</span> c.expected != actual {
  t.<span style=color:#0087ff>Fatalf</span>(<span style=color:#00afaf>&#34;Expected User-Agent &#39;%s&#39; does not match &#39;%s&#39;&#34;</span>, c.expected, actual)
}
</code></pre></td></tr></table></div></div><p>Another way to achieve the same is the <code>got</code>/<code>want</code> naming, where the
comparison looks like:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#4e4e4e>// From: https://github.com/hashicorp/terraform/blob/250527d923f07130c36e65f9bb43b58fcbfe66cf/backend/unparsed_value_test.go#L34-L45
</span><span style=color:#4e4e4e></span><span style=color:#5f8700>if</span> got, want := diags[<span style=color:#00afaf>3</span>].<span style=color:#0087ff>Description</span>().Summary, undeclPlural; got != want {
  t.<span style=color:#0087ff>Errorf</span>(<span style=color:#00afaf>&#34;wrong summary for diagnostic 3\ngot:  %s\nwant: %s&#34;</span>, got, want)
}
</code></pre></td></tr></table></div></div><p>The idea behind the naming is the same, but the goal is to fail with <a href=/testing-in-go-writing-practical-failure-messages>a
practical message</a> to
whoever&rsquo;s debugging your code in the future.</p><p>From here on, delving in the variables conventions further would not prove to
be productive, yet following the naming conventions that we discussed above is
good enough for your tests. If you would like to read more on the topic, I
suggest reading the &ldquo;Names&rdquo; section of <a href=https://golang.org/doc/effective_go.html#names>Effective
Go</a> and &ldquo;Variable Names&rdquo;
section of the <a href=https://github.com/golang/go/wiki/CodeReviewComments#variable-names>Go Code Review
Comments</a>
wiki page.</p><figure class=imagecaption><img class=caption src=/testing-in-go-naming-conventions/void.png caption alt="Person looking into the void">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=making-things-boring>Making things boring<a hidden class=anchor aria-hidden=true href=#making-things-boring>#</a></h2><p>Probably you now:</p><blockquote><p>Why do you bother me with these rules and conventions? <code>go fmt</code> takes care of
my code, isn&rsquo;t that enough?</p></blockquote><p>I hear you and I get your point.</p><p>Here&rsquo;s how I look at it: easy conventions to follow diminish entropy, which
makes for simpler and predictable code. The less cognitive load we have to
absorb when working with a piece of code – the better.</p><p>In other words: I like boring code. Boring code is good. I like code that will
dully adhere to Go&rsquo;s naming conventions, regardless if I find them appealing or
not. Conventions are put in place to make our lives easier, by not having to
think if it should be <code>i</code> or <code>index</code>, and knowing that <code>conf</code> will always mean
<code>configuration</code>.</p><p>And I hope that you will find the boringness of such conventions liberating and
empowering over time.</p><section class=subscribe><b>Liked this article?</b> <a href=/newsletter>Subscribe to my
newsletter</a> and get my fresh posts in your inbox. It's short and sweet,
going out monthly to over 1,000 subscribers.</section></div><footer class=post-footer><nav class=paginav><a class=prev href=https://ieftimov.com/post/testing-in-go-go-test/><span class=title>« Prev Page</span><br><span>Testing in Go: go test</span></a>
<a class=next href=https://ieftimov.com/post/testing-in-go-writing-practical-failure-messages/><span class=title>Next Page »</span><br><span>Testing in Go: Writing Practical Failure Messages</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Naming Conventions on twitter" href="https://twitter.com/intent/tweet/?text=Testing%20in%20Go%3a%20Naming%20Conventions&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-naming-conventions%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Naming Conventions on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-naming-conventions%2f&title=Testing%20in%20Go%3a%20Naming%20Conventions&summary=Testing%20in%20Go%3a%20Naming%20Conventions&source=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-naming-conventions%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Naming Conventions on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-naming-conventions%2f&title=Testing%20in%20Go%3a%20Naming%20Conventions"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Naming Conventions on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-naming-conventions%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Naming Conventions on whatsapp" href="https://api.whatsapp.com/send?text=Testing%20in%20Go%3a%20Naming%20Conventions%20-%20https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-naming-conventions%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing in Go: Naming Conventions on telegram" href="https://telegram.me/share/url?text=Testing%20in%20Go%3a%20Naming%20Conventions&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-in-go-naming-conventions%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>