<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang | Ilija Eftimov ⚡️</title><meta name=keywords content="caching,lru,last recently used,golang"><meta name=description content="One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.
  Before we go too much into details about the implementation of an LRU cache, let&rsquo;s first see what are the possible applications of this caching scheme."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang"><meta property="og:description" content="One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.
  Before we go too much into details about the implementation of an LRU cache, let&rsquo;s first see what are the possible applications of this caching scheme."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/"><meta property="og:image" content="https://ieftimov.com/cards/spotify-recently-played-least-recently-used-cache-golang.png"><meta property="article:section" content="posts"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/spotify-recently-played-least-recently-used-cache-golang.png"><meta name=twitter:title content="Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang"><meta name=twitter:description content="One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.
  Before we go too much into details about the implementation of an LRU cache, let&rsquo;s first see what are the possible applications of this caching scheme."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang","item":"https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang","name":"Barebones model of Spotify\u0027s \u0027Recently Played\u0027 screen using a Least Recently Used (LRU) cache in Golang","description":"One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.\n  Before we go too much into details about the implementation of an LRU cache, let\u0026rsquo;s first see what are the possible applications of this caching scheme.","keywords":["caching","lru","last recently used","golang"],"articleBody":"One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.\n  Before we go too much into details about the implementation of an LRU cache, let’s first see what are the possible applications of this caching scheme.\nApplications LRU cache applications are diverse. The LRU cache eviction scheme is one of the most widespread and used scheme. Due to its nature, it often does the trick for conventional problems in commercial programming. For example, if one has a fixed amount of memory, the most natural way to cache is to keep recently accessed items.\nSo, what would be one potential application of a LRU cache? Let’s see an example.\nOpen your Spotify application (if you have one). Don’t have one? Here’s a screenshot of mine:\n  You can see in the screenshot above that I have chosen the “Recently played” view. To no one’s surprise, it shows all my recently played media. If you’ve never thought about the implementation of such a screen, let me break the magic down for you. This view is a GUI that lives on top of some sort of an LRU cache.\nCurious how we would model such a “Recently played” view? Let’s take a deeper look.\nEstablishing basic types Let’s define couple of types that would represent the Playlists and Songs found on Spotify:\n1 2 3 4 5  type Song struct { duration int64 // seconds \ttitle string artist *Artist }   No surprises here - a Song has a duration, a title and an artist. Let’s look at a Playlist:\n1 2 3 4 5 6 7  type Playlist struct { title string descrption string duration int64 // seconds \tpublishedAt int32 // Unix timestamp \tsongs []*Song }   A Playlist has a title, description, duration (which is the sum of the durations of all songs in it). Also, a publishedAt which is the date of the publishing of the playlist. Finally it has songs - a slice of Song pointers representing the songs in the playlist.\nSuch structure of the Playlist struct will allow users to find a playlist and “just play it”.\nRecently played The “Recently played” screen in Spotify has 30 items only, where each of the items can be a playlist, an artist or an album. For simplicity of our example here, we will agree that we will only keep track of the recently played playlists. This means that we’ll ignore the artists or albums in our version of the “Recently Played” screen.\nA typical implementation of a LRU cache uses a combination of two simple data structures: a hash table and a linked list. Why? Well, as I mentioned in another article on caching, caches have to be fast along two dimensions:\n Ensuring that as many of the requests for files go to it (cache hit), not over the network or to main memory (cache miss); The overhead of using it should be small: testing membership and deciding when to replace a Playlist should be as fast as possible.  On the first point, we have agreed that LRU will do the job because of the nature of the “Recently played” screen. This means that we have to keep track of what Playlists are recently played. A data structure that allows us to do this is a linked list. Since Go already provides us a doubly-linked list implementation, there is no need to reinvent the wheel. We will use the container/list package 1.\nOn the second point, the data structure that comes to mind for a scalable membership tests is a hash table. 2 As you might know, hash tables have unique keys for every value. If our program can create a unique key for a Playlist, it will be easy for us to check if the Playlist is in the cache or not.\nKnowing this, let’s define the RecentlyPlayed struct and its constructor function:\n1 2 3 4 5 6  type RecentlyPlayed struct { capacity int size int cache map[int]*list.Element lru *list.List }   Things are pretty self explanatory here. capacity will hold the maximum capacity of the cache and size will be the current size of the recently played screen. We will use the cache hash table to retrieve the elements from cache. The lru is a linked list (from the container/list package) that we will use to keep track of the recently played playlists.\nLet’s first create a small function that will spawn up a new RecentlyPlayed struct with some sane defaults:\n1 2 3 4 5 6 7 8 9 10  func NewRecentlyPlayed(capacity int) *RecentlyPlayed { rp := RecentlyPlayed{ capacity: capacity, size: 0, lru: list.New(), cache: make(map[string]*list.Element), } return \u0026rp }   This function sets the defaults to the struct and returns a pointer to it. Before we continue, let’s make a quick stop. Let’s take a moment to understand how each of these two data structures will work together.\nFirst, cache is going to be a map that will have a key of type string and a value of type *list.Element. The string will be a hash of the Playlist that will be stored there, while the *list.Element will be a pointer to the element in the doubly-linked list. By having this pointer, we can get the Playlist stored inside it (it’s Value). Also, it will be easy to reposition it in the lru list when we play the Playlist.\n  Introducing the player To have a “Recently played” list of playlists, we obviously need to put it in some sort of a player, that will have a Play function.\nHere’s a quick sketch of it, so we can move to the meat of our implementation:\n1 2 3 4  type Player struct { playProgress int RecentlyPlayedList *RecentlyPlayed }   For the purpose of this example, we can keep the Player quite simple - only the progress of the song currently playing (playProgress) and the recently played list of playlists (RecentlyPlayedList).\nWe will also add a small constructor function for the Player:\n1 2 3 4 5 6  func NewPlayer() *Player { p := Player{ RecentlyPlayedList: NewRecentlyPlayed(30), } return \u0026p }   Now we need to add the Play function and understand what are the functions related to RecentlyPlayed that Play will have to invoke.\nPlaying a Playlist Obviously, there’a already an entity that will have to play the Playlist - the Player. Let’s add a function Play to our Player:\n1 2 3 4 5 6 7 8  func (player *Player) Play(playlist *Playlist) { if cached, playlist := player.RecentlyPlayedList.Get(playlist.hash()); cached { // Play from cache... \t} else { // Fetch over the network and start playing... \tplayer.RecentlyPlayedList.Set(playlist) } }   If you thought that I’d show you how we’ll actually play a media file or stream it over the network I am sorry to disappoint. That’s a tad out of the scope of this article. That being said, I am always looking for topic ideas to write on, although I have a huge list already, so if that’s something you’d like to read on drop a comment below.\n Let’s dissect the Play function:\n  The player.RecentlyPlayedList struct is of type *RecentlyPlayed. It has a function Get which will return a bool and a playlist which our player can then play.\n  If it doesn’t find a cached playlist it will fetch/start streaming the playlist over the network. Then, it will cache it using the Set function of the RecentlyPlayedLists struct.\n  So, what is the behaviour and the internals of these two new methods, Get and Set?\nGetting a Playlist from cache To retrieve a Playlist from cache is actually a cheap task, from time perspective. Our cache is hash table-backed which has a O(1) time complexity for the access operation. The trick is once we access an item in cache we also have to move it to the beginning of the lru list.\nIn other words, we need to promote it as the most recently used item in the RecentlyPlayedList. Given that we use a linked list-backed cache, we have to take our item from the list and move it to the front.\nLet’s see how that would work in our context:\n1 2 3 4 5 6 7 8  func (rp *RecentlyPlayed) Get(key string) (*Playlist, bool) { if elem, present := rp.cache[key]; present { rp.lru.MoveToFront(elem) return elem.Value.(*Playlist), true } else { return nil, false } }   In case you were expecting some magic here – sorry to disappoint, but this is pretty simple. Its a three step function:\n Checks if it finds the item in the cache. If not it returns a nil. Otherwise, it moves the element to the beginning of the LRU list, and It returns the value of the *list.Element, which is the pointer to the Playlist that our player will play  That’s it, pretty simple.\nHash table key for a Playlist Before we move on to Set, let’s quickly discuss the implementation of the hash function.\n1 2 3 4 5 6 7 8 9 10 11 12 13  func (playlist *Playlist) hash() string { hash := sha1.New() s := fmt.Sprintf( \"%d-%s-%s-%d\", playlist.duration, playlist.title, playlist.description, playlist.publishedAt, ) hash.Write([]byte(s)) sum := hash.Sum(nil) return fmt.Sprintf(\"%x\", sum) }   As you can see, it’s a simple one - it’s goal is just to generate a reproducible hash for a Playlist. It basically concatenates the attributes of the Playlist struct and then applies a SHA1 hashing sum on it. As the last step, it returns the hash in a hexidecimal format.\nSetting a Playlist to cache Now that we have the hash function out of the way, let’s look at the code of the Set function. After, we can discuss the steps this function takes to add a Playlist to the cache:\n1 2 3 4 5 6 7 8 9 10  func (rp *RecentlyPlayed) Set(playlist *Playlist) { key := playlist.hash() if elem, present := rp.cache[key]; present { rp.lru.MoveToFront(elem) } else { elem := rp.lru.PushFront(playlist) rp.size++ } rp.cache[key] = elem }   The Set function takes a *Playlist as an argument. It is then hashed using the hash method that implemented by RecentlyPlayed. It returns a unique key based on some attributes of the Playlist. The key is then used when the Playlist is added in the hash table caches.\nBut before we add it to the hash table cache, we will check if there’s already a value in the cache hash table with the same key. If so, we will only move the *Playlist to the front of the lru linked list.\nIf not, we push the *Playlist to the front of the lru linked list, as the most recently used item. This returns a *list.Element, which for its Value expects an interface{} (which is the Go way to say “any type”). The *list.Element will wrap the *Playlist as its Value.\nThis means that any time we access the elem.Value we will have to cast it to its proper type, since *list.Element does not know the type of its Value (remember, it accepts any type).\nAfter the playlist is added to the front of the lru list, the Set function will increment the RecentlyPlayed’s size due to the new item added to the list.\nFinally, the function will cache the *list.Element in the cache hash table\n which we will use to retrieve the playlist with a O(1) time complexity.    Eviction Now that we know how the Get and Set functions work, we need to take one more thing into consideration. That is Spotify’s limitation of the size of the recently played screen. It means that once the number of playlists reaches a threshold, it removes the least recently played playlist. This will make the room to add a new one to the list.\nThis is the eviction algorithm that we have to write for our LRU cache, which powers the recently played screen. In our implementation we’ll call the function increment:\n1 2 3 4 5 6 7 8  func (rp *RecentlyPlayed) increment(element *list.Element) { rp.lru.MoveToFront(element) if rp.size == rp.capacity { lruItem := rp.lru.Back() rp.lru.Remove(lruItem) rp.size-- } }   Every time we want to increment the usage of a certain *list.Element, the function will take these two steps:\n Move the accessed element to be beginning of the lru linked list, and When the size of the RecentlyPlayed struct has reached its capacity, remove the last item in the lru linked list  This function will allow us to handle the eviction of the least recently used item in the list of playlists. Now, we can revisit our Set and Get functions and drop this function in:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func (rp *RecentlyPlayed) Set(playlist *Playlist) { key := playlist.hash() if elem, present := rp.cache[key]; present { rp.increment(elem) // \t} else { elem := rp.lru.PushFront(playlist) rp.size++ } rp.cache[key] = elem } func (rp *RecentlyPlayed) Get(key string) (*Playlist, bool) { if elem, present := rp.cache[key]; present { rp.increment(elem) // \treturn elem.Value.(*Playlist), true } else { return nil, false } }   Now that we have the increment function, we will use it in the Set and Get functions. By doing this, we will update the list of recently used items every time we play a Playlist.\nThis change will unlock two things for our recently played screen:\n It will change the order of the cached playlists, based on the how recently the playlists are played It will remove any playlists once size exceeds capacity  In closing Now that we have a Go-powered sketch of Spotify’s recently played screen, let’s do a quick recap.\nTo shine some light on the shortcomings:\n This is a barebones model - it lacks any mechanisms to stream/download the playlists via the internet. We agreed that although interesting, this would be hard to cover in this article. The model does not take into account any restarting of the application. This means if we stop and start the program the cached playlists will be gone. This is because our implementation does not store the data on disk (only in memory). We do not have any graphical user interface to interact with the application - only a couple of functions that we can invoke.  While all the above is a shortcoming of our implementation, it still paints the picture of how we could write such a program using Go. The combination of a linked list \u0026 a hash table works nice for solving the problem at hand. From time complexity perspective, it scales well. And, for our tiny scenario, the hit-to-miss ratio should is optimal.\nIf you would like to read more of my rambling about caching algorithms, you can also read “When and Why to use a Least Frequently Used (LFU) cache with an implementation in Golang” 3.\nLiked this article? You can buy me a coffee. Or simply subscribe to my newsletter and get my fresh posts in your inbox. It's short and sweet, going out monthly to over 1,000 subscribers.    Package that implements a doubly linked list: https://golang.org/pkg/container/list/ ↩︎\n Or a bloom filter - good article on the topic: https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/ ↩︎\n Article I published on this very blog: https://ieftimov.com/when-why-least-frequently-used-cache-implementation-golang ↩︎\n   ","wordCount":"2560","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/spotify-recently-played-least-recently-used-cache-golang/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang</h1><div class=post-meta>March 11, 2019&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#applications aria-label=Applications>Applications</a></li><li><a href=#establishing-basic-types aria-label="Establishing basic types">Establishing basic types</a></li><li><a href=#recently-played aria-label="Recently played">Recently played</a></li><li><a href=#introducing-the-player aria-label="Introducing the player">Introducing the player</a></li><li><a href=#playing-a-playlist aria-label="Playing a Playlist">Playing a <code>Playlist</code></a></li><li><a href=#getting-a-playlist-from-cache aria-label="Getting a Playlist from cache"><code>Get</code>ting a <code>Playlist</code> from cache</a></li><li><a href=#hash-table-key-for-a-playlist aria-label="Hash table key for a Playlist">Hash table key for a <code>Playlist</code></a></li><li><a href=#setting-a-playlist-to-cache aria-label="Setting a Playlist to cache"><code>Set</code>ting a <code>Playlist</code> to cache</a></li><li><a href=#eviction aria-label=Eviction>Eviction</a></li><li><a href=#in-closing aria-label="In closing">In closing</a></li></ul></div></details></div><div class=post-content><p>One of the most used caching schemes is Least Recently Used (LRU). Caches that
use this eviction strategy will remove the least recently used item when their
size reaches their capacity. That means that such caches have to keep a track
of the order of access of the cached items, so it would evict the correct
items.</p><figure class=imagecaption><img class=caption src=/spotify-recently-played-least-recently-used-cache-golang/music.png caption alt="Person looking at a report page">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Before we go too much into details about the implementation of an LRU cache,
let&rsquo;s first see what are the possible applications of this caching scheme.</p><h2 id=applications>Applications<a hidden class=anchor aria-hidden=true href=#applications>#</a></h2><p>LRU cache applications are diverse. The LRU cache eviction scheme is one of the
most widespread and used scheme. Due to its nature, it often does the trick for
conventional problems in commercial programming. For example, if one has a
fixed amount of memory, the most natural way to cache is to keep recently
accessed items.</p><p>So, what would be one potential application of a LRU cache? Let&rsquo;s see an
example.</p><p>Open your Spotify application (if you have one). Don&rsquo;t have one? Here&rsquo;s a
screenshot of mine:</p><figure class=imagecaption><img class=caption src=/golang-lru-cache/spotify.png caption alt="Spotify desktop application screenshot">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>You can see in the screenshot above that I have chosen the &ldquo;Recently played&rdquo;
view. To no one&rsquo;s surprise, it shows all my recently played media. If you’ve
never thought about the implementation of such a screen, let me break the magic
down for you. This view is a GUI that lives on top of some sort of an LRU
cache.</p><p>Curious how we would model such a &ldquo;Recently played&rdquo; view? Let&rsquo;s take a deeper
look.</p><h2 id=establishing-basic-types>Establishing basic types<a hidden class=anchor aria-hidden=true href=#establishing-basic-types>#</a></h2><p>Let&rsquo;s define couple of types that would represent the <code>Playlist</code>s and <code>Song</code>s
found on Spotify:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> Song <span style=color:#0087ff>struct</span> {
	duration  <span style=color:#af0000>int64</span> <span style=color:#4e4e4e>// seconds
</span><span style=color:#4e4e4e></span>	title     <span style=color:#af0000>string</span>
	artist    *Artist
}</code></pre></td></tr></table></div></div><p>No surprises here - a <code>Song</code> has a <code>duration</code>, a <code>title</code> and an <code>artist</code>. Let&rsquo;s
look at a <code>Playlist</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> Playlist <span style=color:#0087ff>struct</span> {
	title       <span style=color:#af0000>string</span>
	descrption  <span style=color:#af0000>string</span>
	duration    <span style=color:#af0000>int64</span> <span style=color:#4e4e4e>// seconds
</span><span style=color:#4e4e4e></span>	publishedAt <span style=color:#af0000>int32</span> <span style=color:#4e4e4e>// Unix timestamp
</span><span style=color:#4e4e4e></span>	songs       []*Song
}</code></pre></td></tr></table></div></div><p>A <code>Playlist</code> has a <code>title</code>, <code>description</code>, <code>duration</code> (which is the sum of the
durations of all songs in it). Also, a <code>publishedAt</code> which is the date of the
publishing of the playlist. Finally it has <code>songs</code> - a slice of <code>Song</code> pointers
representing the songs in the playlist.</p><p>Such structure of the <code>Playlist</code> <code>struct</code> will allow users to find a playlist
and &ldquo;just play it&rdquo;.</p><h2 id=recently-played>Recently played<a hidden class=anchor aria-hidden=true href=#recently-played>#</a></h2><p>The &ldquo;Recently played&rdquo; screen in Spotify has 30 items only, where each of the
items can be a playlist, an artist or an album. For simplicity of our example
here, we will agree that we will only keep track of the recently played
playlists. This means that we&rsquo;ll ignore the artists or albums in our version of
the &ldquo;Recently Played&rdquo; screen.</p><p>A typical implementation of a LRU cache uses a combination of two simple data
structures: a hash table and a linked list. Why? Well, as I mentioned in
<a href=https://ieftimov.com/when-why-least-frequently-used-cache-implementation-golang>another article on
caching</a>,
caches have to be fast along two dimensions:</p><ol><li>Ensuring that as many of the requests for files go to it (cache hit), not
over the network or to main memory (cache miss);</li><li>The overhead of using it should be small: testing membership and deciding
when to replace a <code>Playlist</code> should be as fast as possible.</li></ol><p>On the first point, we have agreed that LRU will do the job because of the
nature of the &ldquo;Recently played&rdquo; screen. This means that we have to keep track
of what <code>Playlist</code>s are recently played. A data structure that allows us to do
this is a linked list. Since Go already provides us a doubly-linked list
implementation, there is no need to reinvent the wheel. We will use the
<code>container/list</code> package <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>On the second point, the data structure that comes to mind for a scalable
membership tests is a hash table. <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> As you might know, hash tables have
unique keys for every value. If our program can create a unique key for a
<code>Playlist</code>, it will be easy for us to check if the <code>Playlist</code> is in the cache
or not.</p><p>Knowing this, let&rsquo;s define the <code>RecentlyPlayed</code> struct and its constructor
function:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> RecentlyPlayed <span style=color:#0087ff>struct</span> {
	capacity <span style=color:#af0000>int</span>
	size     <span style=color:#af0000>int</span>
	cache    <span style=color:#0087ff>map</span>[<span style=color:#af0000>int</span>]*list.Element
	lru      *list.List
}</code></pre></td></tr></table></div></div><p>Things are pretty self explanatory here. <code>capacity</code> will hold the maximum
capacity of the cache and <code>size</code> will be the current size of the recently
played screen. We will use the <code>cache</code> hash table to retrieve the elements from
cache. The <code>lru</code> is a linked list (from the <code>container/list</code> package) that we
will use to keep track of the recently played playlists.</p><p>Let&rsquo;s first create a small function that will spawn up a new <code>RecentlyPlayed</code>
struct with some sane defaults:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>NewRecentlyPlayed</span>(capacity <span style=color:#af0000>int</span>) *RecentlyPlayed {
	rp := RecentlyPlayed{
		capacity: capacity,
                size:     <span style=color:#00afaf>0</span>,
		lru:      list.<span style=color:#0087ff>New</span>(),
		cache:    <span style=color:#0087ff>make</span>(<span style=color:#0087ff>map</span>[<span style=color:#af0000>string</span>]*list.Element),
	}

	<span style=color:#5f8700>return</span> &amp;rp
}</code></pre></td></tr></table></div></div><p>This function sets the defaults to the struct and returns a pointer to it.
Before we continue, let&rsquo;s make a quick stop. Let&rsquo;s take a moment to understand
how each of these two data structures will work together.</p><p>First, <code>cache</code> is going to be a <code>map</code> that will have a key of type <code>string</code> and
a value of type <code>*list.Element</code>. The <code>string</code> will be a hash of the <code>Playlist</code>
that will be stored there, while the <code>*list.Element</code> will be a pointer to the
element in the doubly-linked list. By having this pointer, we can get the
<code>Playlist</code> stored inside it (it&rsquo;s <code>Value</code>). Also, it will be easy to reposition
it in the <code>lru</code> list when we play the Playlist.</p><figure class=imagecaption><img class=caption src=/spotify-recently-played-least-recently-used-cache-golang/media_player.png caption alt="Music player">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=introducing-the-player>Introducing the player<a hidden class=anchor aria-hidden=true href=#introducing-the-player>#</a></h2><p>To have a &ldquo;Recently played&rdquo; list of playlists, we obviously need to put it in
some sort of a player, that will have a <code>Play</code> function.</p><p>Here&rsquo;s a quick sketch of it, so we can move to the meat of our implementation:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> Player <span style=color:#0087ff>struct</span> {
	playProgress       <span style=color:#af0000>int</span>
	RecentlyPlayedList *RecentlyPlayed
}</code></pre></td></tr></table></div></div><p>For the purpose of this example, we can keep the <code>Player</code> quite simple - only
the progress of the song currently playing (<code>playProgress</code>) and the recently
played list of playlists (<code>RecentlyPlayedList</code>).</p><p>We will also add a small constructor function for the <code>Player</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>NewPlayer</span>() *Player {
	p := Player{
		RecentlyPlayedList: <span style=color:#0087ff>NewRecentlyPlayed</span>(<span style=color:#00afaf>30</span>),
	}
	<span style=color:#5f8700>return</span> &amp;p
}</code></pre></td></tr></table></div></div><p>Now we need to add the <code>Play</code> function and understand what are the functions
related to <code>RecentlyPlayed</code> that <code>Play</code> will have to invoke.</p><h2 id=playing-a-playlist>Playing a <code>Playlist</code><a hidden class=anchor aria-hidden=true href=#playing-a-playlist>#</a></h2><p>Obviously, there&rsquo;a already an entity that will have to play the <code>Playlist</code> - the
<code>Player</code>. Let&rsquo;s add a function <code>Play</code> to our <code>Player</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (player *Player) <span style=color:#0087ff>Play</span>(playlist *Playlist) {
	<span style=color:#5f8700>if</span> cached, playlist := player.RecentlyPlayedList.<span style=color:#0087ff>Get</span>(playlist.<span style=color:#0087ff>hash</span>()); cached {
		<span style=color:#4e4e4e>// Play from cache...
</span><span style=color:#4e4e4e></span>	} <span style=color:#5f8700>else</span> {
		<span style=color:#4e4e4e>// Fetch over the network and start playing...
</span><span style=color:#4e4e4e></span>		player.RecentlyPlayedList.<span style=color:#0087ff>Set</span>(playlist)
	}
}</code></pre></td></tr></table></div></div><div class="notice info"><p class="first notice-title"></p><p>If you thought that I&rsquo;d show you how we&rsquo;ll actually play a media file or stream
it over the network I am sorry to disappoint. That&rsquo;s a tad out of the scope of
this article. That being said, I am always looking for topic ideas to write on,
although I have a huge list already, so if that&rsquo;s something you&rsquo;d like to read
on drop a comment below.</p></div><p>Let&rsquo;s dissect the <code>Play</code> function:</p><ol><li><p>The <code>player.RecentlyPlayedList</code> struct is of type <code>*RecentlyPlayed</code>. It has
a function <code>Get</code> which will return a <code>bool</code> and a playlist which our player
can then play.</p></li><li><p>If it doesn’t find a cached playlist it will fetch/start streaming the
playlist over the network. Then, it will cache it using the <code>Set</code> function
of the <code>RecentlyPlayedLists</code> struct.</p></li></ol><p>So, what is the behaviour and the internals of these two new methods, <code>Get</code> and
<code>Set</code>?</p><h2 id=getting-a-playlist-from-cache><code>Get</code>ting a <code>Playlist</code> from cache<a hidden class=anchor aria-hidden=true href=#getting-a-playlist-from-cache>#</a></h2><p>To retrieve a <code>Playlist</code> from cache is actually a cheap task, from time
perspective. Our cache is hash table-backed which has a <code>O(1)</code> time complexity
for the access operation. The trick is once we access an item in <code>cache</code> we
also have to move it to the beginning of the <code>lru</code> list.</p><p>In other words, we need to promote it as the most recently used item in the
<code>RecentlyPlayedList</code>. Given that we use a linked list-backed cache, we have
to take our item from the list and move it to the front.</p><p>Let&rsquo;s see how that would work in our context:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (rp *RecentlyPlayed) <span style=color:#0087ff>Get</span>(key <span style=color:#af0000>string</span>) (*Playlist, <span style=color:#af0000>bool</span>) {
	<span style=color:#5f8700>if</span> elem, present := rp.cache[key]; present {
                rp.lru.<span style=color:#0087ff>MoveToFront</span>(elem)
		<span style=color:#5f8700>return</span> elem.Value.(*Playlist), <span style=color:#d75f00>true</span>
	} <span style=color:#5f8700>else</span> {
		<span style=color:#5f8700>return</span> <span style=color:#d75f00>nil</span>, <span style=color:#d75f00>false</span>
	}
}</code></pre></td></tr></table></div></div><p>In case you were expecting some magic here – sorry to disappoint, but this is
pretty simple. Its a three step function:</p><ol><li>Checks if it finds the item in the cache. If not it returns a <code>nil</code>.</li><li>Otherwise, it moves the element to the beginning of the LRU list, and</li><li>It returns the value of the <code>*list.Element</code>, which is the pointer
to the <code>Playlist</code> that our player will play</li></ol><p>That&rsquo;s it, pretty simple.</p><h2 id=hash-table-key-for-a-playlist>Hash table key for a <code>Playlist</code><a hidden class=anchor aria-hidden=true href=#hash-table-key-for-a-playlist>#</a></h2><p>Before we move on to <code>Set</code>, let&rsquo;s quickly discuss the implementation of the
<code>hash</code> function.</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (playlist *Playlist) <span style=color:#0087ff>hash</span>() <span style=color:#af0000>string</span> {
	hash := sha1.<span style=color:#0087ff>New</span>()
	s := fmt.<span style=color:#0087ff>Sprintf</span>(
		<span style=color:#00afaf>&#34;%d-%s-%s-%d&#34;</span>,
		playlist.duration,
		playlist.title,
		playlist.description,
		playlist.publishedAt,
	)
	hash.<span style=color:#0087ff>Write</span>([]<span style=color:#0087ff>byte</span>(s))
	sum := hash.<span style=color:#0087ff>Sum</span>(<span style=color:#d75f00>nil</span>)
	<span style=color:#5f8700>return</span> fmt.<span style=color:#0087ff>Sprintf</span>(<span style=color:#00afaf>&#34;%x&#34;</span>, sum)
}</code></pre></td></tr></table></div></div><p>As you can see, it&rsquo;s a simple one - it&rsquo;s goal is just to generate a
reproducible hash for a <code>Playlist</code>. It basically concatenates the attributes of
the <code>Playlist</code> struct and then applies a <code>SHA1</code> hashing sum on it. As the last
step, it returns the hash in a hexidecimal format.</p><h2 id=setting-a-playlist-to-cache><code>Set</code>ting a <code>Playlist</code> to cache<a hidden class=anchor aria-hidden=true href=#setting-a-playlist-to-cache>#</a></h2><p>Now that we have the <code>hash</code> function out of the way, let&rsquo;s look at the code of
the <code>Set</code> function. After, we can discuss the steps this function takes to add
a <code>Playlist</code> to the cache:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (rp *RecentlyPlayed) <span style=color:#0087ff>Set</span>(playlist *Playlist) {
	key := playlist.<span style=color:#0087ff>hash</span>()
	<span style=color:#5f8700>if</span> elem, present := rp.cache[key]; present {
		rp.lru.<span style=color:#0087ff>MoveToFront</span>(elem)
	} <span style=color:#5f8700>else</span> {
		elem := rp.lru.<span style=color:#0087ff>PushFront</span>(playlist)
		rp.size++
	}
	rp.cache[key] = elem
}</code></pre></td></tr></table></div></div><p>The Set function takes a <code>*Playlist</code> as an argument. It is then hashed using
the <code>hash</code> method that implemented by <code>RecentlyPlayed</code>. It returns a unique key
based on some attributes of the <code>Playlist</code>. The key is then used when the
<code>Playlist</code> is added in the hash table <code>caches</code>.</p><p>But before we add it to the hash table <code>cache</code>, we will check if there&rsquo;s
already a value in the <code>cache</code> hash table with the same <code>key</code>. If so, we will
only move the <code>*Playlist</code> to the front of the <code>lru</code> linked list.</p><p>If not, we push the <code>*Playlist</code> to the front of the <code>lru</code> linked list, as the
most recently used item. This returns a <code>*list.Element</code>, which for its <code>Value</code>
expects an <code>interface{}</code> (which is the Go way to say &ldquo;any type&rdquo;). The
<code>*list.Element</code> will wrap the <code>*Playlist</code> as its <code>Value</code>.</p><p>This means that any time we access the <code>elem.Value</code> we will have to cast it to
its proper type, since <code>*list.Element</code> does not know the type of its <code>Value</code>
(remember, it accepts any type).</p><p>After the playlist is added to the front of the <code>lru</code> list, the <code>Set</code> function
will increment the <code>RecentlyPlayed</code>&rsquo;s <code>size</code> due to the new item added to the
list.</p><p>Finally, the function will cache the <code>*list.Element</code> in the <code>cache</code> hash table</p><ul><li>which we will use to retrieve the playlist with a <code>O(1)</code> time complexity.</li></ul><figure class=imagecaption><img class=caption src=/spotify-recently-played-least-recently-used-cache-golang/empty_cart.png caption alt="Person with empty shopping cart">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=eviction>Eviction<a hidden class=anchor aria-hidden=true href=#eviction>#</a></h2><p>Now that we know how the <code>Get</code> and <code>Set</code> functions work, we need to take one
more thing into consideration. That is Spotify’s limitation of the size of the
recently played screen. It means that once the number of playlists reaches a
threshold, it removes the least recently played playlist. This will make the
room to add a new one to the list.</p><p>This is the eviction algorithm that we have to write for our LRU cache, which
powers the recently played screen. In our implementation we&rsquo;ll call the
function <code>increment</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (rp *RecentlyPlayed) <span style=color:#0087ff>increment</span>(element *list.Element) {
	rp.lru.<span style=color:#0087ff>MoveToFront</span>(element)
	<span style=color:#5f8700>if</span> rp.size == rp.capacity {
		lruItem := rp.lru.<span style=color:#0087ff>Back</span>()
		rp.lru.<span style=color:#0087ff>Remove</span>(lruItem)
		rp.size--
	}
}</code></pre></td></tr></table></div></div><p>Every time we want to increment the usage of a certain <code>*list.Element</code>, the
function will take these two steps:</p><ol><li>Move the accessed element to be beginning of the <code>lru</code> linked list, and</li><li>When the <code>size</code> of the <code>RecentlyPlayed</code> struct has reached its <code>capacity</code>,
remove the last item in the <code>lru</code> linked list</li></ol><p>This function will allow us to handle the eviction of the least recently used
item in the list of playlists. Now, we can revisit our <code>Set</code> and <code>Get</code>
functions and drop this function in:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (rp *RecentlyPlayed) <span style=color:#0087ff>Set</span>(playlist *Playlist) {
	key := playlist.<span style=color:#0087ff>hash</span>()
	<span style=color:#5f8700>if</span> elem, present := rp.cache[key]; present {
		rp.<span style=color:#0087ff>increment</span>(elem) <span style=color:#4e4e4e>// &lt;- the change
</span><span style=color:#4e4e4e></span>	} <span style=color:#5f8700>else</span> {
		elem := rp.lru.<span style=color:#0087ff>PushFront</span>(playlist)
		rp.size++
	}
	rp.cache[key] = elem
}

<span style=color:#0087ff>func</span> (rp *RecentlyPlayed) <span style=color:#0087ff>Get</span>(key <span style=color:#af0000>string</span>) (*Playlist, <span style=color:#af0000>bool</span>) {
	<span style=color:#5f8700>if</span> elem, present := rp.cache[key]; present {
		rp.<span style=color:#0087ff>increment</span>(elem) <span style=color:#4e4e4e>// &lt;- the change
</span><span style=color:#4e4e4e></span>		<span style=color:#5f8700>return</span> elem.Value.(*Playlist), <span style=color:#d75f00>true</span>
	} <span style=color:#5f8700>else</span> {
		<span style=color:#5f8700>return</span> <span style=color:#d75f00>nil</span>, <span style=color:#d75f00>false</span>
	}
}</code></pre></td></tr></table></div></div><p>Now that we have the <code>increment</code> function, we will use it in the <code>Set</code> and
<code>Get</code> functions. By doing this, we will update the list of recently used items
every time we play a <code>Playlist</code>.</p><p>This change will unlock two things for our recently played screen:</p><ol><li>It will change the order of the cached playlists, based on the how recently
the playlists are played</li><li>It will remove any playlists once <code>size</code> exceeds <code>capacity</code></li></ol><h2 id=in-closing>In closing<a hidden class=anchor aria-hidden=true href=#in-closing>#</a></h2><p>Now that we have a Go-powered sketch of Spotify&rsquo;s recently played screen, let&rsquo;s
do a quick recap.</p><p>To shine some light on the shortcomings:</p><ol><li>This is a barebones model - it lacks any mechanisms to stream/download the
playlists via the internet. We agreed that although interesting, this would
be hard to cover in this article.</li><li>The model does not take into account any restarting of the application. This
means if we stop and start the program the cached playlists will be gone.
This is because our implementation does not store the data on disk (only in
memory).</li><li>We do not have any graphical user interface to interact with the application
- only a couple of functions that we can invoke.</li></ol><p>While all the above is a shortcoming of our implementation, it still paints the
picture of how we could write such a program using Go. The combination of a
linked list & a hash table works nice for solving the problem at hand. From
time complexity perspective, it scales well. And, for our tiny scenario, the
hit-to-miss ratio should is optimal.</p><p>If you would like to read more of my rambling about caching algorithms, you can
also read &ldquo;When and Why to use a Least Frequently Used (LFU) cache with an
implementation in Golang&rdquo; <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><section class=subscribe><b>Liked this article?</b>
You can <a href=https://www.buymeacoffee.com/ieftimov>buy me a coffee</a>.
Or simply <a href=/newsletter>subscribe to my
newsletter</a> and get my fresh posts in your inbox. It's short and sweet,
going out monthly to over 1,000 subscribers.</section><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Package that implements a doubly linked list:
<a href=https://golang.org/pkg/container/list/>https://golang.org/pkg/container/list/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Or a bloom filter - good article on the topic:
<a href=https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/>https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Article I published on this very blog:
<a href=https://ieftimov.com/when-why-least-frequently-used-cache-implementation-golang>https://ieftimov.com/when-why-least-frequently-used-cache-implementation-golang</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/caching/>caching</a></li><li><a href=https://ieftimov.com/tags/lru/>lru</a></li><li><a href=https://ieftimov.com/tags/last-recently-used/>last recently used</a></li><li><a href=https://ieftimov.com/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/tell-team-running-late-google-home-google-functions-golang-twilio/><span class=title>« Prev Page</span><br><span>Tell your team you are running late using Google Home, Google Cloud Functions, Golang and Twilio</span></a>
<a class=next href=https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/><span class=title>Next Page »</span><br><span>When and Why to use a Least Frequently Used (LFU) cache with an implementation in Golang</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang on twitter" href="https://twitter.com/intent/tweet/?text=Barebones%20model%20of%20Spotify%27s%20%27Recently%20Played%27%20screen%20using%20a%20Least%20Recently%20Used%20%28LRU%29%20cache%20in%20Golang&url=https%3a%2f%2fieftimov.com%2fpost%2fspotify-recently-played-least-recently-used-cache-golang%2f&hashtags=caching%2clru%2clastrecentlyused%2cgolang"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fspotify-recently-played-least-recently-used-cache-golang%2f&title=Barebones%20model%20of%20Spotify%27s%20%27Recently%20Played%27%20screen%20using%20a%20Least%20Recently%20Used%20%28LRU%29%20cache%20in%20Golang&summary=Barebones%20model%20of%20Spotify%27s%20%27Recently%20Played%27%20screen%20using%20a%20Least%20Recently%20Used%20%28LRU%29%20cache%20in%20Golang&source=https%3a%2f%2fieftimov.com%2fpost%2fspotify-recently-played-least-recently-used-cache-golang%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fspotify-recently-played-least-recently-used-cache-golang%2f&title=Barebones%20model%20of%20Spotify%27s%20%27Recently%20Played%27%20screen%20using%20a%20Least%20Recently%20Used%20%28LRU%29%20cache%20in%20Golang"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fspotify-recently-played-least-recently-used-cache-golang%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang on whatsapp" href="https://api.whatsapp.com/send?text=Barebones%20model%20of%20Spotify%27s%20%27Recently%20Played%27%20screen%20using%20a%20Least%20Recently%20Used%20%28LRU%29%20cache%20in%20Golang%20-%20https%3a%2f%2fieftimov.com%2fpost%2fspotify-recently-played-least-recently-used-cache-golang%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Barebones model of Spotify's 'Recently Played' screen using a Least Recently Used (LRU) cache in Golang on telegram" href="https://telegram.me/share/url?text=Barebones%20model%20of%20Spotify%27s%20%27Recently%20Played%27%20screen%20using%20a%20Least%20Recently%20Used%20%28LRU%29%20cache%20in%20Golang&url=https%3a%2f%2fieftimov.com%2fpost%2fspotify-recently-played-least-recently-used-cache-golang%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>