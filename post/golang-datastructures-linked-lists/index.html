<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data structures in Go: Linked lists | Ilija Eftimov ⚡️</title><meta name=keywords content="linked lists,lists"><meta name=description content="Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.
  This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/golang-datastructures-linked-lists/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Data structures in Go: Linked lists"><meta property="og:description" content="Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.
  This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/golang-datastructures-linked-lists/"><meta property="og:image" content="https://ieftimov.com/cards/golang-datastructures-linked-lists.png"><meta property="article:section" content="posts"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/golang-datastructures-linked-lists.png"><meta name=twitter:title content="Data structures in Go: Linked lists"><meta name=twitter:description content="Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.
  This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Data structures in Go: Linked lists","item":"https://ieftimov.com/post/golang-datastructures-linked-lists/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Data structures in Go: Linked lists","name":"Data structures in Go: Linked lists","description":"Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.\n  This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang.","keywords":["linked lists","lists"],"articleBody":"Data structures and algorithms are the bread and butter of computer science. Although sometimes they appear scary to people, most of them have a simple explanation. Also, when explained well with a problem algorithms can be interesting and fun to learn and apply.\n  This post is aimed at people that are not comfortable with linked lists, or folks that want to see and learn how to build one with Golang. We will see how we can implement them with Go via a (somewhat) practical example, instead of the plain theory and code examples.\nBut first, let’s touch on a bit of theory.\nLinked lists Linked lists are one of the simpler data structures out there. Wikipedia’s article on linked lists states that:\n In computer science, a linked list is a linear collection of data elements, in which linear order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a group of nodes which together represent a sequence. Under the simplest form, each node is composed of data and a reference (in other words, a link) to the next node in the sequence.\n While all this might look like too much or confusing, let’s break it down. A linear data structure is the one where it’s elements form a sequence of some sort. Simple as that. Now, why the physical placement in memory doesn’t matter? Well, when you have arrays the amount of memory the array takes is fixed, in the sense that if you have an array of 5 items, the language will grab only 5 memory addresses in the memory, one after another. Because these addresses create a sequence, the array knows in what memory range its values will be stored and thus the physical placement in-memory of these values create a sequence.\nWith linked lists, it’s a bit different. In the definition you will notice that “each element points to the next”, using “data and a reference (in other words, a link) to the next node”. This means that each node of the linked list stores two things: a value and a reference to the next node in the list. Simple as that.\n  Streams of data Everything that humans perceive around them is some sort of information or rather data that our senses and our minds know how to process and convert it into a useful piece of information. Whether we look, or smell, or touch we process data and find meaning from that data. Or, when we browse our social media networks we always resort to a feed of data, ordered chronologically and with no end in sight.\nSo, how can we use linked lists to model such a news feed? Let’s first quickly take a glance at a simple Tweet for example:\nFor the purposes of our example social network, let’s get inspired by Twitter and create a Post type, that has a body, a publishDate and a link to the next post:\n1 2 3 4 5  type Post struct { body string publishDate int64 // Unix timestamp \tnext *Post // link to the next Post }   Next, how can we model a feed of posts? Well, if we know that feeds consist of posts that are linked to another post, then we can try to create a type like that:\n1 2 3 4  type Feed struct { length int // we'll use it later \tstart *Post }   The Feed struct will have a beginning (or start) which will point to the first Post in the feed and a length property which will store the size of the Feed at any given moment.\nSo, let’s say we want to create a Feed with two posts, the first step is to create an Append function on the Feed type:\n1 2 3 4 5 6 7 8 9 10 11 12  func (f *Feed) Append(newPost *Post) { if f.length == 0 { f.start = newPost } else { currentPost := f.start for currentPost.next != nil { currentPost = currentPost.next } currentPost.next = newPost } f.length++ }   Then we can invoke it, twice:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func main() { f := \u0026Feed{} p1 := Post{ body: \"Lorem ipsum\", } f.Append(\u0026p1) fmt.Printf(\"Length: %v\\n\", f.length) fmt.Printf(\"First: %v\\n\", f.start) p2 := Post{ body: \"Dolor sit amet\", } f.Append(\u0026p2) fmt.Printf(\"Length: %v\\n\", f.length) fmt.Printf(\"First: %v\\n\", f.start) fmt.Printf(\"Second: %v\\n\", f.start.next) }   So, what does this code do? First, the main function - it creates a pointer to a Feed struct, two Post structs with some dummy content and it invokes twice the Append function on the Feed, which results in it having a length of 2. We inspect the two values that the Feed has by accessing the start of the Feed (which is, in fact, a Post) and the next item after the start, which is the second Post.\nWhen we run the program, the output will look something like:\n1 2 3 4 5  Length: 1 First: \u0026{Lorem ipsum 1257894000 } Length: 2 First: \u0026{Lorem ipsum 1257894000 0x10444280} Second: \u0026{Dolor sit amet 1257894000 }   You can see, after we add the first Post to the Feed, the length is 1 and the first Post has a body and a publishte (as a Unix timestamp), while it’s next value is nil (because there’s no more Posts in the Feed). Then, we add the second Post to the Feed and when we inspect the two Posts we see that the first one has the same content as before, but with a pointer to the next Post in the list. The second also has a body and a publishDate but with no pointer to the next Post in the list. Also, the length of the Feed increases as we add more Posts to it.\nLet’s go back to the Append function now and deconstruct it so we understand better how to work with linked lists. First, the function creates a pointer to a Post value, with the body argument as body of the Post and the publishDate is set to the Unix timestamp representation of the current time.\nThen, we check if the length of the Feed is 0 - this means that it has no Posts and the first one that is added should be set as the starting Post, conveniently named start.\nBut, if the length of the Feed is more than 0, then our algorithm takes a different turn. It will start with the start of the Feed and it will walk through all the Posts until it finds one that doesn’t have a pointer to a next one. Then, it will attach the new Post as the next value on the last Post of the list.\n  Optimising Append Imagine we have a user that scrolls through their Feed, like on any other social network. Since posts are chronologically ordered, based on the publishDate, the Feed will grow more and more as the user scrolls through it and more Posts are attached to the Feed. Given the approach, we took in the Append function, as the Feed gets longer and longer the Append function will become more and more expensive. Why? Because we have to traverse the whole Feed to add a Post at the end of it. If you have heard about Big-O notation, this algorithm has an O(n) time complexity, which means that it will always traverse the whole Feed before it adds a Post to it.\nAs you can imagine, this can be quite inefficient, especially if the Feed grows to be quite long. How can we improve the Append function and decrease the asymptotic complexity of it?\nSee, since our Feed data structure is just a list of Posts, to traverse it we have to know the beginning of the list (called start) that’s a pointer of type Post. Because in our example Append always adds a Post to the end of the Feed, we could drastically improve the performance of the algorithm if Feed knows not just of its starting element, but also about it’s ending element. Of course, there’s always a tradeoff with optimisations, and the tradeoff here is that the data structure will consume a bit more memory (for the new attribute on the Feed structure).\nExtending our Feed data structure is quite easy:\n1 2 3 4 5  type Feed struct { length int start *Post end *Post }   But our Append algorithm will have to be tweaked to work with the new structure of a Feed. This is the version of Append using the end attribute of Post:\n1 2 3 4 5 6 7 8 9 10 11  func (f *Feed) Append(newPost *Post) { if f.length == 0 { f.start = newPost f.end = newPost } else { lastPost := f.end lastPost.next = newPost f.end = newPost } f.length++ }   That looks a bit simpler, doesn’t it? Let me give you some good news:\n The code is simpler and shorter now, and We drastically improved the time complexity of the function  If you look now at the algorithm, it does two things: if the Feed is empty it will set the new Post as the beginning and the end of the Feed, otherwise it will set the new Post as the end item and it will attach it to the previous Post in the list. On top of how simple it is, this will algorithm now has a big-O complexity of O(1), also known as “constant time”. That means that Append will perform the same regardless of the length of the Feed structure.\nPretty simple, right? But let’s imagine that the Feed is actually a list of Posts on our profile. Hence they are ours, we should be able to delete them. I mean, what kind of a social network doesn’t allow it’s users to (at least) delete their posts?\n  Removing a Post As we established in the previous section, we want the users of our Feeds to be able to delete their posts. So, how can we model that? If our Feeds were an array, we would just remove the item and be done with it, right?\nWell, this is actually where linked lists shine. When arrays sizes change, the runtime has to capture a new memory block to store the items of the array in. Linked lists due to their design, each item having a pointer to the next node in the list, can be scattered throughout the memory space meaning adding/removing nodes from the list is cheap from a space perspective. When one wants to remove a node from a linked list only the neighbours of the removed node need to be linked, and that is. Garbage collected languages (like Go) make this even easier since we don’t have to worry about releasing the allocated memory - the GC will kick in and remove all unused objects.\nTo make our lives a bit easier for this example, let’s put a constraint that each of the Posts on a Feedwill have a unique publishDate.This means a publisher can create one Post per second on their Feed. Taking that into effect, this is how we can easily remove a Post from a Feed:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func (f *Feed) Remove(publishDate int64) { if f.length == 0 { panic(errors.New(\"Feed is empty\")) } var previousPost *Post currentPost := f.start for currentPost.publishDate != publishDate { if currentPost.next == nil { panic(errors.New(\"No such Post found.\")) } previousPost = currentPost currentPost = currentPost.next } previousPost.next = currentPost.next f.length-- }   The Remove function will take a publishDate of a Post as an argument by which it will detect what Post needs to be deleted (or unlinked). The function is rather small. If it detects that the start item of the Feed is to be removed it will just reassign the start of the Feed with the second Post in the Feed. Otherwise, it jumps through each of the Posts in the Feed until it runs into a Post that has a matching publishDate to the one passed as the function argument. When it finds one, it will just connect the previous and the next Post in the Feed with each other, effectively dropping the middle (matching) one from the Feed.\nThere’s one edge case that we need to make sure that we cover in our Remove function - what if the Feed doesn’t have a Post with the specified publishDate? To keep it simple, the function checks for the absence of the next Post in the Feed before it jumps to it. If the next is nil the function panics, telling us that it couldn’t find a Post with such publishDate.\n  Inserting a Post Now that we got appending and removing out of the way, let’s take a look at (a bit of) a hypothetical case. Imagine that the source that produces the Posts sends them to our application in a non-chronological order. This means that the Posts need to be put in the correct order in the Feed, based on the publishDate. This is how that would look like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func (f *Feed) Insert(newPost *Post) { if f.length == 0 { f.start = newPost } else { var previousPost *Post currentPost := f.start for currentPost.publishDate    In essence, this is a very similar algorithm to the one in the Remove function, because although both of them do a very different thing (adding v.s. removing a Post in the Feed), they are both based on a search algorithm. That means that both of the functions actually traverse the whole Feed, searching for a Post that matches the publishDate with the one received in the argument of the function. The only difference is that Insert will actually put the new Post in the place where the dates match, while Remove will remove the Post from the Feed.\nAdditionally, this means that both of these functions carry the same time complexity, which is O(n). This means that in a worst-case scenario, the functions will have to traverse the whole Feed to get to the item where the new post needs to be inserted (or the removed).\nWhat if we used arrays? If you are asking that yourself, let me say right up front - you have a point. True, we could store all of the Posts in an array (or a slice in Go), easily push items onto it and also even have random access with an O(1) complexity.\nDue to the nature of arrays, whose values have to be stored in memory one right after another, reading is really fast and cheap. Once you have something stored in an array, retrieving it as easy as accessing it by its 0-based index. When it comes to inserting an item, whether in the middle or at the end, then arrays become less efficient compared to lists. That is because if the array doesn’t have more memory reserved for the new item(s), it will have to reserve it and use it. But, if the next memory addresses are not free, it will have to “move” to a new memory address where there would be space for all of the items in it (new and old).\nLooking at all of the examples and discussion we had so far, we can create a table with time complexity for each of the algorithms we created, and compare them with the same algorithms for arrays:\n1 2 3 4 5 6 7 8 9  ╔═══════════╦═════════╦═════════════╗ ║ Action ║ Array ║ Linked list ║ ╠═══════════╬═════════╬═════════════╣ ║ Access ║ O(1) ║ O(n) ║ ║ Search ║ O(n) ║ O(n) ║ ║ Prepend ║ O(1) ║ O(1) ║ ║ Append ║ O(n) ║ O(1) ║ ║ Delete ║ O(n) ║ O(n) ║ ╚═══════════╩═════════╩═════════════╝   As you can see, when you are faced with a certain problem, picking the correct data structure can really make or break the products you create. For ever-growing Feeds, where insertion of Posts is paramount, linked lists do a much better job because insertions are really cheap. But, if we had a different problem on our hands that requires frequent deletions or lots of retrieval/searching, then we would have to pick the correct data structure for the problem we are dealing with.\nYou can see the whole implementation of the Feed and play with it here. Also, Go has it’s own linked list implementation, with some nice functions already built in. You can see it’s documentation here.\nEDIT 20.02.2018 10:00 CET: Previous verion of the article wrongly stated that the big-O complexity of the delete function is O(1). Changed to O(n) after pointed out by Bart de Goede.\nEDIT 22.02.2018 23:00 CET: Previous verion of the article wrongly stated that the big-O complexity of searching in an array is O(1) instead of O(N). This was a mixup of Access and Search on my side. This is fixed by adding separate rows in the table for Search and Access and their respective time complexities.\nEDIT 25.02.2018 17:00 CET: Previous version of the article had a buggy implementation of the Insert function, which was pointed out by Albert Shirima in the comments.\n Liked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to +1000 of other engineers.  I care about your privacy, and will never send you spam. You can unsubscribe at any time.\n ","wordCount":"2962","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/golang-datastructures-linked-lists/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Data structures in Go: Linked lists</h1><div class=post-meta>February 18, 2018&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#linked-lists aria-label="Linked lists">Linked lists</a></li><li><a href=#streams-of-data aria-label="Streams of data">Streams of data</a><ul><li><a href=#optimising-append aria-label="Optimising Append">Optimising <code>Append</code></a></li></ul></li><li><a href=#removing-a-post aria-label="Removing a Post">Removing a <code>Post</code></a></li><li><a href=#inserting-a-post aria-label="Inserting a Post">Inserting a <code>Post</code></a></li><li><a href=#what-if-we-used-arrays aria-label="What if we used arrays?">What if we used arrays?</a></li></ul></div></details></div><div class=post-content><p>Data structures and algorithms are the bread and butter of computer science.
Although sometimes they appear scary to people, most of them have a simple
explanation. Also, when explained well with a problem algorithms can be
interesting and fun to learn and apply.</p><figure class=imagecaption><img class=caption src=/golang-datastructures-linked-lists/selection.png caption alt="List of items">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>This post is aimed at people that are not comfortable with linked lists, or
folks that want to see and learn how to build one with Golang. We will see how
we can implement them with Go via a (somewhat) practical example, instead of
the plain theory and code examples.</p><p>But first, let&rsquo;s touch on a bit of theory.</p><h2 id=linked-lists>Linked lists<a hidden class=anchor aria-hidden=true href=#linked-lists>#</a></h2><p>Linked lists are one of the simpler data structures out there. Wikipedia&rsquo;s
article on linked lists states that:</p><blockquote><p>In computer science, a linked list is a linear collection of data elements,
in which linear order is not given by their physical placement in memory.
Instead, each element points to the next. It is a data structure consisting
of a group of nodes which together represent a sequence. Under the simplest
form, each node is composed of data and a reference (in other words, a link)
to the next node in the sequence.</p></blockquote><p>While all this might look like too much or confusing, let&rsquo;s break it down. A
linear data structure is the one where it&rsquo;s elements form a sequence of some
sort. Simple as that. Now, why the physical placement in memory doesn&rsquo;t matter?
Well, when you have arrays the amount of memory the array takes is fixed, in
the sense that if you have an array of 5 items, the language will grab only 5
memory addresses in the memory, one after another. Because these addresses
create a sequence, the array knows in what memory range its values will be
stored and thus the physical placement in-memory of these values create a
sequence.</p><p>With linked lists, it&rsquo;s a bit different. In the definition you will notice that
&ldquo;each element points to the next&rdquo;, using &ldquo;data and a reference (in other words,
a link) to the next node&rdquo;. This means that each node of the linked list stores
two things: a value and a reference to the next node in the list. Simple as
that.</p><figure class=imagecaption><img class=caption src=/golang-datastructures-linked-lists/task.png caption alt="Task list">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=streams-of-data>Streams of data<a hidden class=anchor aria-hidden=true href=#streams-of-data>#</a></h2><p>Everything that humans perceive around them is some sort of information or
rather data that our senses and our minds know how to process and convert it
into a useful piece of information. Whether we look, or smell, or touch we
process data and find meaning from that data. Or, when we browse our social
media networks we always resort to a feed of data, ordered chronologically and
with <em>no end in sight</em>.</p><p>So, how can we use linked lists to model such a news feed? Let&rsquo;s first quickly
take a glance at a simple Tweet for example:</p><p>For the purposes of our example social network, let&rsquo;s get inspired by Twitter
and create a <code>Post</code> type, that has a <code>body</code>, a <code>publishDate</code> and a link to the
<code>next</code> post:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> Post <span style=color:#0087ff>struct</span> {
	body         <span style=color:#af0000>string</span>
	publishDate <span style=color:#af0000>int64</span> <span style=color:#4e4e4e>// Unix timestamp
</span><span style=color:#4e4e4e></span>	next *Post <span style=color:#4e4e4e>// link to the next Post
</span><span style=color:#4e4e4e></span>}</code></pre></td></tr></table></div></div><p>Next, how can we model a feed of posts? Well, if we know that feeds consist of
posts that are linked to another post, then we can try to create a type like
that:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> Feed <span style=color:#0087ff>struct</span> {
	length <span style=color:#af0000>int</span> <span style=color:#4e4e4e>// we&#39;ll use it later
</span><span style=color:#4e4e4e></span>	start  *Post
}</code></pre></td></tr></table></div></div><p>The <code>Feed</code> struct will have a beginning (or <code>start</code>) which will point to the
first <code>Post</code> in the feed and a <code>length</code> property which will store the size of
the <code>Feed</code> at any given moment.</p><p>So, let&rsquo;s say we want to create a <code>Feed</code> with two posts, the first step is to
create an <code>Append</code> function on the <code>Feed</code> type:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (f *Feed) <span style=color:#0087ff>Append</span>(newPost *Post) {
	<span style=color:#5f8700>if</span> f.length == <span style=color:#00afaf>0</span> {
		f.start = newPost
	} <span style=color:#5f8700>else</span> {
		currentPost := f.start
		<span style=color:#5f8700>for</span> currentPost.next != <span style=color:#d75f00>nil</span> {
			currentPost = currentPost.next
		}
		currentPost.next = newPost
	}
	f.length++
}</code></pre></td></tr></table></div></div><p>Then we can invoke it, twice:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> <span style=color:#0087ff>main</span>() {
        f := &amp;Feed{}
        p1 := Post{
            body: <span style=color:#00afaf>&#34;Lorem ipsum&#34;</span>,
        }
	f.<span style=color:#0087ff>Append</span>(&amp;p1)

	fmt.<span style=color:#0087ff>Printf</span>(<span style=color:#00afaf>&#34;Length: %v\n&#34;</span>, f.length)
	fmt.<span style=color:#0087ff>Printf</span>(<span style=color:#00afaf>&#34;First: %v\n&#34;</span>, f.start)

        p2 := Post{
            body: <span style=color:#00afaf>&#34;Dolor sit amet&#34;</span>,
        }
	f.<span style=color:#0087ff>Append</span>(&amp;p2)

	fmt.<span style=color:#0087ff>Printf</span>(<span style=color:#00afaf>&#34;Length: %v\n&#34;</span>, f.length)
	fmt.<span style=color:#0087ff>Printf</span>(<span style=color:#00afaf>&#34;First: %v\n&#34;</span>, f.start)
	fmt.<span style=color:#0087ff>Printf</span>(<span style=color:#00afaf>&#34;Second: %v\n&#34;</span>, f.start.next)
}</code></pre></td></tr></table></div></div><p>So, what does this code do? First, the <code>main</code> function - it creates a pointer
to a <code>Feed</code> struct, two <code>Post</code> structs with some dummy content and it invokes
twice the <code>Append</code> function on the <code>Feed</code>, which results in it having a length
of 2. We inspect the two values that the <code>Feed</code> has by accessing the <code>start</code>
of the <code>Feed</code> (which is, in fact, a <code>Post</code>) and the <code>next</code> item after the
<code>start</code>, which is the second <code>Post</code>.</p><p>When we run the program, the output will look something like:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Length: 1
First: &amp;{Lorem ipsum 1257894000 &lt;nil&gt;}
Length: 2
First: &amp;{Lorem ipsum 1257894000 0x10444280}
Second: &amp;{Dolor sit amet 1257894000 &lt;nil&gt;}</code></pre></td></tr></table></div></div><p>You can see, after we add the first <code>Post</code> to the <code>Feed</code>, the length is <code>1</code> and
the first <code>Post</code> has a <code>body</code> and a <code>publishte</code> (as a Unix timestamp), while
it&rsquo;s <code>next</code> value is <code>nil</code> (because there&rsquo;s no more <code>Post</code>s in the <code>Feed</code>).
Then, we add the second <code>Post</code> to the <code>Feed</code> and when we inspect the two
<code>Post</code>s we see that the first one has the same content as before, but with a
pointer to the <code>next</code> <code>Post</code> in the list. The second also has a <code>body</code> and a
<code>publishDate</code> but with no pointer to the next <code>Post</code> in the list. Also, the
length of the <code>Feed</code> increases as we add more <code>Post</code>s to it.</p><p>Let&rsquo;s go back to the <code>Append</code> function now and deconstruct it so we understand
better how to work with linked lists. First, the function creates a pointer to
a <code>Post</code> value, with the <code>body</code> argument as <code>body</code> of the <code>Post</code> and the
<code>publishDate</code> is set to the Unix timestamp representation of the current time.</p><p>Then, we check if the <code>length</code> of the <code>Feed</code> is <code>0</code> - this means that it has no
<code>Post</code>s and the first one that is added should be set as the starting <code>Post</code>,
conveniently named <code>start</code>.</p><p>But, if the length of the <code>Feed</code> is more than 0, then our algorithm takes a
different turn. It will start with the <code>start</code> of the <code>Feed</code> and it will walk
through all the <code>Post</code>s until it finds one that doesn&rsquo;t have a pointer to a
<code>next</code> one. Then, it will attach the new <code>Post</code> as the <code>next</code> value on the last
<code>Post</code> of the list.</p><figure class=imagecaption><img class=caption src=/golang-datastructures-linked-lists/add_content.png caption alt="TODO list">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h3 id=optimising-append>Optimising <code>Append</code><a hidden class=anchor aria-hidden=true href=#optimising-append>#</a></h3><p>Imagine we have a user that scrolls through their <code>Feed</code>, like on any other
social network. Since posts are chronologically ordered, based on the
<code>publishDate</code>, the <code>Feed</code> will grow more and more as the user scrolls through
it and more <code>Post</code>s are attached to the <code>Feed</code>. Given the approach, we took in
the <code>Append</code> function, as the <code>Feed</code> gets longer and longer the <code>Append</code>
function will become more and more expensive. Why? Because we have to traverse
the whole <code>Feed</code> to add a <code>Post</code> at the end of it. If you have heard about
<em>Big-O notation</em>, this algorithm has an <code>O(n)</code> time complexity, which means
that it will always traverse the whole <code>Feed</code> before it adds a <code>Post</code> to it.</p><p>As you can imagine, this can be quite inefficient, especially if the <code>Feed</code>
grows to be quite long. How can we improve the <code>Append</code> function and decrease
the <a href=https://en.wikipedia.org/wiki/Asymptotic_computational_complexity>asymptotic
complexity</a>
of it?</p><p>See, since our <code>Feed</code> data structure is just a list of <code>Post</code>s, to traverse it
we have to know the beginning of the list (called <code>start</code>) that&rsquo;s a pointer of
type <code>Post</code>. Because in our example <code>Append</code> always adds a <code>Post</code> to the end of
the <code>Feed</code>, we could drastically improve the performance of the algorithm if
<code>Feed</code> knows not just of its <code>start</code>ing element, but also about it&rsquo;s <code>end</code>ing
element. Of course, there&rsquo;s always a tradeoff with optimisations, and the
tradeoff here is that the data structure will consume a bit more memory (for
the new attribute on the <code>Feed</code> structure).</p><p>Extending our <code>Feed</code> data structure is quite easy:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>type</span> Feed <span style=color:#0087ff>struct</span> {
	length <span style=color:#af0000>int</span>
	start  *Post
	end    *Post
}</code></pre></td></tr></table></div></div><p>But our <code>Append</code> algorithm will have to be tweaked to work with the new
structure of a <code>Feed</code>. This is the version of <code>Append</code> using the <code>end</code>
attribute of <code>Post</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (f *Feed) <span style=color:#0087ff>Append</span>(newPost *Post) {
	<span style=color:#5f8700>if</span> f.length == <span style=color:#00afaf>0</span> {
		f.start = newPost
		f.end = newPost
	} <span style=color:#5f8700>else</span> {
		lastPost := f.end
		lastPost.next = newPost
		f.end = newPost
	}
	f.length++
}</code></pre></td></tr></table></div></div><p>That looks a bit simpler, doesn&rsquo;t it? Let me give you some good news:</p><ol><li>The code is simpler and shorter now, and</li><li>We drastically improved the time complexity of the function</li></ol><p>If you look now at the algorithm, it does two things: if the <code>Feed</code> is empty it
will set the new <code>Post</code> as the beginning and the end of the <code>Feed</code>, otherwise
it will set the new <code>Post</code> as the <code>end</code> item and it will attach it to the
previous <code>Post</code> in the list. On top of how simple it is, this will algorithm
now has a big-O complexity of <code>O(1)</code>, also known as &ldquo;constant time&rdquo;. That means
that <code>Append</code> will perform the same regardless of the length of the <code>Feed</code>
structure.</p><p>Pretty simple, right? But let&rsquo;s imagine that the <code>Feed</code> is actually a list of
<code>Post</code>s on our profile. Hence they are ours, we should be able to delete them.
I mean, what kind of a social network doesn&rsquo;t allow it&rsquo;s users to (at least)
delete their posts?</p><figure class=imagecaption><img class=caption src=/golang-datastructures-linked-lists/throw_down.png caption alt="Throwing down graphic">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=removing-a-post>Removing a <code>Post</code><a hidden class=anchor aria-hidden=true href=#removing-a-post>#</a></h2><p>As we established in the previous section, we want the users of our <code>Feed</code>s to
be able to delete their posts. So, how can we model that? If our <code>Feed</code>s were
an array, we would just remove the item and be done with it, right?</p><p>Well, this is actually where linked lists shine. When arrays sizes change, the
runtime has to capture a new memory block to store the items of the array in.
Linked lists due to their design, each item having a pointer to the next node
in the list, can be scattered throughout the memory space meaning
adding/removing nodes from the list is cheap from a space perspective. When one
wants to remove a node from a linked list only the neighbours of the removed
node need to be linked, and that is. Garbage collected languages (like Go) make
this even easier since we don&rsquo;t have to worry about releasing the allocated
memory - the GC will kick in and remove all unused objects.</p><p>To make our lives a bit easier for this example, let&rsquo;s put a constraint that
each of the <code>Posts</code> on a <code>Feed</code>will have a unique <code>publishDate</code>.This means a
publisher can create one <code>Post</code> per second on their <code>Feed</code>. Taking that into
effect, this is how we can easily remove a <code>Post</code> from a <code>Feed</code>:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (f *Feed) <span style=color:#0087ff>Remove</span>(publishDate <span style=color:#af0000>int64</span>) {
	<span style=color:#5f8700>if</span> f.length == <span style=color:#00afaf>0</span> {
		<span style=color:#0087ff>panic</span>(errors.<span style=color:#0087ff>New</span>(<span style=color:#00afaf>&#34;Feed is empty&#34;</span>))
	}

	<span style=color:#0087ff>var</span> previousPost *Post
	currentPost := f.start

	<span style=color:#5f8700>for</span> currentPost.publishDate != publishDate {
		<span style=color:#5f8700>if</span> currentPost.next == <span style=color:#d75f00>nil</span> {
			<span style=color:#0087ff>panic</span>(errors.<span style=color:#0087ff>New</span>(<span style=color:#00afaf>&#34;No such Post found.&#34;</span>))
		}

		previousPost = currentPost
		currentPost = currentPost.next
	}
	previousPost.next = currentPost.next

	f.length--
}</code></pre></td></tr></table></div></div><p>The <code>Remove</code> function will take a <code>publishDate</code> of a <code>Post</code> as an argument by
which it will detect what <code>Post</code> needs to be deleted (or unlinked). The
function is rather small. If it detects that the <code>start</code> item of the <code>Feed</code> is
to be removed it will just reassign the <code>start</code> of the <code>Feed</code> with the second
<code>Post</code> in the <code>Feed</code>. Otherwise, it jumps through each of the <code>Post</code>s in the
<code>Feed</code> until it runs into a <code>Post</code> that has a matching <code>publishDate</code> to the one
passed as the function argument. When it finds one, it will just connect the
previous and the next <code>Post</code> in the <code>Feed</code> with each other, effectively
dropping the middle (matching) one from the <code>Feed</code>.</p><p>There&rsquo;s one edge case that we need to make sure that we cover in our <code>Remove</code>
function - what if the <code>Feed</code> doesn&rsquo;t have a <code>Post</code> with the specified
<code>publishDate</code>? To keep it simple, the function checks for the absence of the
<code>next</code> <code>Post</code> in the <code>Feed</code> before it jumps to it. If the <code>next</code> is <code>nil</code> the
function <code>panic</code>s, telling us that it couldn&rsquo;t find a <code>Post</code> with such
<code>publishDate</code>.</p><figure class=imagecaption><img class=caption src=/golang-datastructures-linked-lists/wall_post.png caption alt="Social media wall">
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><h2 id=inserting-a-post>Inserting a <code>Post</code><a hidden class=anchor aria-hidden=true href=#inserting-a-post>#</a></h2><p>Now that we got appending and removing out of the way, let&rsquo;s take a look at (a
bit of) a hypothetical case. Imagine that the source that produces the <code>Post</code>s
sends them to our application in a non-chronological order. This means that the
<code>Post</code>s need to be put in the correct order in the <code>Feed</code>, based on the
<code>publishDate</code>. This is how that would look like:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#0087ff>func</span> (f *Feed) <span style=color:#0087ff>Insert</span>(newPost *Post) {
	<span style=color:#5f8700>if</span> f.length == <span style=color:#00afaf>0</span> {
		f.start = newPost
	} <span style=color:#5f8700>else</span> {
		<span style=color:#0087ff>var</span> previousPost *Post
		currentPost := f.start

		<span style=color:#5f8700>for</span> currentPost.publishDate &lt; newPost.publishDate {
			previousPost = currentPost
			currentPost = previousPost.next
		}

		previousPost.next = newPost
		newPost.next = currentPost
	}
	f.length++
}</code></pre></td></tr></table></div></div><p>In essence, this is a very similar algorithm to the one in the <code>Remove</code>
function, because although both of them do a very different thing (adding v.s.
removing a <code>Post</code> in the <code>Feed</code>), they are both based on a <em>search</em> algorithm.
That means that both of the functions actually traverse the whole <code>Feed</code>,
<em>searching</em> for a <code>Post</code> that matches the <code>publishDate</code> with the one received
in the argument of the function. The only difference is that <code>Insert</code> will
actually put the new <code>Post</code> in the place where the dates match, while <code>Remove</code>
will remove the <code>Post</code> from the <code>Feed</code>.</p><p>Additionally, this means that both of these functions carry the same time
complexity, which is <code>O(n)</code>. This means that in a worst-case scenario, the
functions will have to traverse the whole <code>Feed</code> to get to the item where the
new post needs to be inserted (or the removed).</p><h2 id=what-if-we-used-arrays>What if we used arrays?<a hidden class=anchor aria-hidden=true href=#what-if-we-used-arrays>#</a></h2><p>If you are asking that yourself, let me say right up front - you have a point.
True, we could store all of the <code>Post</code>s in an array (or a slice in Go), easily
push items onto it and also even have random access with an <code>O(1)</code> complexity.</p><p>Due to the nature of arrays, whose values have to be stored in memory one right
after another, reading is really fast and cheap. Once you have something stored
in an array, retrieving it as easy as accessing it by its 0-based index. When
it comes to inserting an item, whether in the middle or at the end, then arrays
become less efficient compared to lists. That is because if the array doesn&rsquo;t
have more memory reserved for the new item(s), it will have to reserve it and
use it. But, if the next memory addresses are not free, it will have to &ldquo;move&rdquo;
to a new memory address where there would be space for all of the items in it
(new and old).</p><p>Looking at all of the examples and discussion we had so far, we can create a
table with time complexity for each of the algorithms we created, and compare
them with the same algorithms for arrays:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>╔═══════════╦═════════╦═════════════╗
║ Action    ║ Array   ║ Linked list ║
╠═══════════╬═════════╬═════════════╣
║ Access    ║ O(1)    ║ O(n)        ║
║ Search    ║ O(n)    ║ O(n)        ║
║ Prepend   ║ O(1)    ║ O(1)        ║
║ Append    ║ O(n)    ║ O(1)        ║
║ Delete    ║ O(n)    ║ O(n)        ║
╚═══════════╩═════════╩═════════════╝</code></pre></td></tr></table></div></div><p>As you can see, when you are faced with a certain problem, picking the correct
data structure can really make or break the products you create. For
ever-growing <code>Feed</code>s, where insertion of <code>Post</code>s is paramount, linked lists do
a much better job because insertions are really cheap. But, if we had a
different problem on our hands that requires frequent deletions or lots of
retrieval/searching, then we would have to pick the correct data structure for
the problem we are dealing with.</p><p>You can see the whole implementation of the <code>Feed</code> and play with it
<a href=https://play.golang.org/p/fqLPjf_ekD6>here</a>. Also, Go has it&rsquo;s own linked
list implementation, with some nice functions already built in. You can see
it&rsquo;s documentation <a href=https://golang.org/pkg/container/list/>here</a>.</p><p><em>EDIT</em> 20.02.2018 10:00 CET: Previous verion of the article wrongly stated that
the big-O complexity of the delete function is <code>O(1)</code>. Changed to <code>O(n)</code> after
pointed out by <a href=https://twitter.com/bartdegoede>Bart de Goede</a>.</p><p><em>EDIT</em> 22.02.2018 23:00 CET: Previous verion of the article wrongly stated that
the big-O complexity of searching in an array is <code>O(1)</code> instead of <code>O(N)</code>. This
was a mixup of <em>Access</em> and <em>Search</em> on my side. This is fixed by adding
separate rows in the table for <em>Search</em> and <em>Access</em> and their respective time
complexities.</p><p><em>EDIT</em> 25.02.2018 17:00 CET: Previous version of the article had a buggy
implementation of the <code>Insert</code> function, which was pointed out by Albert
Shirima in the comments.</p><section class=subscribe><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to +1000 of other engineers.</p><script async data-uid=5495dc64a0 src=https://ilija.ck.page/5495dc64a0/index.js></script><p class=privacy>I care about your privacy, and will never send you spam. You can unsubscribe at any time.</p></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/linked-lists/>linked lists</a></li><li><a href=https://ieftimov.com/tags/lists/>lists</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/golang-datastructures-stacks-queues/><span class=title>« Prev Page</span><br><span>Data structures in Go: Stacks and queues</span></a>
<a class=next href=https://ieftimov.com/post/create-manage-macos-launchd-agents-golang/><span class=title>Next Page »</span><br><span>Create and manage MacOS LaunchAgents using Go</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Data structures in Go: Linked lists on twitter" href="https://twitter.com/intent/tweet/?text=Data%20structures%20in%20Go%3a%20Linked%20lists&url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-linked-lists%2f&hashtags=linkedlists%2clists"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data structures in Go: Linked lists on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-linked-lists%2f&title=Data%20structures%20in%20Go%3a%20Linked%20lists&summary=Data%20structures%20in%20Go%3a%20Linked%20lists&source=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-linked-lists%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data structures in Go: Linked lists on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-linked-lists%2f&title=Data%20structures%20in%20Go%3a%20Linked%20lists"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data structures in Go: Linked lists on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-linked-lists%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data structures in Go: Linked lists on whatsapp" href="https://api.whatsapp.com/send?text=Data%20structures%20in%20Go%3a%20Linked%20lists%20-%20https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-linked-lists%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Data structures in Go: Linked lists on telegram" href="https://telegram.me/share/url?text=Data%20structures%20in%20Go%3a%20Linked%20lists&url=https%3a%2f%2fieftimov.com%2fpost%2fgolang-datastructures-linked-lists%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>