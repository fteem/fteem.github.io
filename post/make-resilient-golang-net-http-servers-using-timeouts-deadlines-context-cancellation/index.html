<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Make resilient Go net/http servers using timeouts, deadlines and context cancellation | Ilija Eftimov ⚡️</title><meta name=keywords content><meta name=description content="When it comes to timeouts, there are two types of people: those who know how tricky they can be, and those who are yet to find out.
As tricky as they are, timeouts are a reality in the connected world we live in. As I am writing this, on the other side of the table, two persons are typing on their smartphones, probably chatting to people very far from them. All made possible because of networks."><meta name=author content="Ilija Eftimov"><link rel=canonical href=https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Make resilient Go net/http servers using timeouts, deadlines and context cancellation"><meta property="og:description" content="When it comes to timeouts, there are two types of people: those who know how tricky they can be, and those who are yet to find out.
As tricky as they are, timeouts are a reality in the connected world we live in. As I am writing this, on the other side of the table, two persons are typing on their smartphones, probably chatting to people very far from them. All made possible because of networks."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/"><meta property="og:image" content="https://ieftimov.com/cards/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-05T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-05T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ieftimov.com/cards/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation.png"><meta name=twitter:title content="Make resilient Go net/http servers using timeouts, deadlines and context cancellation"><meta name=twitter:description content="When it comes to timeouts, there are two types of people: those who know how tricky they can be, and those who are yet to find out.
As tricky as they are, timeouts are a reality in the connected world we live in. As I am writing this, on the other side of the table, two persons are typing on their smartphones, probably chatting to people very far from them. All made possible because of networks."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Make resilient Go net/http servers using timeouts, deadlines and context cancellation","item":"https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Make resilient Go net/http servers using timeouts, deadlines and context cancellation","name":"Make resilient Go net\/http servers using timeouts, deadlines and context cancellation","description":"When it comes to timeouts, there are two types of people: those who know how tricky they can be, and those who are yet to find out.\nAs tricky as they are, timeouts are a reality in the connected world we live in. As I am writing this, on the other side of the table, two persons are typing on their smartphones, probably chatting to people very far from them. All made possible because of networks.","keywords":[],"articleBody":"When it comes to timeouts, there are two types of people: those who know how tricky they can be, and those who are yet to find out.\nAs tricky as they are, timeouts are a reality in the connected world we live in. As I am writing this, on the other side of the table, two persons are typing on their smartphones, probably chatting to people very far from them. All made possible because of networks.\nNetworks and all their intricacies are here to stay, and we, who write servers for the web, have to know how to use them efficiently and guard against their deficiencies.\nWithout further ado, let’s look at timeouts and how they affect our net/http servers.\nServer timeouts - first principles In web programming, the general classification of timeouts is client and server timeouts. What inspired me to dive into this topic was an interesting server timeout problem I found myself in. That’s why, in this article, we will focus on server-side timeouts.\nTo get the basic terminology out of the way: timeout is a time interval (or limit) in which a specific action must complete. If the operation does not complete in the given time limit, a timeout occurs, and the operation is canceled.\nInitializing a net/http server in Golang reveals a few basic timeout configurations:\nsrv := \u0026http.Server{ ReadTimeout: 1 * time.Second, WriteTimeout: 1 * time.Second, IdleTimeout: 30 * time.Second, ReadHeaderTimeout: 2 * time.Second, TLSConfig: tlsConfig, Handler: srvMux, } This server of http.Server type can be initialized with four different timeouts:\n ReadTimeout: the maximum duration for reading the entire request, including the body WriteTimeout: the maximum duration before timing out writes of the response IdleTimetout: the maximum amount of time to wait for the next request when keep-alive is enabled ReadHeaderTimeout: the amount of time allowed to read request headers  A graphical representation of the above timeouts:\n  Before you start thinking that these are all the timeouts you need, tread carefully! There’s more than meets the eye here. These timeout values provide much more fine-grained control, and they are not going to help us to timeout our long-running HTTP handlers.\nLet me explain.\nTimeouts and deadlines If we look at the source of net/http, in particular, the conn type, we will notice that it uses net.Conn connection under the hood which represents the underlying network connection:\n// Taken from: https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L247 // A conn represents the server-side of an HTTP connection. type conn struct { // server is the server on which the connection arrived.  // Immutable; never nil.  server *Server // * Snipped *  // rwc is the underlying network connection.  // This is never wrapped by other types and is the value given out  // to CloseNotifier callers. It is usually of type *net.TCPConn or  // *tls.Conn.  rwc net.Conn // * Snipped * } In other words, it’s the actual TCP connection that our HTTP request travels on. From a type perspective, it’s a *net.TCPConn or *tls.Conn if it’s a TLS connection.\nThe serve function, calls the readRequest function for each incoming request. readRequest uses the timeout values that we set on the server to set deadlines on the TCP connection:\n// Taken from: https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L936 // Read next request from connection. func (c *conn) readRequest(ctx context.Context) (w *response, err error) { // *Snipped*  t0 := time.Now() if d := c.server.readHeaderTimeout(); d != 0 { hdrDeadline = t0.Add(d) } if d := c.server.ReadTimeout; d != 0 { wholeReqDeadline = t0.Add(d) } c.rwc.SetReadDeadline(hdrDeadline) if d := c.server.WriteTimeout; d != 0 { defer func() { c.rwc.SetWriteDeadline(time.Now().Add(d)) }() } // *Snipped* } From the snippet above, we can conclude that the timeout values set on the server end up as TCP connection deadlines instead of HTTP timeouts.\nSo, what are deadlines then? How do they work? Will they timeout our connection if our request takes too long?\nA simple way to think about deadlines is as a point in time at which restrictions on specific actions on the connection are enforced. For example, if we set a write deadline after the deadline time passes, any write actions on the connection will be forbidden.\nWhile we can create timeout-like behavior using deadlines, we cannot control the time it takes for our handlers to complete. Deadlines operate on the connection, so our server will fail to return a result only after the handlers try to access connection properties (such as writing to http.ResponseWriter).\nTo see this in action, let’s create a tiny handler that takes longer to complete relative to the timeouts we set on the server:\npackage main import ( \"fmt\" \"io\" \"net/http\" \"time\" ) func slowHandler(w http.ResponseWriter, req *http.Request) { time.Sleep(2 * time.Second) io.WriteString(w, \"I am slow!\\n\") } func main() { srv := http.Server{ Addr: \":8888\", WriteTimeout: 1 * time.Second, Handler: http.HandlerFunc(slowHandler), } if err := srv.ListenAndServe(); err != nil { fmt.Printf(\"Server failed: %s\\n\", err) } } The server above has a single handler, which takes 2 seconds to complete. On the other hand, the http.Server has a WriteTimeout set to 1 second. Due to the configuration of the server, we expect the handler to be unable to write the response to the connection.\nWe can start the server using go run server.go. To send a request we can curl localhost:8888:\n$ time curl localhost:8888 curl: (52) Empty reply from server curl localhost:8888 0.01s user 0.01s system 0% cpu 2.021 total The request took 2 seconds to complete, and the response from the server was empty. While our server knows that we cannot write to our response after 1 second, the handler still took 100% more (2 seconds) to complete.\nWhile this is a timeout-like behavior, it would be more useful to stop our server from further execution when it reaches the timeout, ending the request. In our example above, the handler proceeds to process the request until it completes, although it takes 100% longer (2 seconds) than the response write timeout time (1 second).\nThe natural question is, how can we have efficient timeouts for our handlers?\nHandler timeout Our goal is to make sure our slowHandler does not take longer than 1 seconds to complete. If it does take longer, our server should stop its execution and return a proper timeout error.\nIn Go, as with other programming languages, composition is very often the favored approach to writing and designing code. The net/http package of the standard library is one of the places where having compatible components that one can put together with little effort is an obvious design choice.\nIn that light, the net/http packages provide a TimeoutHandler - it returns a handler that runs a handler within the given time limit.\nIts signature is:\nfunc TimeoutHandler(h Handler, dt time.Duration, msg string) Handler It takes a Handler as the first argument, a time.Duration as the second argument (the timeout time) and a string, the message returned when it hits the timeout.\nTo wrap our slowHandler within a TimeoutHandler, all we have to do is:\npackage main import ( \"fmt\" \"io\" \"net/http\" \"time\" ) func slowHandler(w http.ResponseWriter, req *http.Request) { time.Sleep(2 * time.Second) io.WriteString(w, \"I am slow!\\n\") } func main() { srv := http.Server{ Addr: \":8888\", WriteTimeout: 5 * time.Second, Handler: http.TimeoutHandler(http.HandlerFunc(slowHandler), 1*time.Second, \"Timeout!\\n\"), } if err := srv.ListenAndServe(); err != nil { fmt.Printf(\"Server failed: %s\\n\", err) } } The two notable changes are:\n We wrap our slowHanlder in the http.TimetoutHandler, setting the timeout to 1 second and the timeout message to “Timeout!”. We increase the WriteTimeout to 5 seconds, to give the http.TimeoutHandler time to kick in. If we don’t do this when the TimeoutHandler kicks in, the deadline will pass, and it won’t be able to write to the response.  If we started the server again and hit the slow handler we’ll get the following output:\n$ time curl localhost:8888 Timeout! curl localhost:8888 0.01s user 0.01s system 1% cpu 1.023 total After a second, our TimeoutHandler will kick in, stop processing the slowHandler, and return a plain “Timeout!” message. If the message we set is blank, then the handler will return the default timeout response, which is:\nhtml head titleTimeouttitle head body h1Timeouth1 body html Regardless of the output, this is pretty neat, isn’t it? Our application now is protected from long-running handlers and specially crafted requests made to cause very long-running handlers, leading to a potential DoS (Denial of Service) attack.\nIt’s worth noting that although setting timeouts is a great start, it’s still elementary protection. If you’re under threat of an imminent DoS attack, you should look into more advanced protection tools and techniques. (Cloudflare is a good start.)\nOur slowHandler is a simple example-only handler. But, what if our application was much more complicated, making external calls to other services or resources? What if we had an outgoing request to a service such as S3 when our handler would time out?\nWhat would happen then?\nUnhandled timeouts and request cancellations Let’s expand our example a bit:\nfunc slowAPICall() string { d := rand.Intn(5) select { case time.After(time.Duration(d) * time.Second): log.Printf(\"Slow API call done after %s seconds.\\n\", d) return \"foobar\" } } func slowHandler(w http.ResponseWriter, r *http.Request) { result := slowAPICall() io.WriteString(w, result+\"\\n\") } Let’s imagine that initially we didn’t know that our slowHandler took so long to complete because it was sending a request to an API - using the slowAPICall function.\nThe slowAPICall function is straightforward: using select and a time.After it blocks between 0 and 5 seconds. Once that period passes, the time.After method sends a value through its channel and \"foobar\" will be returned.\n(An alternative approach is to use sleep(time.Duration(rand.Intn(5)) * time.Second), but we will stick to select because it will make our life simpler in the next example.)\nIf we run our server, we would expect the timeout handler to cut off the request processing after 1 second. Sending a request proves that:\n$ time curl localhost:8888 Timeout! curl localhost:8888 0.01s user 0.01s system 1% cpu 1.021 total By looking at the server output, we will notice that it prints the loglines after a few seconds instead of when the timeout handler kicks in:\n$ go run server.go 2019/12/29 17:20:03 Slow API call done after 4 seconds. Such behavior suggests that although the request timed out after 1 second, the server proceeded to process the request fully. That’s why it printed the logline after 4 seconds passed.\nWhile this example is trivial and naive, such behavior in production servers can become a rather big problem. For example, imagine if the slowAPICall function spawned hundreds of goroutines, each of them processing some data. Or if it was issuing multiple API calls to various systems. Such long-running processes will eat up resources from your system, while the caller/client won’t ever use their result.\nSo, how can we guard our system from such unoptimized timeouts or request cancellations?\nContext timeouts and cancellation Go comes with a neat package for handling such scenarios called context.\nThe context package was promoted to the standard library as of Go 1.7. Previously it was part of the Go Sub-repository Packages, with the name golang.org/x/net/context\nThe package defines the Context type. It’s primary purpose is to carry deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes. If you would like to learn more about the context package, I recommend reading “Go Concurrency Patterns: Context” on Golang’s blog.\nThe Request type that is part of the net/http package already has a context attached to it. As of Go 1.7, Request has a Context function, which returns the request’s context. For incoming server requests, the server cancels the context when the client’s connection closes, when the request is canceled (in HTTP/2), or when the ServeHTTP method returns.\nThe behavior we are looking for is to stop all further processing on the server-side when the client cancels the request (we hit CTRL + C on our cURL) or the TimeoutHandler steps in after some time and ends the request. That will effectively close all connections and free all other resources taken up by the running handler (and all of its children goroutines).\nLet’s use the request Context to pass it to the slowAPICall function as an argument:\nfunc slowAPICall(ctx context.Context) string { d := rand.Intn(5) select { case time.After(time.Duration(d) * time.Second): log.Printf(\"Slow API call done after %d seconds.\\n\", d) return \"foobar\" } } func slowHandler(w http.ResponseWriter, r *http.Request) { result := slowAPICall(r.Context()) io.WriteString(w, result+\"\\n\") } Now that we utilize the request context, how can we put it in action? The Context type has a Done attribute, which is of type . Done closes when the work done on behalf of the context should be canceled, which is what we need in the example.\nLet’s handle the ctx.Done channel in the select block in the slowAPICall function. When we receive an empty struct via the Done channel, this signifies the context cancellation, and we have to return a zero-value string from the slowAPICall function:\nfunc slowAPICall(ctx context.Context) string { d := rand.Intn(5) select { case ctx.Done(): log.Printf(\"slowAPICall was supposed to take %s seconds, but was canceled.\", d) return \"\" case time.After(time.Duration(d) * time.Second): log.Printf(\"Slow API call done after %d seconds.\\n\", d) return \"foobar\" } } (This is the reason we used a select block, instead of the time.Sleep - we can just handle the Done channel in the select here.)\nIn our limited example, this does the trick – when we receive value through the Done channel, we log a line to STDOUT and return an empty string. In more complicated situations, such as sending real API requests, you might need to close down connections or clean up file descriptors.\nLet’s spin up the server again and send a cURL request:\n# The cURL command: $ curl localhost:8888 Timeout! # The server output: $ go run server.go 2019/12/30 00:07:15 slowAPICall was supposed to take 2 seconds, but was canceled. So check this out: we ran a cURL to the server, it took longer than 1 second, and our server canceled the slowAPICall function. And we didn’t need to write almost any code for it. The TimeoutHandler did this for us - when the handler took longer than expected, the TimeoutHandler stopped the execution of the handler and canceled the request context.\nThe TimeoutHandler performs the context cancellation in the timeoutHandler.ServeHTTP method:\n// Taken from: https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L3217-L3263 func (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request) { ctx := h.testContext if ctx == nil { var cancelCtx context.CancelFunc ctx, cancelCtx = context.WithTimeout(r.Context(), h.dt) defer cancelCtx() } r = r.WithContext(ctx) // *Snipped* } Above, we use the request context by invoking context.WithTimeout on it. The timeout value h.dt, which is the second argument received by the TimeoutHandler, is applied to the context. The returned context is a copy of the request context with a timeout attached. Right after, it’s set as the request’s context using the r.WithContext(ctx) invocation.\nThe context.WithTimeout function makes the context cancellation. It returns a copy of the Context with a timeout set to the duration passed as an argument. Once it reaches the timeout, it cancels the context.\nHere’s the code that does it:\n// Taken from: https://github.com/golang/go/blob/bbbc6589/src/context/context.go#L486-L498 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } // Taken from: https://github.com/golang/go/blob/bbbc6589/src/context/context.go#L418-L450 func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { // *Snipped*  c := \u0026timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } // *Snipped*  if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded) }) } return c, func() { c.cancel(true, Canceled) } } Here we meet deadlines again. The WithDeadline function sets a function that executes after the duration d passes. Once the duration passes, it invokes the cancel method on the context, which will close the done channel of the context and will set the context’s timer attribute to nil.\nThe closing of the Done channel effectively cancels the context, which allows our slowAPICall function to stop its execution. That’s how the TimeoutHandler timeouts long-running handlers.\n(If you would like to read the code that does the above, you should see the cancel functions on the cancelCtx type and the timerCtx type.)\nResilient net/http servers Connection deadlines provide low-level fine-grained control. While their names contain “timeout” they do not have the behavior that folks commonly expect from timeouts. They are in fact very powerful, but they expect the programmer to know how to wield that weapon.\nOn the other hand, when working with HTTP handlers, the TimeoutHandler should be our go-to tool. The design chosen by the Go authors, of having composable handlers, provides flexibility, so much that we could even have different timeouts per handler if we decided to. TimeoutHandler provides execution control while maintaining the behavior that we commonly expect when thinking of timeouts.\nOn top of that, the TimeoutHandler works well with the context package. While the context package is simple, it carries cancellation signals and request-scoped data, that we can use to make our applications adhere better to the intricacies of networks.\nBefore we close, here are three suggestions on how to think of timeouts while writing your HTTP servers:\n Most-often, reach for TimeoutHandler. It does what we commonly expect of timeouts. Never forget context cancellations. The context package is simple to use and can save your servers lots of processing resources. Especially againts bad actors or misbehaving networks. By all means, use deadlines. Just make sure you test thoroughly that they provide you the functionality that you want.  To read more on the topic:\n “The complete guide to Go net/http timeouts” on Cloudflare’s blog “So you want to expose Go on the Internet” on Cloudflare’s blog “Use http.TimeoutHandler or ReadTimeout/WriteTimeout?” on Stackoverflow “Standard net/http config will break your production environment” on Simon Frey’s blog  Liked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to +1000 of other engineers.\n    ","wordCount":"2967","inLanguage":"en","datePublished":"2020-01-05T00:00:00Z","dateModified":"2020-01-05T00:00:00Z","author":{"@type":"Person","name":"Ilija Eftimov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Make resilient Go net/http servers using timeouts, deadlines and context cancellation</h1><div class=post-meta>January 5, 2020&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Ilija Eftimov</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#server-timeouts---first-principles aria-label="Server timeouts - first principles">Server timeouts - first principles</a></li><li><a href=#timeouts-and-deadlines aria-label="Timeouts and deadlines">Timeouts and deadlines</a></li><li><a href=#handler-timeout aria-label="Handler timeout">Handler timeout</a></li><li><a href=#unhandled-timeouts-and-request-cancellations aria-label="Unhandled timeouts and request cancellations">Unhandled timeouts and request cancellations</a></li><li><a href=#context-timeouts-and-cancellation aria-label="Context timeouts and cancellation">Context timeouts and cancellation</a></li><li><a href=#resilient-nethttp-servers aria-label="Resilient net/http servers">Resilient <code>net/http</code> servers</a></li></ul></div></details></div><div class=post-content><p>When it comes to timeouts, there are two types of people: those who know how
tricky they can be, and those who are yet to find out.</p><p>As tricky as they are, timeouts are a reality in the connected world we live
in. As I am writing this, on the other side of the table, two persons are
typing on their smartphones, probably chatting to people very far from them.
All made possible because of networks.</p><p>Networks and all their intricacies are here to stay, and we, who write servers
for the web, have to know how to use them efficiently and guard against their
deficiencies.</p><p>Without further ado, let&rsquo;s look at timeouts and how they affect our <code>net/http</code>
servers.</p><h2 id=server-timeouts---first-principles>Server timeouts - first principles<a hidden class=anchor aria-hidden=true href=#server-timeouts---first-principles>#</a></h2><p>In web programming, the general classification of timeouts is client and server
timeouts. What inspired me to dive into this topic was an interesting server
timeout problem I found myself in. That&rsquo;s why, in this article, we will focus
on server-side timeouts.</p><p>To get the basic terminology out of the way: timeout is a time interval (or
limit) in which a specific action must complete. If the operation does not
complete in the given time limit, a timeout occurs, and the operation is
canceled.</p><p>Initializing a <code>net/http</code> server in Golang reveals a few basic timeout
configurations:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>srv <span style=color:#719e07>:=</span> <span style=color:#719e07>&amp;</span>http.Server{
    ReadTimeout:       <span style=color:#2aa198>1</span> <span style=color:#719e07>*</span> time.Second,
    WriteTimeout:      <span style=color:#2aa198>1</span> <span style=color:#719e07>*</span> time.Second,
    IdleTimeout:       <span style=color:#2aa198>30</span> <span style=color:#719e07>*</span> time.Second,
    ReadHeaderTimeout: <span style=color:#2aa198>2</span> <span style=color:#719e07>*</span> time.Second,
    TLSConfig:         tlsConfig,
    Handler:           srvMux,
}</code></pre></div><p>This server of <code>http.Server</code> type can be initialized with four different
timeouts:</p><ul><li><code>ReadTimeout</code>: the maximum duration for reading the entire request, including
the body</li><li><code>WriteTimeout</code>: the maximum duration before timing out writes of the response</li><li><code>IdleTimetout</code>: the maximum amount of time to wait for the next request when
keep-alive is enabled</li><li><code>ReadHeaderTimeout</code>: the amount of time allowed to read request headers</li></ul><p>A graphical representation of the above timeouts:</p><figure class=imagecaption><img class=caption src=/make-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation/request-lifecycle-timeouts.png caption alt>
<span class=caption-text style="font-size:.75em;display:table;margin:0 auto 1.5em"></span></figure><p>Before you start thinking that these are all the timeouts you need, tread
carefully! There&rsquo;s more than meets the eye here. These timeout values provide
much more fine-grained control, and they are not going to help us to timeout
our long-running HTTP handlers.</p><p>Let me explain.</p><h2 id=timeouts-and-deadlines>Timeouts and deadlines<a hidden class=anchor aria-hidden=true href=#timeouts-and-deadlines>#</a></h2><p>If we look at the source of <code>net/http</code>, in particular, the <a href=https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L248><code>conn</code>
type</a>,
we will notice that it uses <code>net.Conn</code> connection under the hood which
represents the underlying network connection:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// Taken from: https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L247
</span><span style=color:#586e75>// A conn represents the server-side of an HTTP connection.
</span><span style=color:#586e75></span><span style=color:#268bd2>type</span> conn <span style=color:#268bd2>struct</span> {
    <span style=color:#586e75>// server is the server on which the connection arrived.
</span><span style=color:#586e75></span>    <span style=color:#586e75>// Immutable; never nil.
</span><span style=color:#586e75></span>    server <span style=color:#719e07>*</span>Server

    <span style=color:#586e75>// * Snipped *
</span><span style=color:#586e75></span>
    <span style=color:#586e75>// rwc is the underlying network connection.
</span><span style=color:#586e75></span>    <span style=color:#586e75>// This is never wrapped by other types and is the value given out
</span><span style=color:#586e75></span>    <span style=color:#586e75>// to CloseNotifier callers. It is usually of type *net.TCPConn or
</span><span style=color:#586e75></span>    <span style=color:#586e75>// *tls.Conn.
</span><span style=color:#586e75></span>    rwc net.Conn

    <span style=color:#586e75>// * Snipped *
</span><span style=color:#586e75></span>}</code></pre></div><p>In other words, it&rsquo;s the actual TCP connection that our HTTP
request travels on. From a type perspective, it&rsquo;s a <code>*net.TCPConn</code> or
<code>*tls.Conn</code> if it&rsquo;s a TLS connection.</p><p>The <code>serve</code>
<a href=https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L1765>function</a>,
calls the <code>readRequest</code> function <a href=https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L1822>for each incoming
request</a>.
<code>readRequest</code> <a href=https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L946-L958>uses the timeout
values</a>
that we set on the server to <strong>set deadlines on the TCP connection</strong>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// Taken from: https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L936
</span><span style=color:#586e75>// Read next request from connection.
</span><span style=color:#586e75></span><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>conn) <span style=color:#268bd2>readRequest</span>(ctx context.Context) (w <span style=color:#719e07>*</span>response, err <span style=color:#dc322f>error</span>) {
        <span style=color:#586e75>// *Snipped*
</span><span style=color:#586e75></span>
        t0 <span style=color:#719e07>:=</span> time.<span style=color:#268bd2>Now</span>()
        <span style=color:#719e07>if</span> d <span style=color:#719e07>:=</span> c.server.<span style=color:#268bd2>readHeaderTimeout</span>(); d <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span> {
                hdrDeadline = t0.<span style=color:#268bd2>Add</span>(d)
        }
        <span style=color:#719e07>if</span> d <span style=color:#719e07>:=</span> c.server.ReadTimeout; d <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span> {
                wholeReqDeadline = t0.<span style=color:#268bd2>Add</span>(d)
        }
        c.rwc.<span style=color:#268bd2>SetReadDeadline</span>(hdrDeadline)
        <span style=color:#719e07>if</span> d <span style=color:#719e07>:=</span> c.server.WriteTimeout; d <span style=color:#719e07>!=</span> <span style=color:#2aa198>0</span> {
                <span style=color:#719e07>defer</span> <span style=color:#268bd2>func</span>() {
                        c.rwc.<span style=color:#268bd2>SetWriteDeadline</span>(time.<span style=color:#268bd2>Now</span>().<span style=color:#268bd2>Add</span>(d))
                }()
        }

        <span style=color:#586e75>// *Snipped*
</span><span style=color:#586e75></span>}</code></pre></div><p>From the snippet above, we can conclude that the timeout values set on the
server end up as TCP connection deadlines instead of HTTP timeouts.</p><p>So, what are deadlines then? How do they work? Will they timeout our connection
if our request takes too long?</p><p>A simple way to think about deadlines is as a point in time at which
restrictions on specific actions on the connection are enforced. For example,
if we set a write deadline after the deadline time passes, any write actions on
the connection will be forbidden.</p><p>While we can create timeout-like behavior using deadlines, we cannot control
the time it takes for our handlers to complete. Deadlines operate on the
connection, so our server will fail to return a result only after the handlers
try to access connection properties (such as writing to <code>http.ResponseWriter</code>).</p><p>To see this in action, let&rsquo;s create a tiny handler that takes longer to
complete relative to the timeouts we set on the server:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;fmt&#34;</span>
	<span style=color:#2aa198>&#34;io&#34;</span>
	<span style=color:#2aa198>&#34;net/http&#34;</span>
	<span style=color:#2aa198>&#34;time&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>slowHandler</span>(w http.ResponseWriter, req <span style=color:#719e07>*</span>http.Request) {
	time.<span style=color:#268bd2>Sleep</span>(<span style=color:#2aa198>2</span> <span style=color:#719e07>*</span> time.Second)
	io.<span style=color:#268bd2>WriteString</span>(w, <span style=color:#2aa198>&#34;I am slow!\n&#34;</span>)
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	srv <span style=color:#719e07>:=</span> http.Server{
		Addr:         <span style=color:#2aa198>&#34;:8888&#34;</span>,
		WriteTimeout: <span style=color:#2aa198>1</span> <span style=color:#719e07>*</span> time.Second,
		Handler:      http.<span style=color:#268bd2>HandlerFunc</span>(slowHandler),
	}

	<span style=color:#719e07>if</span> err <span style=color:#719e07>:=</span> srv.<span style=color:#268bd2>ListenAndServe</span>(); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
		fmt.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;Server failed: %s\n&#34;</span>, err)
	}
}</code></pre></div><p>The server above has a single handler, which takes 2 seconds to complete. On the
other hand, the <code>http.Server</code> has a <code>WriteTimeout</code> set to 1 second. Due to the
configuration of the server, we expect the handler to be unable to write the
response to the connection.</p><p>We can start the server using <code>go run server.go</code>. To send a request we can
<code>curl localhost:8888</code>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ <span style=color:#b58900>time</span> curl localhost:8888
curl: <span style=color:#719e07>(</span>52<span style=color:#719e07>)</span> Empty reply from server
curl localhost:8888  0.01s user 0.01s system 0% cpu 2.021 total</code></pre></div><p>The request took 2 seconds to complete, and the response from the server was
empty. While our server knows that we cannot write to our response after 1
second, the handler still took 100% more (2 seconds) to complete.</p><p>While this is a timeout-like behavior, it would be more useful to stop our
server from further execution when it reaches the timeout, ending the request.
In our example above, the handler proceeds to process the request until it
completes, although it takes 100% longer (2 seconds) than the response write
timeout time (1 second).</p><p>The natural question is, how can we have efficient timeouts for our handlers?</p><h2 id=handler-timeout>Handler timeout<a hidden class=anchor aria-hidden=true href=#handler-timeout>#</a></h2><p>Our goal is to make sure our <code>slowHandler</code> does not take longer than 1 seconds
to complete. If it does take longer, our server should stop its execution and
return a proper timeout error.</p><p>In Go, as with other programming languages, composition is very often the
favored approach to writing and designing code. The <a href=https://golang.org/pkg/net/http><code>net/http</code>
package</a> of the standard library is one of the
places where having compatible components that one can put together with little
effort is an obvious design choice.</p><p>In that light, the <code>net/http</code> packages provide <a href=https://golang.org/pkg/net/http/#TimeoutHandler>a
<code>TimeoutHandler</code></a> - it returns
a handler that runs a handler within the given time limit.</p><p>Its signature is:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>TimeoutHandler</span>(h Handler, dt time.Duration, msg <span style=color:#dc322f>string</span>) Handler</code></pre></div><p>It takes a <code>Handler</code> as the first argument, a <code>time.Duration</code> as the second
argument (the timeout time) and a <code>string</code>, the message returned when it hits
the timeout.</p><p>To wrap our <code>slowHandler</code> within a <code>TimeoutHandler</code>, all we have to do is:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#719e07>package</span> main

<span style=color:#719e07>import</span> (
	<span style=color:#2aa198>&#34;fmt&#34;</span>
	<span style=color:#2aa198>&#34;io&#34;</span>
	<span style=color:#2aa198>&#34;net/http&#34;</span>
	<span style=color:#2aa198>&#34;time&#34;</span>
)

<span style=color:#268bd2>func</span> <span style=color:#268bd2>slowHandler</span>(w http.ResponseWriter, req <span style=color:#719e07>*</span>http.Request) {
	time.<span style=color:#268bd2>Sleep</span>(<span style=color:#2aa198>2</span> <span style=color:#719e07>*</span> time.Second)
	io.<span style=color:#268bd2>WriteString</span>(w, <span style=color:#2aa198>&#34;I am slow!\n&#34;</span>)
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>main</span>() {
	srv <span style=color:#719e07>:=</span> http.Server{
		Addr:         <span style=color:#2aa198>&#34;:8888&#34;</span>,
		WriteTimeout: <span style=color:#2aa198>5</span> <span style=color:#719e07>*</span> time.Second,
		Handler:      http.<span style=color:#268bd2>TimeoutHandler</span>(http.<span style=color:#268bd2>HandlerFunc</span>(slowHandler), <span style=color:#2aa198>1</span><span style=color:#719e07>*</span>time.Second, <span style=color:#2aa198>&#34;Timeout!\n&#34;</span>),
	}

	<span style=color:#719e07>if</span> err <span style=color:#719e07>:=</span> srv.<span style=color:#268bd2>ListenAndServe</span>(); err <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
		fmt.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;Server failed: %s\n&#34;</span>, err)
	}
}</code></pre></div><p>The two notable changes are:</p><ul><li>We wrap our <code>slowHanlder</code> in the <code>http.TimetoutHandler</code>, setting the timeout
to 1 second and the timeout message to &ldquo;Timeout!&rdquo;.</li><li>We increase the <code>WriteTimeout</code> to 5 seconds, to give the
<code>http.TimeoutHandler</code> time to kick in. If we don&rsquo;t do this when the
<code>TimeoutHandler</code> kicks in, the deadline will pass, and it won&rsquo;t be able to
write to the response.</li></ul><p>If we started the server again and hit the slow handler we&rsquo;ll get the following
output:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ <span style=color:#b58900>time</span> curl localhost:8888
Timeout!
curl localhost:8888  0.01s user 0.01s system 1% cpu 1.023 total</code></pre></div><p>After a second, our <code>TimeoutHandler</code> will kick in, stop processing the
<code>slowHandler</code>, and return a plain &ldquo;<code>Timeout!</code>&rdquo; message. If the message we set
is blank, then the handler will return the default timeout response, which is:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#268bd2>html</span>&gt;
  &lt;<span style=color:#268bd2>head</span>&gt;
    &lt;<span style=color:#268bd2>title</span>&gt;Timeout&lt;/<span style=color:#268bd2>title</span>&gt;
  &lt;/<span style=color:#268bd2>head</span>&gt;
  &lt;<span style=color:#268bd2>body</span>&gt;
   &lt;<span style=color:#268bd2>h1</span>&gt;Timeout&lt;/<span style=color:#268bd2>h1</span>&gt;
  &lt;/<span style=color:#268bd2>body</span>&gt;
&lt;/<span style=color:#268bd2>html</span>&gt;</code></pre></div><p>Regardless of the output, this is pretty neat, isn&rsquo;t it? Our application now is
protected from long-running handlers and specially crafted requests made to
cause very long-running handlers, leading to a potential DoS (Denial of
Service) attack.</p><p>It&rsquo;s worth noting that although setting timeouts is a great start, it&rsquo;s still
elementary protection. If you&rsquo;re under threat of an imminent DoS attack, you
should look into more advanced protection tools and techniques.
(<a href=https://www.cloudflare.com/ddos/>Cloudflare</a> is a good start.)</p><p>Our <code>slowHandler</code> is a simple example-only handler. But, what if our
application was much more complicated, making external calls to other services
or resources? What if we had an outgoing request to a service such as S3 when
our handler would time out?</p><p>What would happen then?</p><h2 id=unhandled-timeouts-and-request-cancellations>Unhandled timeouts and request cancellations<a hidden class=anchor aria-hidden=true href=#unhandled-timeouts-and-request-cancellations>#</a></h2><p>Let&rsquo;s expand our example a bit:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>slowAPICall</span>() <span style=color:#dc322f>string</span> {
	d <span style=color:#719e07>:=</span> rand.<span style=color:#268bd2>Intn</span>(<span style=color:#2aa198>5</span>)
	<span style=color:#719e07>select</span> {
	<span style=color:#719e07>case</span> <span style=color:#719e07>&lt;-</span>time.<span style=color:#268bd2>After</span>(time.<span style=color:#268bd2>Duration</span>(d) <span style=color:#719e07>*</span> time.Second):
		log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;Slow API call done after %s seconds.\n&#34;</span>, d)
		<span style=color:#719e07>return</span> <span style=color:#2aa198>&#34;foobar&#34;</span>
	}
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>slowHandler</span>(w http.ResponseWriter, r <span style=color:#719e07>*</span>http.Request) {
	result <span style=color:#719e07>:=</span> <span style=color:#268bd2>slowAPICall</span>()
	io.<span style=color:#268bd2>WriteString</span>(w, result<span style=color:#719e07>+</span><span style=color:#2aa198>&#34;\n&#34;</span>)
}</code></pre></div><p>Let&rsquo;s imagine that initially we didn&rsquo;t know that our <code>slowHandler</code> took so long
to complete because it was sending a request to an API - using the
<code>slowAPICall</code> function.</p><p>The <code>slowAPICall</code> function is straightforward: using <code>select</code> and a
<code>time.After</code> it blocks between 0 and 5 seconds. Once that period passes, the
<code>time.After</code> method sends a value through its channel and <code>"foobar"</code> will be
returned.</p><p>(An alternative approach is to use <code>sleep(time.Duration(rand.Intn(5)) * time.Second)</code>, but we will stick to <code>select</code> because it will make our life
simpler in the next example.)</p><p>If we run our server, we would expect the timeout handler to cut off the
request processing after 1 second. Sending a request proves that:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ <span style=color:#b58900>time</span> curl localhost:8888
Timeout!
curl localhost:8888  0.01s user 0.01s system 1% cpu 1.021 total</code></pre></div><p>By looking at the server output, we will notice that it prints the loglines
after a few seconds instead of when the timeout handler kicks in:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ go run server.go
2019/12/29 17:20:03 Slow API call <span style=color:#719e07>done</span> after <span style=color:#2aa198>4</span> seconds.</code></pre></div><p>Such behavior suggests that although the request timed out after 1 second, the
server proceeded to process the request fully. That&rsquo;s why it printed the
logline after 4 seconds passed.</p><p>While this example is trivial and naive, such behavior in production servers
can become a rather big problem. For example, imagine if the <code>slowAPICall</code>
function spawned hundreds of goroutines, each of them processing some data. Or
if it was issuing multiple API calls to various systems. Such long-running
processes will eat up resources from your system, while the caller/client won&rsquo;t
ever use their result.</p><p>So, how can we guard our system from such unoptimized timeouts or request
cancellations?</p><h2 id=context-timeouts-and-cancellation>Context timeouts and cancellation<a hidden class=anchor aria-hidden=true href=#context-timeouts-and-cancellation>#</a></h2><p>Go comes with a neat package for handling such scenarios called
<a href=https://golang.org/pkg/context/><code>context</code></a>.</p><p>The <code>context</code> package was promoted to the standard library as of Go 1.7.
Previously it was part of the <a href=https://godoc.org/-/subrepo>Go Sub-repository
Packages</a>, with the name
<a href=https://godoc.org/golang.org/x/net/context><code>golang.org/x/net/context</code></a></p><p>The package defines the <code>Context</code> type. It&rsquo;s primary purpose is to carry
deadlines, cancellation signals, and other request-scoped values across API
boundaries and between processes. If you would like to learn more about the
context package, I recommend reading &ldquo;Go Concurrency Patterns: Context&rdquo; on
<a href=https://blog.golang.org/context>Golang&rsquo;s blog</a>.</p><p>The <code>Request</code> type that is part of the <code>net/http</code> package already has a
<code>context</code> attached to it. As of Go 1.7, <code>Request</code> has <a href=https://golang.org/pkg/net/http/#Request.Context>a <code>Context</code>
function</a>, which returns the
request&rsquo;s context. For incoming server requests, the server cancels the context
when the client&rsquo;s connection closes, when the request is canceled (in HTTP/2),
or when the <code>ServeHTTP</code> method returns.</p><p>The behavior we are looking for is to stop all further processing on the
server-side when the client cancels the request (we hit <code>CTRL + C</code> on our
<code>cURL</code>) or the <code>TimeoutHandler</code> steps in after some time and ends the request.
That will effectively close all connections and free all other resources taken
up by the running handler (and all of its children goroutines).</p><p>Let&rsquo;s use the request Context to pass it to the <code>slowAPICall</code> function as
an argument:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>slowAPICall</span>(ctx context.Context) <span style=color:#dc322f>string</span> {
	d <span style=color:#719e07>:=</span> rand.<span style=color:#268bd2>Intn</span>(<span style=color:#2aa198>5</span>)
	<span style=color:#719e07>select</span> {
	<span style=color:#719e07>case</span> <span style=color:#719e07>&lt;-</span>time.<span style=color:#268bd2>After</span>(time.<span style=color:#268bd2>Duration</span>(d) <span style=color:#719e07>*</span> time.Second):
		log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;Slow API call done after %d seconds.\n&#34;</span>, d)
		<span style=color:#719e07>return</span> <span style=color:#2aa198>&#34;foobar&#34;</span>
	}
}

<span style=color:#268bd2>func</span> <span style=color:#268bd2>slowHandler</span>(w http.ResponseWriter, r <span style=color:#719e07>*</span>http.Request) {
	result <span style=color:#719e07>:=</span> <span style=color:#268bd2>slowAPICall</span>(r.<span style=color:#268bd2>Context</span>())
	io.<span style=color:#268bd2>WriteString</span>(w, result<span style=color:#719e07>+</span><span style=color:#2aa198>&#34;\n&#34;</span>)
}</code></pre></div><p>Now that we utilize the request context, how can we put it in action? <a href=https://golang.org/pkg/context/#Context>The
<code>Context</code> type</a> has a <code>Done</code>
attribute, which is of type <code>&lt;-chan struct{}</code>. <code>Done</code> closes when the work
done on behalf of the context should be canceled, which is what we need in the
example.</p><p>Let&rsquo;s handle the <code>ctx.Done</code> channel in the <code>select</code> block in the <code>slowAPICall</code>
function. When we receive an empty <code>struct</code> via the <code>Done</code> channel, this
signifies the context cancellation, and we have to return a zero-value string
from the <code>slowAPICall</code> function:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#268bd2>func</span> <span style=color:#268bd2>slowAPICall</span>(ctx context.Context) <span style=color:#dc322f>string</span> {
	d <span style=color:#719e07>:=</span> rand.<span style=color:#268bd2>Intn</span>(<span style=color:#2aa198>5</span>)
	<span style=color:#719e07>select</span> {
	<span style=color:#719e07>case</span> <span style=color:#719e07>&lt;-</span>ctx.<span style=color:#268bd2>Done</span>():
		log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;slowAPICall was supposed to take %s seconds, but was canceled.&#34;</span>, d)
		<span style=color:#719e07>return</span> <span style=color:#2aa198>&#34;&#34;</span>
	<span style=color:#719e07>case</span> <span style=color:#719e07>&lt;-</span>time.<span style=color:#268bd2>After</span>(time.<span style=color:#268bd2>Duration</span>(d) <span style=color:#719e07>*</span> time.Second):
		log.<span style=color:#268bd2>Printf</span>(<span style=color:#2aa198>&#34;Slow API call done after %d seconds.\n&#34;</span>, d)
		<span style=color:#719e07>return</span> <span style=color:#2aa198>&#34;foobar&#34;</span>
	}
}</code></pre></div><p>(This is the reason we used a <code>select</code> block, instead of the <code>time.Sleep</code> - we
can just handle the <code>Done</code> channel in the <code>select</code> here.)</p><p>In our limited example, this does the trick – when we receive value through the
<code>Done</code> channel, we log a line to STDOUT and return an empty string. In more
complicated situations, such as sending real API requests, you might need to
close down connections or clean up file descriptors.</p><p>Let&rsquo;s spin up the server again and send a <code>cURL</code> request:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#586e75># The cURL command:</span>
$ curl localhost:8888
Timeout!

<span style=color:#586e75># The server output:</span>
$ go run server.go
2019/12/30 00:07:15 slowAPICall was supposed to take <span style=color:#2aa198>2</span> seconds, but was canceled.</code></pre></div><p>So check this out: we ran a <code>cURL</code> to the server, it took longer than 1 second,
and our server canceled the <code>slowAPICall</code> function. And we didn&rsquo;t need to write
almost any code for it. The <code>TimeoutHandler</code> did this for us - when the handler
took longer than expected, the <code>TimeoutHandler</code> stopped the execution of the
handler and canceled the request context.</p><p>The <code>TimeoutHandler</code> performs the context cancellation in <a href=https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L3217-L3263>the
<code>timeoutHandler.ServeHTTP</code>
method</a>:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// Taken from: https://github.com/golang/go/blob/bbbc658/src/net/http/server.go#L3217-L3263
</span><span style=color:#586e75></span><span style=color:#268bd2>func</span> (h <span style=color:#719e07>*</span>timeoutHandler) <span style=color:#268bd2>ServeHTTP</span>(w ResponseWriter, r <span style=color:#719e07>*</span>Request) {
        ctx <span style=color:#719e07>:=</span> h.testContext
        <span style=color:#719e07>if</span> ctx <span style=color:#719e07>==</span> <span style=color:#cb4b16>nil</span> {
        	<span style=color:#268bd2>var</span> cancelCtx context.CancelFunc
        	ctx, cancelCtx = context.<span style=color:#268bd2>WithTimeout</span>(r.<span style=color:#268bd2>Context</span>(), h.dt)
        	<span style=color:#719e07>defer</span> <span style=color:#268bd2>cancelCtx</span>()
        }
        r = r.<span style=color:#268bd2>WithContext</span>(ctx)

        <span style=color:#586e75>// *Snipped*
</span><span style=color:#586e75></span>}</code></pre></div><p>Above, we use the request context by invoking <code>context.WithTimeout</code> on it. The
timeout value <code>h.dt</code>, which is the second argument received by the
<code>TimeoutHandler</code>, is applied to the context. The returned context is a copy of
the request context with a timeout attached. Right after, it&rsquo;s set as the
request&rsquo;s context using the <code>r.WithContext(ctx)</code> invocation.</p><p>The <code>context.WithTimeout</code> function makes the context cancellation. It returns a
copy of the <code>Context</code> with a timeout set to the duration passed as an argument.
Once it reaches the timeout, it cancels the context.</p><p>Here&rsquo;s the code that does it:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#586e75>// Taken from: https://github.com/golang/go/blob/bbbc6589/src/context/context.go#L486-L498
</span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>WithTimeout</span>(parent Context, timeout time.Duration) (Context, CancelFunc) {
	<span style=color:#719e07>return</span> <span style=color:#268bd2>WithDeadline</span>(parent, time.<span style=color:#268bd2>Now</span>().<span style=color:#268bd2>Add</span>(timeout))
}

<span style=color:#586e75>// Taken from: https://github.com/golang/go/blob/bbbc6589/src/context/context.go#L418-L450
</span><span style=color:#586e75></span><span style=color:#268bd2>func</span> <span style=color:#268bd2>WithDeadline</span>(parent Context, d time.Time) (Context, CancelFunc) {
        <span style=color:#586e75>// *Snipped*
</span><span style=color:#586e75></span>
        c <span style=color:#719e07>:=</span> <span style=color:#719e07>&amp;</span>timerCtx{
        	cancelCtx: <span style=color:#268bd2>newCancelCtx</span>(parent),
        	deadline:  d,
        }

        <span style=color:#586e75>// *Snipped*
</span><span style=color:#586e75></span>
        <span style=color:#719e07>if</span> c.err <span style=color:#719e07>==</span> <span style=color:#cb4b16>nil</span> {
        	c.timer = time.<span style=color:#268bd2>AfterFunc</span>(dur, <span style=color:#268bd2>func</span>() {
        		c.<span style=color:#268bd2>cancel</span>(<span style=color:#cb4b16>true</span>, DeadlineExceeded)
        	})
        }
        <span style=color:#719e07>return</span> c, <span style=color:#268bd2>func</span>() { c.<span style=color:#268bd2>cancel</span>(<span style=color:#cb4b16>true</span>, Canceled) }
}</code></pre></div><p>Here we meet deadlines again. The <code>WithDeadline</code> function sets a function that
executes after the duration <code>d</code> passes. Once the duration passes, it invokes
the <code>cancel</code> method on the context, which will close the <code>done</code> channel of the
context and will set the context&rsquo;s <code>timer</code> attribute to <code>nil</code>.</p><p>The closing of the <code>Done</code> channel effectively cancels the context, which allows
our <code>slowAPICall</code> function to stop its execution. That&rsquo;s how the
<code>TimeoutHandler</code> timeouts long-running handlers.</p><p>(If you would like to read the code that does the above, you should see the
<code>cancel</code> functions on <a href=https://github.com/golang/go/blob/bbbc6589dfbc05be2bfa59f51c20f9eaa8d0c531/src/context/context.go#L389-L416>the <code>cancelCtx</code>
type</a>
and <a href=https://github.com/golang/go/blob/bbbc6589dfbc05be2bfa59f51c20f9eaa8d0c531/src/context/context.go#L472-L484>the <code>timerCtx</code>
type</a>.)</p><h2 id=resilient-nethttp-servers>Resilient <code>net/http</code> servers<a hidden class=anchor aria-hidden=true href=#resilient-nethttp-servers>#</a></h2><p>Connection deadlines provide low-level fine-grained control. While their names
contain &ldquo;timeout&rdquo; they do not have the behavior that folks commonly expect from
timeouts. They are in fact very powerful, but they expect the programmer to
know how to wield that weapon.</p><p>On the other hand, when working with HTTP handlers, the <code>TimeoutHandler</code> should
be our go-to tool. The design chosen by the Go authors, of having composable
handlers, provides flexibility, so much that we could even have different
timeouts per handler if we decided to. <code>TimeoutHandler</code> provides execution
control while maintaining the behavior that we commonly expect when thinking of
timeouts.</p><p>On top of that, the <code>TimeoutHandler</code> works well with the <code>context</code> package.
While the <code>context</code> package is simple, it carries cancellation signals and
request-scoped data, that we can use to make our applications adhere better to
the intricacies of networks.</p><p>Before we close, here are three suggestions on how to think of timeouts while
writing your HTTP servers:</p><ol><li>Most-often, reach for <code>TimeoutHandler</code>. It does what we commonly expect of
timeouts.</li><li>Never forget context cancellations. The <code>context</code> package is simple to use
and can save your servers lots of processing resources. Especially againts
bad actors or misbehaving networks.</li><li>By all means, use deadlines. Just make sure you test thoroughly that they
provide you the functionality that you want.</li></ol><p>To read more on the topic:</p><ul><li>&ldquo;The complete guide to Go net/http timeouts&rdquo; on <a href=https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/>Cloudflare&rsquo;s
blog</a></li><li>&ldquo;So you want to expose Go on the Internet&rdquo; on <a href=https://blog.cloudflare.com/exposing-go-on-the-internet/>Cloudflare&rsquo;s
blog</a></li><li>&ldquo;Use http.TimeoutHandler or ReadTimeout/WriteTimeout?&rdquo; on
<a href=https://stackoverflow.com/questions/51258952/use-http-timeouthandler-or-readtimeout-writetimeout>Stackoverflow</a></li><li>&ldquo;Standard net/http config will break your production environment&rdquo; on <a href=https://blog.simon-frey.eu/go-as-in-golang-standard-net-http-config-will-break-your-production>Simon
Frey&rsquo;s
blog</a></li></ul><div id=revue-embed><form action=https://www.getrevue.co/profile/itsilija/add_subscriber method=post id=revue-form name=revue-form target=_blank><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to +1000 of other engineers.</p><div class=revue-form-group><input class=revue-form-field placeholder="Your email address..." type=email name=member[email] id=member_email></div><div class=revue-form-actions><input type=submit value=Subscribe name=member[subscribe] id=member_submit></div></form></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://ieftimov.com/post/testing-in-go-golden-files/><span class=title>« Prev Page</span><br><span>Testing in Go: Golden Files</span></a>
<a class=next href=https://ieftimov.com/post/testing-in-go-test-doubles-by-example/><span class=title>Next Page »</span><br><span>Testing in Go: Test Doubles by Example</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Make resilient Go net/http servers using timeouts, deadlines and context cancellation on twitter" href="https://twitter.com/intent/tweet/?text=Make%20resilient%20Go%20net%2fhttp%20servers%20using%20timeouts%2c%20deadlines%20and%20context%20cancellation&url=https%3a%2f%2fieftimov.com%2fpost%2fmake-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Make resilient Go net/http servers using timeouts, deadlines and context cancellation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2fmake-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation%2f&title=Make%20resilient%20Go%20net%2fhttp%20servers%20using%20timeouts%2c%20deadlines%20and%20context%20cancellation&summary=Make%20resilient%20Go%20net%2fhttp%20servers%20using%20timeouts%2c%20deadlines%20and%20context%20cancellation&source=https%3a%2f%2fieftimov.com%2fpost%2fmake-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Make resilient Go net/http servers using timeouts, deadlines and context cancellation on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2fmake-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation%2f&title=Make%20resilient%20Go%20net%2fhttp%20servers%20using%20timeouts%2c%20deadlines%20and%20context%20cancellation"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Make resilient Go net/http servers using timeouts, deadlines and context cancellation on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2fmake-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Make resilient Go net/http servers using timeouts, deadlines and context cancellation on whatsapp" href="https://api.whatsapp.com/send?text=Make%20resilient%20Go%20net%2fhttp%20servers%20using%20timeouts%2c%20deadlines%20and%20context%20cancellation%20-%20https%3a%2f%2fieftimov.com%2fpost%2fmake-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Make resilient Go net/http servers using timeouts, deadlines and context cancellation on telegram" href="https://telegram.me/share/url?text=Make%20resilient%20Go%20net%2fhttp%20servers%20using%20timeouts%2c%20deadlines%20and%20context%20cancellation&url=https%3a%2f%2fieftimov.com%2fpost%2fmake-resilient-golang-net-http-servers-using-timeouts-deadlines-context-cancellation%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>