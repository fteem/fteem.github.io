<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing Ruby's floats precision | Ilija Eftimov ⚡️</title><meta name=keywords content="floats,precision"><meta name=description content="Float precision in Ruby is a well known quirk. But when testing floats, not many of us bother to remember this and make their tests respectful to this quirk. In this post we will see how the popular Ruby testing frameworks help us test floats properly.
Background story Last week I published a post about migrating a test suite from RSpec to Minitest. What was very interesting is that I got a mention on Twitter from Ryan Davis with an offer for a code review of the migration."><meta name=author content="Ilija"><link rel=canonical href=https://ieftimov.com/post/testing-floats-in-ruby/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://ieftimov.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ieftimov.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ieftimov.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ieftimov.com/apple-touch-icon.png><link rel=mask-icon href=https://ieftimov.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script async defer data-domain=ieftimov.com src=https://plausible.io/js/plausible.js></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><meta property="og:title" content="Testing Ruby's floats precision"><meta property="og:description" content="Float precision in Ruby is a well known quirk. But when testing floats, not many of us bother to remember this and make their tests respectful to this quirk. In this post we will see how the popular Ruby testing frameworks help us test floats properly.
Background story Last week I published a post about migrating a test suite from RSpec to Minitest. What was very interesting is that I got a mention on Twitter from Ryan Davis with an offer for a code review of the migration."><meta property="og:type" content="article"><meta property="og:url" content="https://ieftimov.com/post/testing-floats-in-ruby/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Testing Ruby's floats precision"><meta name=twitter:description content="Float precision in Ruby is a well known quirk. But when testing floats, not many of us bother to remember this and make their tests respectful to this quirk. In this post we will see how the popular Ruby testing frameworks help us test floats properly.
Background story Last week I published a post about migrating a test suite from RSpec to Minitest. What was very interesting is that I got a mention on Twitter from Ryan Davis with an offer for a code review of the migration."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ieftimov.com/posts/"},{"@type":"ListItem","position":2,"name":"Testing Ruby's floats precision","item":"https://ieftimov.com/post/testing-floats-in-ruby/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing Ruby's floats precision","name":"Testing Ruby\u0027s floats precision","description":"Float precision in Ruby is a well known quirk. But when testing floats, not many of us bother to remember this and make their tests respectful to this quirk. In this post we will see how the popular Ruby testing frameworks help us test floats properly.\nBackground story Last week I published a post about migrating a test suite from RSpec to Minitest. What was very interesting is that I got a mention on Twitter from Ryan Davis with an offer for a code review of the migration.","keywords":["floats","precision"],"articleBody":"Float precision in Ruby is a well known quirk. But when testing floats, not many of us bother to remember this and make their tests respectful to this quirk. In this post we will see how the popular Ruby testing frameworks help us test floats properly.\nBackground story Last week I published a post about migrating a test suite from RSpec to Minitest. What was very interesting is that I got a mention on Twitter from Ryan Davis with an offer for a code review of the migration. Here’s the convo:\nRyan did the review for me, and one of his comments was:\nLets see why…\nRuby Float (im)precision Float numbers cannot store decimal numbers properly. The reason is that Float is a binary number format. What do I mean? Well, Ruby always converts Floats from decimal to binary and vice versa.\nThink about this very simple example. Whats the result of 1 divided by 3? Yup, 0.33333333333… The result of this calculation is 0.333(3), with 3 repeating until infinity.\nThis same rule, or quirk, applies to binary numbers. When a decimal number is converted to binary, the resulting binary number can be endless. Mathematically this is all fine. But in practice, my MacBook Air doesn’t have endless memory. I am running just on 4GBs of RAM, so Ruby must cut off the endless number at some point. Or it will fill up the whole memory of the computer and it will become useless. This mechanism of rounding numbers produces a rounding error and that’s exactly what we have to deal with here.\nSo, the base rule about this is: do not represent currency (or, money) with Float.\nIn practice Take this for an example. Simple calculation. We want to add 0.1 to 0.05, which should return 0.15. Right? Lets give it a try:\n1 2   0.1 + 0.05 == 0.15 = false   Okay, what? Let’s see what’s the result of the addition:\n1 2   0.1 + 0.05 = 0.15000000000000002   You can see that Ruby rounds off the number at the end. Lets print this number with 50 decimal points:\n1 2   sprintf(\"%0.50f\", 0.10 + 0.05) = \"0.15000000000000002220446049250313080847263336181641\"   Whoa! You can see that the actual result of this addition is quite different from 0.15. Ruby here rounds off the numbers, because the difference is so “microscopic”.\nIf you are curious, here’s how the numbers 0.10 and 0.05 actually look like with 50 decimal points in Ruby:\n1 2 3 4   sprintf(\"%0.50f\", 0.10) = \"0.10000000000000000555111512312578270211815834045410\"  sprintf(\"%0.50f\", 0.05) = \"0.05000000000000000277555756156289135105907917022705\"   Testing it Okay, so now when the problem is obvious, how can we test it? The best way to test this is to use a delta number. You can think of this delta number as a number showing the margin of rounding error.\nFor example, the delta for the 0.10 + 0.05 operation is approximately 0.0000000000000001.\nWith Minitest Minitest provides us the assert_in_delta and assert_in_epsilon methods.\nassert_in_delta It fails unless the expected and the actual values are within delta of each other.\n1 2 3  def test_precision assert_in_delta(0.15, 0.10 + 0.05, 0.0000000000000001) end   This means that, while we will expect to get 0.15 as a result, the rounding-off error can be as big as 0.0000000000000001.\nIf you see the source of this method, it’s quite easy to understand:\n1 2 3 4 5 6  # File minitest/unit.rb, line 122 def assert_in_delta exp, act, delta = 0.001, msg = nil n = (exp - act).abs msg = message(msg) { \"Expected #{exp}- #{act}(#{n}) to be #{delta}\" } assert delta = n, msg end   The delta must be larger or equal than the absolute value of the result of subtraction of the expected and the actual values.\nassert_in_epsilon This method behaves in a different matter than assert_in_delta. For example, if we use the delta as an epsilon, this test will fail:\n1 2 3  def test_precision assert_in_epsilon(0.15, 0.10 + 0.05, 0.0000000000000001) end   1 2 3 4 5 6 7 8 9  # Running: F Finished in 0.001584s, 1262.6263 runs/s, 1262.6263 assertions/s. 1) Failure: SomeTest#test_with_epsilon [test.rb:5]: Expected |0.15 - 0.15000000000000002| (2.7755575615628914e-17) to be    Why this happens is easier to see in the source of the assert_in_epsilon method:\n1 2 3 4  # File minitest/unit.rb, line 132 def assert_in_epsilon a, b, epsilon = 0.001, msg = nil assert_in_delta a, b, [a, b].min * epsilon, msg end   So, assert_in_epsilon is a wrapper for assert_in_delta with a small but important difference. The delta here is subject to “auto-scaling”. This means that it will increase for the product of the smaller number from the expected value/actual value pair and the epsilon.\nAlso, I guess, it’s called “epsilon” because the greek letter Epsilon is usually used to denote a small quantity (like a margin of error) or perhaps a number which will be turned into a zero within some limit.\nWith RSpec RSpec provides us the be_within matcher. The same rules apply here as the Minitest assert_in_delta method. The format is:\n1  expect().to be_within().of()   Or, in our case:\n1 2 3  it \"should match within a delta\" do expect(0.10 + 0.05).to be_within(0.0000000000000001).of(0.15) end   Conclusion Since the people behind RSpec and Minitest are awesome, they have provided us these methods where we can easily smooth out the edges of testing floats. What’s very important to understand here is that while testing this is pretty easy, it’s extremely important to know what to use when.\nWhen it comes to money/currency, every sane developer out there will use BigDecimal. It provides arbitrary-precision floating point decimal arithmetic, which means that it will always get a correct result for any calculation involving floating point numbers.\nAs an outro, I’ll leave you with this tweet:\n Liked this article? Subscribe to my newsletter and get future articles in your inbox. It's a short and sweet read, going out to +1000 of other engineers.  I care about your privacy, and will never send you spam. You can unsubscribe at any time.\n ","wordCount":"990","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Ilija"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ieftimov.com/post/testing-floats-in-ruby/"},"publisher":{"@type":"Organization","name":"Ilija Eftimov ⚡️","logo":{"@type":"ImageObject","url":"https://ieftimov.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://ieftimov.com/ accesskey=h title="Ilija Eftimov ⚡️ (Alt + H)">Ilija Eftimov ⚡️</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ieftimov.com/ title=About><span>About</span></a></li><li><a href=https://ieftimov.com/posts title=Writing><span>Writing</span></a></li><li><a href=https://ieftimov.com/newsletter title=Newsletter><span>Newsletter</span></a></li><li><a href=https://forms.gle/orfXK5jh1LRaiFzo8 title="Suggest a topic"><span>Suggest a topic</span></a></li><li><a href=https://www.buymeacoffee.com/ieftimov title="Buy me a ☕"><span>Buy me a ☕</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testing Ruby's floats precision</h1><div class=post-meta>July 21, 2015&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Ilija</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#background-story aria-label="Background story">Background story</a></li><li><a href=#ruby-float-imprecision aria-label="Ruby Float (im)precision">Ruby Float (im)precision</a></li><li><a href=#in-practice aria-label="In practice">In practice</a></li><li><a href=#testing-it aria-label="Testing it">Testing it</a><ul><li><a href=#with-minitest aria-label="With Minitest">With Minitest</a><ul><li><a href=#assert_in_delta aria-label=assert_in_delta>assert_in_delta</a></li><li><a href=#assert_in_epsilon aria-label=assert_in_epsilon>assert_in_epsilon</a></li></ul></li><li><a href=#with-rspec aria-label="With RSpec">With RSpec</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>Float precision in Ruby is a well known quirk. But when testing floats, not
many of us bother to remember this and make their tests respectful to this
quirk. In this post we will see how the popular Ruby testing frameworks help us
test floats properly.</p><h2 id=background-story>Background story<a hidden class=anchor aria-hidden=true href=#background-story>#</a></h2><p>Last week I published <a href=/migrate-rspec-to-minitest>a post about migrating a test suite from RSpec to
Minitest</a>. What was very interesting is that I got
a mention on Twitter from <a href=https://twitter.com/the_zenspider>Ryan Davis</a> with
an offer for a code review of the migration. Here&rsquo;s the convo:</p><p>Ryan did the review for me, and one of his comments was:</p><p>Lets see why&mldr;</p><h2 id=ruby-float-imprecision>Ruby Float (im)precision<a hidden class=anchor aria-hidden=true href=#ruby-float-imprecision>#</a></h2><p>Float numbers cannot store decimal numbers properly. The reason is that Float
is a binary number format. What do I mean? Well, Ruby always converts Floats
from decimal to binary and vice versa.</p><p>Think about this very simple example. Whats the result of 1 divided by 3? Yup,
0.33333333333&mldr; The result of this calculation is 0.333(3), with 3 repeating
until infinity.</p><p>This same rule, or quirk, applies to binary numbers. When a decimal number is
converted to binary, the resulting binary number can be endless. Mathematically
this is all fine. But in practice, my MacBook Air doesn&rsquo;t have endless memory.
I am running just on 4GBs of RAM, so Ruby must cut off the endless number at
some point. Or it will fill up the whole memory of the computer and it will
become useless. This mechanism of rounding numbers produces a rounding error
and that&rsquo;s exactly what we have to deal with here.</p><p>So, the base rule about this is: <strong>do not</strong> represent currency (or, money) with
Float.</p><h2 id=in-practice>In practice<a hidden class=anchor aria-hidden=true href=#in-practice>#</a></h2><p>Take this for an example. Simple calculation. We want to add 0.1 to 0.05, which
should return 0.15. Right? Lets give it a try:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; <span style=color:#00afaf>0</span>.<span style=color:#00afaf>1</span> + <span style=color:#00afaf>0</span>.<span style=color:#00afaf>05</span> == <span style=color:#00afaf>0</span>.<span style=color:#00afaf>15</span>
=&gt; <span style=color:#5f8700>false</span></code></pre></td></tr></table></div></div><p>Okay, what? Let&rsquo;s see what&rsquo;s the result of the addition:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; <span style=color:#00afaf>0</span>.<span style=color:#00afaf>1</span> + <span style=color:#00afaf>0</span>.<span style=color:#00afaf>05</span>
=&gt; <span style=color:#00afaf>0</span>.<span style=color:#00afaf>15000000000000002</span></code></pre></td></tr></table></div></div><p>You can see that Ruby rounds off the number at the end. Lets print this number
with 50 decimal points:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; <span style=color:#0087ff>sprintf</span>(<span style=color:#00afaf>&#34;%0.50f&#34;</span>, <span style=color:#00afaf>0</span>.<span style=color:#00afaf>10</span> + <span style=color:#00afaf>0</span>.<span style=color:#00afaf>05</span>)
=&gt; <span style=color:#00afaf>&#34;0.15000000000000002220446049250313080847263336181641&#34;</span></code></pre></td></tr></table></div></div><p>Whoa! You can see that the actual result of this addition is quite different
from 0.15. Ruby here rounds off the numbers, because the difference is so
&ldquo;microscopic&rdquo;.</p><p>If you are curious, here&rsquo;s how the numbers 0.10 and 0.05 actually look like
with 50 decimal points in Ruby:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>&gt;&gt; <span style=color:#0087ff>sprintf</span>(<span style=color:#00afaf>&#34;%0.50f&#34;</span>, <span style=color:#00afaf>0</span>.<span style=color:#00afaf>10</span>)
=&gt; <span style=color:#00afaf>&#34;0.10000000000000000555111512312578270211815834045410&#34;</span>
&gt;&gt; <span style=color:#0087ff>sprintf</span>(<span style=color:#00afaf>&#34;%0.50f&#34;</span>, <span style=color:#00afaf>0</span>.<span style=color:#00afaf>05</span>)
=&gt; <span style=color:#00afaf>&#34;0.05000000000000000277555756156289135105907917022705&#34;</span></code></pre></td></tr></table></div></div><h2 id=testing-it>Testing it<a hidden class=anchor aria-hidden=true href=#testing-it>#</a></h2><p>Okay, so now when the problem is obvious, how can we test it? The best way to
test this is to use a <strong>delta</strong> number. You can think of this delta number as a
number showing the margin of rounding error.</p><p>For example, the delta for the 0.10 + 0.05 operation is approximately
0.0000000000000001.</p><h3 id=with-minitest>With Minitest<a hidden class=anchor aria-hidden=true href=#with-minitest>#</a></h3><p>Minitest provides us the <code>assert_in_delta</code> and <code>assert_in_epsilon</code> methods.</p><h4 id=assert_in_delta>assert_in_delta<a hidden class=anchor aria-hidden=true href=#assert_in_delta>#</a></h4><p>It fails unless the expected and the actual values are within <strong>delta</strong> of each
other.</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#5f8700>def</span> <span style=color:#0087ff>test_precision</span>
  assert_in_delta(<span style=color:#00afaf>0</span>.<span style=color:#00afaf>15</span>, <span style=color:#00afaf>0</span>.<span style=color:#00afaf>10</span> + <span style=color:#00afaf>0</span>.<span style=color:#00afaf>05</span>, <span style=color:#00afaf>0</span>.<span style=color:#00afaf>0000000000000001</span>)
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>This means that, while we will expect to get 0.15 as a result, the rounding-off
error can be as big as 0.0000000000000001.</p><p>If you see the source of this method, it&rsquo;s quite easy to understand:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#4e4e4e># File minitest/unit.rb, line 122</span>
<span style=color:#5f8700>def</span> <span style=color:#0087ff>assert_in_delta</span> exp, act, delta = <span style=color:#00afaf>0</span>.<span style=color:#00afaf>001</span>, msg = <span style=color:#5f8700>nil</span>
  n = (exp - act).abs
  msg = message(msg) { <span style=color:#00afaf>&#34;Expected </span><span style=color:#00afaf>#{</span>exp<span style=color:#00afaf>}</span><span style=color:#00afaf> - </span><span style=color:#00afaf>#{</span>act<span style=color:#00afaf>}</span><span style=color:#00afaf> (</span><span style=color:#00afaf>#{</span>n<span style=color:#00afaf>}</span><span style=color:#00afaf>) to be &lt; </span><span style=color:#00afaf>#{</span>delta<span style=color:#00afaf>}</span><span style=color:#00afaf>&#34;</span> }
  assert delta &gt;= n, msg
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>The delta must be larger or equal than the absolute value of the result of subtraction
of the expected and the actual values.</p><h4 id=assert_in_epsilon>assert_in_epsilon<a hidden class=anchor aria-hidden=true href=#assert_in_epsilon>#</a></h4><p>This method behaves in a different matter than <code>assert_in_delta</code>. For
example, if we use the delta as an epsilon, this test will fail:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#5f8700>def</span> <span style=color:#0087ff>test_precision</span>
  assert_in_epsilon(<span style=color:#00afaf>0</span>.<span style=color:#00afaf>15</span>, <span style=color:#00afaf>0</span>.<span style=color:#00afaf>10</span> + <span style=color:#00afaf>0</span>.<span style=color:#00afaf>05</span>, <span style=color:#00afaf>0</span>.<span style=color:#00afaf>0000000000000001</span>)
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#4e4e4e># Running:</span>

F

Finished in 0.001584s, 1262.6263 runs/s, 1262.6263 assertions/s.

  1) Failure:
SomeTest#test_with_epsilon [test.rb:5]:
Expected |0.15 - 0.15000000000000002| (2.7755575615628914e-17) to be &lt;= 1.5e-17.</code></pre></td></tr></table></div></div><p>Why this happens is easier to see in the source of the <code>assert_in_epsilon</code>
method:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#4e4e4e># File minitest/unit.rb, line 132</span>
<span style=color:#5f8700>def</span> <span style=color:#0087ff>assert_in_epsilon</span> a, b, epsilon = <span style=color:#00afaf>0</span>.<span style=color:#00afaf>001</span>, msg = <span style=color:#5f8700>nil</span>
  assert_in_delta a, b, [a, b].min * epsilon, msg
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><p>So, <code>assert_in_epsilon</code> is a wrapper for <code>assert_in_delta</code> with a small but
important difference. The delta here is subject to &ldquo;auto-scaling&rdquo;. This means
that it will increase for the product of the smaller number from the expected
value/actual value pair and the epsilon.</p><p>Also, I guess, it&rsquo;s called &ldquo;epsilon&rdquo; because the greek letter Epsilon is usually used to
denote a small quantity (like a margin of error) or perhaps a number which will be
turned into a zero within some limit.</p><h3 id=with-rspec>With RSpec<a hidden class=anchor aria-hidden=true href=#with-rspec>#</a></h3><p>RSpec provides us the <code>be_within</code> matcher. The same rules apply here as the
Minitest <code>assert_in_delta</code> method. The format is:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>expect(&lt;actual&gt;).to be_within(&lt;delta&gt;).of(&lt;expected&gt;)</code></pre></td></tr></table></div></div><p>Or, in our case:</p><div class=highlight><div style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#454545">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#454545">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>it <span style=color:#00afaf>&#34;should match within a delta&#34;</span> <span style=color:#5f8700>do</span>
  expect(<span style=color:#00afaf>0</span>.<span style=color:#00afaf>10</span> + <span style=color:#00afaf>0</span>.<span style=color:#00afaf>05</span>).to be_within(<span style=color:#00afaf>0</span>.<span style=color:#00afaf>0000000000000001</span>).of(<span style=color:#00afaf>0</span>.<span style=color:#00afaf>15</span>)
<span style=color:#5f8700>end</span></code></pre></td></tr></table></div></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Since the people behind RSpec and Minitest are awesome, they have provided us
these methods where we can easily smooth out the edges of testing floats.
What&rsquo;s very important to understand here is that while testing this is pretty
easy, it&rsquo;s <strong>extremely</strong> important to know what to use when.</p><p>When it comes to money/currency, every sane developer out there will use
<a href=http://ruby-doc.org/stdlib-2.1.1/libdoc/bigdecimal/rdoc/BigDecimal.html>BigDecimal</a>.
It provides arbitrary-precision floating point decimal arithmetic, which means
that it will <strong>always</strong> get a correct result for any calculation involving
floating point numbers.</p><p>As an outro, I&rsquo;ll leave you with this tweet:</p><section class=subscribe><p><b>Liked this article?</b>
Subscribe to my newsletter and get future articles in your inbox. It's a
short and sweet read, going out to +1000 of other engineers.</p><script async data-uid=5495dc64a0 src=https://ilija.ck.page/5495dc64a0/index.js></script><p class=privacy>I care about your privacy, and will never send you spam. You can unsubscribe at any time.</p></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://ieftimov.com/tags/floats/>floats</a></li><li><a href=https://ieftimov.com/tags/precision/>precision</a></li></ul><nav class=paginav><a class=prev href=https://ieftimov.com/post/exception-handling-and-testing/><span class=title>« Prev Page</span><br><span>Exception handling and testing it with Minitest</span></a>
<a class=next href=https://ieftimov.com/post/migrate-rspec-to-minitest/><span class=title>Next Page »</span><br><span>Migrating a test suite from RSpec to Minitest</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Testing Ruby's floats precision on twitter" href="https://twitter.com/intent/tweet/?text=Testing%20Ruby%27s%20floats%20precision&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-floats-in-ruby%2f&hashtags=floats%2cprecision"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing Ruby's floats precision on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-floats-in-ruby%2f&title=Testing%20Ruby%27s%20floats%20precision&summary=Testing%20Ruby%27s%20floats%20precision&source=https%3a%2f%2fieftimov.com%2fpost%2ftesting-floats-in-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing Ruby's floats precision on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-floats-in-ruby%2f&title=Testing%20Ruby%27s%20floats%20precision"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing Ruby's floats precision on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fieftimov.com%2fpost%2ftesting-floats-in-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing Ruby's floats precision on whatsapp" href="https://api.whatsapp.com/send?text=Testing%20Ruby%27s%20floats%20precision%20-%20https%3a%2f%2fieftimov.com%2fpost%2ftesting-floats-in-ruby%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Testing Ruby's floats precision on telegram" href="https://telegram.me/share/url?text=Testing%20Ruby%27s%20floats%20precision&url=https%3a%2f%2fieftimov.com%2fpost%2ftesting-floats-in-ruby%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright 2021 © Ilija Eftimov</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>