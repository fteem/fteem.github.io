<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>caching on Ilija Eftimov</title>
    <link>https://ieftimov.com/tags/caching/</link>
    <description>Recent content in caching on Ilija Eftimov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Â© 2014 - 2019 Ilija Eftimov</copyright>
    <lastBuildDate>Mon, 11 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ieftimov.com/tags/caching/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Barebones model of Spotify&#39;s &#39;Recently Played&#39; screen using a Least Recently Used (LRU) cache in Golang</title>
      <link>https://ieftimov.com/post/barebones-model-of-spotifys-recently-played-screen-using-a-least-recently-used-lru-cache-in-golang/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ieftimov.com/post/barebones-model-of-spotifys-recently-played-screen-using-a-least-recently-used-lru-cache-in-golang/</guid>
      <description>One of the most used caching schemes is Least Recently Used (LRU). Caches that use this eviction strategy will remove the least recently used item when their size reaches their capacity. That means that such caches have to keep a track of the order of access of the cached items, so it would evict the correct items.
Image taken from Undraw.  Before we go too much into details about the implementation of an LRU cache, let&#39;s first see what are the possible applications of this caching scheme.</description>
    </item>
    
  </channel>
</rss>